<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lambda Calculus on fyshXplore</title>
        <link>http://fyshxfish.github.io/tags/lambda-calculus/</link>
        <description>Recent content in Lambda Calculus on fyshXplore</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <lastBuildDate>Sat, 07 Sep 2024 23:18:00 +0800</lastBuildDate><atom:link href="http://fyshxfish.github.io/tags/lambda-calculus/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Message Passing 视角下的 Bool - SICP § 2.4.3 | 泛型 | 数据与函数的边界 </title>
        <link>http://fyshxfish.github.io/p/message-passing-%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84-bool-sicp-2.4.3-%E6%B3%9B%E5%9E%8B-%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%BE%B9%E7%95%8C/</link>
        <pubDate>Sat, 07 Sep 2024 23:18:00 +0800</pubDate>
        
        <guid>http://fyshxfish.github.io/p/message-passing-%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84-bool-sicp-2.4.3-%E6%B3%9B%E5%9E%8B-%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%BE%B9%E7%95%8C/</guid>
        <description>&lt;h2 id=&#34;本文概述&#34;&gt;&lt;a href=&#34;#%e6%9c%ac%e6%96%87%e6%a6%82%e8%bf%b0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;本文概述
&lt;/h2&gt;&lt;p&gt;SICP § 2.4.3 中描述了以查表（ type × operation 二维表）为实现方式的泛型系统，具体函数被隐藏在泛型函数 + Selector 这样的抽象之下，那么如果将具体函数放在数据 + Selector 这样的抽象之下是什么样的呢，本文呈现了符合此抽象（SICP 中称为 Message Passing）的 Boolean.  接下来从 Message Passing，Haskell 中的 &lt;code&gt;$&lt;/code&gt; 和 Church Encoding 三个角度聊聊数据与函数之间的关系.  Message Passing - 让数据自己携带函数；Haskell &lt;code&gt;$&lt;/code&gt;的应用 - 将数据变成某种函数；Church Encoding - 抽象&amp;quot;计数的&amp;quot;计算过程.&lt;/p&gt;
&lt;h2 id=&#34;关于泛型&#34;&gt;&lt;a href=&#34;#%e5%85%b3%e4%ba%8e%e6%b3%9b%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;关于泛型
&lt;/h2&gt;&lt;p&gt;在 2.4.3 这一节中，作者构建了一个泛型系统，泛型是什么呢，是一种抽象；对于具备某种类似&lt;strong&gt;特性&lt;/strong&gt;的若干个类型，如果我们可以对于某个类型，依赖这个&lt;strong&gt;特性&lt;/strong&gt;写一个函数，那么我们希望将这个函数推广到具备这个&lt;strong&gt;特性&lt;/strong&gt;的其他类型，例如：对于两个 &lt;code&gt;Int&lt;/code&gt; 类型的值，我可以对其最大值进行计算（&lt;code&gt;max Int Int&lt;/code&gt;），因为 &lt;code&gt;Int&lt;/code&gt; 是&lt;strong&gt;可以比较 (Orderable)&lt;/strong&gt; 的，即，&lt;code&gt;Int&lt;/code&gt; 类型提供了 &lt;code&gt;&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;&lt;/code&gt; / &amp;hellip; 等比较函数的实现，那么，对于其他&lt;strong&gt;可比&lt;/strong&gt;的（提供比较函数实现的）类型，我们希望可以将 &lt;code&gt;max&lt;/code&gt; 推广到这些类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Ord&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们将&lt;strong&gt;可比&lt;/strong&gt;这个特性抽象成 &lt;code&gt;Ord&lt;/code&gt; 类型类（type class），&lt;code&gt;max&lt;/code&gt; 函数可以作用于任意该类的成员类型， .&lt;/p&gt;
&lt;p&gt;当我们在任意 &lt;code&gt;Ord&lt;/code&gt; 类的类型上应用 &lt;code&gt;max&lt;/code&gt; 函数时，编译器会帮我们&lt;u&gt;找到&lt;/u&gt;对应类型的 &lt;code&gt;&amp;gt;=&lt;/code&gt; 的具体实现.&lt;/p&gt;
&lt;p&gt;那么如何&lt;u&gt;找到&lt;/u&gt;？一种答案是：查表. 当我需要对 &lt;code&gt;Float&lt;/code&gt; (type) 执行 &lt;code&gt;max&lt;/code&gt; (operation) ，那么我在 type × operation 的笛卡尔积中找到 (&lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;) 对应的函数 (也就是 &lt;code&gt;Float&lt;/code&gt; 对应的 &lt;code&gt;max&lt;/code&gt; 非泛型具体实现) 就可以了.&lt;/p&gt;
&lt;img src=&#34;generic_table.png&#34; alt=&#34;generic_table&#34; style=&#34;zoom:80%; box-shadow: 2px 2px 3px rgba(155, 171, 187,0.7);&#34; /&gt;
&lt;p&gt;SICP Page 252: 泛型就是把 type × operation 这张表分解成一行一行的，每个泛型函数代表一行. ✨&lt;/p&gt;
&lt;img src=&#34;table_rows.png&#34; alt=&#34;table_rows&#34; style=&#34;zoom:80%; box-shadow: 2px 2px 3px rgba(155, 171, 187,0.7);&#34; /&gt;
&lt;!-- ## Intelligent Operations V.S. Intelligent Data Objects --&gt;
&lt;!-- ## Intelligent Data Objects --&gt;
&lt;h2 id=&#34;数据与函数的边界&#34;&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e4%b8%8e%e5%87%bd%e6%95%b0%e7%9a%84%e8%be%b9%e7%95%8c&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;数据与函数的边界
&lt;/h2&gt;&lt;h3 id=&#34;intelligent-operation-what-if-intelligent-data-objects&#34;&gt;&lt;a href=&#34;#intelligent-operation-what-if-intelligent-data-objects&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Intelligent Operation? WHAT IF Intelligent Data Objects?
&lt;/h3&gt;&lt;p&gt;在本文上一节中提到的泛型（泛型函数）中，数据作为被操作的客体存在，数据的工作就是&lt;strong&gt;被&lt;/strong&gt;函数作用，我们的泛型针对的是函数（operation），在我们的预期中，我们希望函数是聪明的，比如 &lt;code&gt;max :: (Ord a) =&amp;gt; a -&amp;gt; a -&amp;gt; a&lt;/code&gt; 是聪明的，对于它所作用的具体类型，它可以&amp;quot;自动&amp;quot;转变成该类型对应的非泛型具体实现 &lt;code&gt;max :: Int -&amp;gt; Int -&amp;gt; Int&lt;/code&gt;. 而数据只需要等待被作用就可以了.&lt;/p&gt;
&lt;p&gt;𝐖𝐡𝐚𝐭 𝐢𝐟: 让泛型函数找到数据对应的具体实现 → 让数据找到函数对应的具体实现？从分解 type × operation 表的角度说，将这张表分解成一列一列的，让某种数据（对应generic operation，暂且称之为 genetic? data）代表一列，这样如何呢？&lt;/p&gt;
&lt;img src=&#34;table_cols.png&#34; alt=&#34;table_cols&#34; style=&#34;zoom:80%; box-shadow: 2px 2px 3px rgba(155, 171, 187,0.7);&#34; /&gt;
&lt;p&gt;在 SICP 2.1.3 中谈及组合数据的提取时对此就有所呈现，本站的&lt;a class=&#34;link&#34; href=&#34;https://fyshxfish.github.io/p/huffman-%E6%A0%91%E7%9A%84-haskell-%E5%AE%9E%E7%8E%B0-sicp-2.3.4-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E8%A7%A3%E6%9E%84/#%e4%b8%80%e8%87%b4%e6%80%a7&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;上一篇博客&lt;/a&gt;也有提到. 在 SICP 2.1.3 中的侧重点还是在对组合数据本身的操作（提取字段）上：为了保证列表元素存取前后的一致性，我们将列表写成一个 procedure 向外提供，此 procedure 接收参数，并根据参数返回对应的列表元素.&lt;/p&gt;
&lt;p&gt;这里我们关心的是数据在程序中的行为，即 数据如何与函数、其他数据进行交互，我们希望&lt;strong&gt;数据自己携带与其他数据的交互方式&lt;/strong&gt;，而不是让数据作为只能被其他函数作用的静态实体. 基于这样的想法，尝试着写一个这样符合这样的行为规范的Bool.&lt;/p&gt;
&lt;h3 id=&#34;携带函数的-boolean&#34;&gt;&lt;a href=&#34;#%e6%90%ba%e5%b8%a6%e5%87%bd%e6%95%b0%e7%9a%84-boolean&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;携带函数的 Boolean
&lt;/h3&gt;&lt;!-- 示例：让 `Bool` (`tru` / `fls`) 找到 `and` / `or` 的具体实现： --&gt;
&lt;p&gt;首先给出类似的 type × operation 二维表，只是简单建模，所以就只考虑与或两种运算：&lt;/p&gt;
&lt;img src=&#34;tf_table.png&#34; alt=&#34;tf_table&#34; style=&#34;zoom:80%; box-shadow: 2px 2px 3px rgba(155, 171, 187,0.7);&#34; /&gt;
&lt;p&gt;类似于代表一行的泛型函数，写一个可以代表一列的&amp;quot;数据&amp;quot;，&lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;列对应的标识符分别为 &lt;code&gt;tru&lt;/code&gt;, &lt;code&gt;fls&lt;/code&gt;，如何让数据携带函数，一种答案是 让数据本身就是一个可以接收参数的函数，由参数来提取数据内禀的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt;                                   &lt;span class=&#34;c1&#34;&gt;; (define tru (lambda ...))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lambda &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;cond &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru_logic_and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;nv&#34;&gt;tru_logic_or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;fls&lt;/span&gt;                                   &lt;span class=&#34;c1&#34;&gt;; (define fls (lambda ...))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lambda &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;cond &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;fls_logic_and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;nv&#34;&gt;fls_logic_or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;lambda - cond&lt;/code&gt; 对应的函数（也就是柯里化的逻辑与或）实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scm&#34; data-lang=&#34;scm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;tru_logic_and&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;fls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;; 1 AND x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;tru_logic_or&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;                           &lt;span class=&#34;c1&#34;&gt;; 1 OR _ = 1        &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;fls_logic_and&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;fls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;                          &lt;span class=&#34;c1&#34;&gt;; 0 AND _ = 0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;fls_logic_or&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;eq? &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tru&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;fls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;; 0 OR x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 REPL 中查看 &lt;code&gt;tru&lt;/code&gt; &lt;code&gt;fls&lt;/code&gt;：毫无疑问两者都是 compound procedure&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; tru
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 13 tru]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; fls
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 12 fls]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;做一个简单的测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; ((tru &amp;#39;and) fls)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 12 fls]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们做了什么事情呢？首先 &lt;code&gt;tru&lt;/code&gt; 是接收符号参数的一个 &lt;code&gt;lambda&lt;/code&gt; 表达式，&lt;code&gt;(tru &#39;and)&lt;/code&gt; 得到的是 &lt;code&gt;tru_logic_and&lt;/code&gt; —— 一个柯里化的逻辑与（也就是已经传入了一个 &lt;code&gt;TRUE&lt;/code&gt; 的逻辑与），然后将 &lt;code&gt;tru_logic_and&lt;/code&gt; 应用于 &lt;code&gt;fls&lt;/code&gt; ，最后的返回值是 compound procedure &lt;code&gt;fls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;给出图示如下：&lt;/p&gt;
&lt;img src=&#34;msg_pasing_tru.png&#34; alt=&#34;message passing `tru`&#34; style=&#34;zoom:80%; box-shadow: 2px 2px 3px rgba(155, 171, 187,0.7);&#34; /&gt;
&lt;p&gt;如果表达式长一些：如果忽略一部分括号，看起来就是中缀的逻辑表达式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; ((((fls &amp;#39;or) tru) &amp;#39;and) fls)      ; ((0 or 1) and 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 12 fls]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果更偏好前缀调用，可以做一层小封装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scm&#34; data-lang=&#34;scm&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;define &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;logic&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对 &lt;code&gt;logic&lt;/code&gt; 进行测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; (logic &amp;#39;and tru fls)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 12 fls]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1 ]=&amp;gt; (logic &amp;#39;or (logic &amp;#39;and fls fls) tru)      ; (or (and 0 0) 1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;;Value: #[compound-procedure 13 tru]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;-message-passing-看待数据的另一种视角&#34;&gt;&lt;a href=&#34;#-message-passing-%e7%9c%8b%e5%be%85%e6%95%b0%e6%8d%ae%e7%9a%84%e5%8f%a6%e4%b8%80%e7%a7%8d%e8%a7%86%e8%a7%92&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;→ Message Passing: 看待数据的另一种视角
&lt;/h3&gt;&lt;p&gt;上面这种构建 Boolean 的编程风格被称为 Message Passing：一个数据是一个接收操作名（message）的实体，例如：&lt;code&gt;tru&lt;/code&gt; 可以接收 &lt;code&gt;&#39;and&lt;/code&gt; / &lt;code&gt;&#39;or&lt;/code&gt; 这样的 Message 并返回对应的柯里化函数供我们后续使用. 在这样的视角下，数据本身和&lt;strong&gt;数据所携带的方法&lt;/strong&gt;一样重要，也是&amp;quot;数据即程序&amp;quot;的一种体现. 不知道看到这里的你是否也在此处察觉到了一些面向对象的风味.&lt;/p&gt;
&lt;!-- 面向对象？ --&gt;
&lt;h3 id=&#34;haskell-中的-&#34;&gt;&lt;a href=&#34;#haskell-%e4%b8%ad%e7%9a%84-&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Haskell 中的 &lt;code&gt;$&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 的作用是改变表达式求值顺序，从而减少代码中的括号量，从类型签名上去观察，可以看到，&lt;code&gt;$&lt;/code&gt; 把一个数据变成了一个函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ghci&amp;gt; x = 5 :: Int
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ghci&amp;gt; :t ($ x)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;($ x) :: (Int -&amp;gt; b) -&amp;gt; b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- `($ x)`是一个可以被其他函数（也就是类型签名中的 `Int -&gt; b` ）作用的一个函数. --&gt;
&lt;p&gt;&lt;code&gt;($ x)&lt;/code&gt; 把 &lt;code&gt;x&lt;/code&gt; 从静态数据，变成了一个等待被函数 &lt;code&gt;Int -&amp;gt; b&lt;/code&gt; 作用的数据（从类型签名上看，这是一个函数）. 基于这种理解，可以写这样的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ghci&amp;gt; map ($ 5) [(* 2), (+ 10), (^ 3)]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[10,15,125]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;church-encoding&#34;&gt;&lt;a href=&#34;#church-encoding&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Church Encoding
&lt;/h3&gt;&lt;!-- 如何在 lambda 演算中表示自然数？ --&gt;
&lt;!-- 从丘奇数出现在我的世界里的那一刻起，这个 --&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Church_encoding&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Church Encoding wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color: #888888; font-size: 0.85em;&#34;&gt;我对 Church Encoding 的理解不是很到位，所以先不在这里陈述，我一直对 Church Encoding 比较困惑，前两天看到一个&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/39930042/answer/2415190431?utm_psn=1816166240617631745&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;知乎回答&lt;/a&gt;给了我很大的启发. 不要像理解物理计算机所存储的数字一样去理解 Church Encoding，尽管 Church Encoding 经常被翻译成丘奇数，但就像前面提到的知乎回答中陈述的观点一样，Church Encoding 更多表达的是一种&lt;strong&gt;对计算过程的抽象&lt;/strong&gt;，而不是某个预备被存储在物理存储器中的具体数字. 接触以 lambda calculus 为起点的 FP 内容，尽量避免过拟合，甚至最好不要试图去拟合，很多困扰可能是过往的经验带给你的. &lt;/span&gt;&lt;/p&gt;
&lt;!-- 陈述待补充

--- 



睡觉了 Sun Sep  8 00:30:22 CST 2024

[TODO]:

- Haskell 中的 `$`

- 丘奇数

看待数据的视角有很多，内存与指针、代数数据类型、数据即程序（也就是 SICP / 本文中想陈述的视角）... 对于 # 数据即程序 # 这样的情况，也许我们更加关注的是: 数据携带了什么方法，数据可以为我们提供什么方法 / 函数
 --&gt;
</description>
        </item>
        
    </channel>
</rss>
