[{"content":"let 语义 结论: let scope 会直接求值 (包括绑定和绑定之后的表达式, 也就是 let 之外的一层括号所包裹的范围), 即使你把 let 嵌套在内层函数里而且这个函数还完全没有被调用.\n示例:\n(define (comp x) (if (\u0026gt; 3 x) (display \u0026#34;then-clause\u0026#34;) (display \u0026#34;else-clause\u0026#34;) ) #| (define foo1 (let ((bar1 (/ 2 0))) ; * evaluted conditionlessly (display \u0026#34;should not be printed\u0026#34;) ) ) |# (define foo2 (let ((bar2 (/ 5 2))) ; * evaluted conditionlessly (newline) (display \u0026#34;let in `foo2`, bar2: \u0026#34;) (display bar2) ) ) ) 运行示例:\nfoo1: 可以看到 let 绑定被求值了, 否则不会抛出除零异常.\nprompt\u0026gt; (comp 4) else-clause ;Division by zero signalled by /. ;To continue, call RESTART with an option number: ;snip foo2: 可以看到 let 绑定后的表达式被求值了, 否则不会有 display 的输出\nprompt\u0026gt; (comp 2) then-clause let in `foo2`, bar2: 5/2 ;Unspecified return value if 语义 if的语义: 根据对条件式进行求值，根据求值结果决定继续对 then/else 分支进行求值.\n可以与此对照参考的材料是 SICP (2nd Edition) Exercise 1.6，此题中使用 abstraction ，通过 cond 定义了 new-if:\n(define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause) ) ) 函数应用的语义是（applicative mode evaluation）：先对参数（比如这里的then-clause 和 else-clause）进行求值，然后进行函数应用，这也是为什么不能在then-clause 或 else-clause里写递归表达式，因为它们会先被求值，而不是根据 predicate 的值决定是否求值，于是递归就无穷无尽了. if/cond/\u0026hellip; 是 special form, 相较于通过 define 定义的 abstraction, 语义是特殊的. 我喜欢 new-if 这个例子，它简洁而有力地体现了 lisp 元编程的特性，通过此例也可以更好地接纳 lisp 里大量的括号，根据 substitution model, 这里的 predicate, then-clause, else-clause 可以替换成你需要的表达式, 而表达式就是被括号包裹的, 即 括号是表达式的边界, 你可以把被括号包裹的表达式放在任意的参数位 (当然要符合 abstraction 隐式的对于参数的类型约束).\n为什么会写这篇文本: 对于这样素数判断的一段代码：\n(define (prime? x) (if (or (= x 1) (= x 2)) #t test_prime ) (define (divisible? y) (= 0 (remainder x y)) ) (define (iter_biggest_divisor y) (cond ((= y 1) 1) ((divisible? y) y) (else (iter_biggest_divisor (- y 1))) ) ) (define test_prime (let ((biggest_divisor (iter_biggest_divisor (quotient x 2)) )) (display biggest_divisor) (if (= biggest_divisor 1) #t #f ) ) ) ) 运行的结果是:\nprompt\u0026gt; (prime? 1) ;The object 0, passed as the second argument to integer-remainder, is not in the correct range. prompt\u0026gt; (prime? 2) 1 ;Value: #t 按照预期, (prime? 1) 和 (prime? 2) 都应该直接返回 #t, 而不是前者报错, 后者呈现出 (display biggest_divisor) 的行为. 根据前文的陈述, 原因是: 整个 let scope 都被求值了.\n","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/scheme-let-%E7%9A%84%E8%AF%AD%E4%B9%89-feat.-if-%E7%9A%84%E8%AF%AD%E4%B9%89/","title":"Scheme: let 的语义 (feat. if 的语义)"},{"content":" Problem: Given a positive integer $n$, find all ordered pairs of distinct positive integers $i$ and $j$, where $ 1 \\leq i \\leq j \\leq n $, such that $ i + j $ is prime.\nisDivisible :: Int -\u0026gt; Int -\u0026gt; Bool isDivisible x y | mod x y == 0 = True | otherwise = False isPrime :: Int -\u0026gt; Bool isPrime x | x \u0026lt;= 2 = True | otherwise = not (foldr (||) False (map (isDivisible x) [2..((floor . sqrt . fromIntegral) x)])) genPairs :: Int -\u0026gt; [((Int, Int), Int)] genPairs n = do x \u0026lt;- [1..n] y \u0026lt;- [1..(x-1)] return ((y, x), (x + y)) sumPrimePairs :: Int -\u0026gt; [((Int, Int), Int)] sumPrimePairs = (filter (\\(_, s) -\u0026gt; (isPrime s))) . genPairs Context of List Monad : 不确定的结果.\n此章的标题是 Nested Mappings, 在代码层面的表现是嵌套的 lambda, Haskell 中的 do-notation 展开形式就是嵌套的 lambda, 前者是后者的语法糖.\n此章中定义的 flatMap 就是 Haskell 中的 \u0026gt;\u0026gt;= (bind).\n2024-08-30 补充： SICP page 168 集合全排列的 Haskell 实现\npermutations :: Eq a =\u0026gt; [a] -\u0026gt; [[a]] permutations [] = [[]] permutations xs = do x \u0026lt;- xs perm \u0026lt;- permutations $ removeByElem x xs return (x: perm) removeByElem :: Eq a =\u0026gt; a -\u0026gt; [a] -\u0026gt; [a] removeByElem x = filter (/= x) ","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/sicp-2.2.3-nested-mappings-%E6%A1%88%E4%BE%8B%E7%9A%84-haskell-%E5%AE%9E%E7%8E%B0-list-monad/","title":"SICP 2.2.3 Nested Mappings 案例的 Haskell 实现 (List Monad)"},{"content":"不严肃的随手记录，希望我能记得持续更新，因为我经常把一些记录扔在零零散散的位置，然后忘记这个记录的存在。\n首先在这里贴蒋炎岩老师的一场与VSCode相关的讲座，Ctrl+Shift+P：如果你需要做某些事情，可以先尝试用 Ctrl+Shift+P 打开命令面板搜索（比如也许你想重新加载VSCode窗口，你就可以 Ctrl+Shift+P 然后搜索\u0026quot;reload window\u0026quot;），如果你发现自己需要经常做这个动作，那么就 Ctrl+k Ctrl+s 进入 Keyboard Shortcuts 为这个操作绑定快捷键吧，配置快捷键的哲学就在于：发现自己经常重复做某件事情，有一个瞬间发现自己不想用鼠标再次重复这个过程，于是去检索记忆/配置这个热键。\n(如果后续VSCode Command Palette接入了语言模型，可以进行自然语言的模糊搜素，那应该会很不错。)\n\u0026raquo; 让VSCode的界面更简洁：隐藏Activity Bar和Status Bar 其实并不是时时刻刻都需要看到 Activity Bar 和 Status Bar，如果你也觉得它们占用了宝贵的屏幕空间，那么可以绑定以下快捷键：\nView: Toggle Activity Bar Visibility - Ctrl+Shift+9 View: Toggle Status Bar Visibility - Ctrl+Shift+8\n为什么是Ctrl+Shift+8/9：因为Shift+9对应的字符是左括号，和Activity Bar在形态上略有相似，顺手把Status Bar对应的快捷键设置为Ctrl+Shift+8，键位近比较顺手，因为我总是同时关闭此二者的可见性；想快捷键还是一个不那么容易的事情，容易和已有的键位绑定冲突，设置完了一段时间不用又会忘记，然后发现Ctrl+Shift+P检索才是永远的家。\n\u0026raquo; Terminal: Move Terminal to Editor Area 之前看蒋炎岩老师的课的时候发现他的终端tab和代码tab的形态是一致的，现在我也知道怎么做了，先Ctrl+Shift+P，在命令面板中检索Terminal: Move Terminal to Editor Area，即可将终端放置到Editor Area，其他类似操作还有Move Terminal to Panel, Create New Terminal in Editor Area\u0026hellip;当然，可以为你经常使用的操作绑定快捷键。\n一种适用的场景是：如果你在学习某种编程语言，而这种语言（比如Haskell, Lisp, Python\u0026hellip;）刚好有REPL，你就可以在Editor Area切分，一半放代码，一半放Terminal REPL，如果需要，可以编辑文件，然后在REPL中导入代码文件（像Haskell ghci中的:l foo.hs），这样就很方便，可以通过Ctrl+1/Ctrl+2在代码tab和终端tab之间做Focus的切换；视觉上我认为这样的体验也一些，比默认的上下分屏更好（毕竟更多情况下电脑的屏幕水平边比竖直边长，这也是为什么我喜欢竖直向的浏览器标签栏）。\n还有一种类似的实现：通过Ctrl+Shift+B打开Secondary Side Bar，把终端拖到Secondary Side Bar，不过在我的Windows的VScode上，我不能把终端拖到Secondary Side Bar展示，很奇怪，之前在Linux虚拟机上是可以的。\n\u0026raquo; Rainbow Brackets 在Settings(GUI)中键入@id:editor.bracketPairColorization.enabled @id:editor.guides.bracketPairs，选择你需要的选项，editor.bracketPairColorization.enabled是默认启用的，editor.guides.bracketPairs是默认关闭(false)的，可以选择true或者active启用，true的效果是所有括号都有引导线，active的效果是只有最接近光标的外层括号有引导线，我觉得active就很好了，true让编辑界面有点花里胡哨。效果如下：\n顺便一个快捷键：Ctrl+Shift+\\，可以在当前文本对应的左右括号之间跳转，给别人展示代码的时候也许有用，对应Vim Normal Mode下的%.(P.S. 此快捷键在Terminal中使用，可以用来在不同的Terminal tab中跳转)\n起因是我最近在看SICP，这本书使用的语言是lisp(scheme)，这门语言的括号实在是多(，真的有其他语言的语言设计中具备比lisp更多的括号吗？) 于是我在Extensions中搜索Rainbow Brackets，对应插件表示项目已放弃维护，因为此特性已由VSCode内置，并为我指路至Settings(GUI)的配置具体位置。\n\u0026raquo; 一些常用的快捷键 Baseline\n将光标悬停在GUI的button上，如果该button有对应的快捷键，弹出的悬窗会呈现快捷键信息（很多程序都遵循这个设计哲学），所以如果发现自己经常点击某个键，不妨停下来看看它对应的热键是什么。\nCtrl-b：toggle side bar.\n这里对应的一个故事是，有人给VSCode提了一个issue，希望VSCode提供一个类似toggleExplorerVisibility配置项，然后获得一个用户回复\u0026quot;Ctrl-B to toggle side bar\u0026quot;并关闭了此issue. 为什么我会知道这件事情，因为我也以为我的需求是toggleExplorerVisibility，结论是：明确每个组件的称呼很重要。(但是，一个热键对应toggle，两个热键分别对应show/hide，前者应该更合理一些。)\nAlt-left/right Arrow：回退到上一光标位置/前进到下一光标位置\n比较有用的一个情景是：和F12配合，在函数的调用链里导航。\nCtrl-[/]：对光标所在行左移/右移缩进。\n同 Vim Visual Mode 下的 \u0026gt;/\u0026lt;. Vim的这个键位我用着一直不是很顺，因为选中之后只能进行一次操作，如果想再做一次缩进，那要再选一次，虽然是可以2 \u0026gt;这样向右缩进两个tab，但是对我来说还是没有那么顺，自从发现在编辑中使用 Ctrl/Shift/Alt 可以做一些跳转/选中等操作，我就很少离开Vim Insert Mode了，当然这些热键在语义化的方面是比不过Vim的键位。\nAlt-up/down Arrow：上移/下移光标所在行。\nShift-Alt-f: format 代码，前提是配置好了formatter.\n于是我不再需要手动调空格/空行的数量，Ctrl-v的时候也不必担心光标所在列，粘贴完一键format完事，很可惜像Python这样强制缩进的语言不太好format.\nCtrl-(Shift-)Enter: 在当前光标所在行下(上)方新建一行，光标跳转到新行行首。\n同 Vim Normal Mode 下的 o(O).\n(最近的一个需求是：希望可以选中若干行代码，然后一个快捷键删除所有的空行.)\n","date":"2024-08-26T00:00:00+08:00","image":"http://fyshxfish.github.io/p/vscode-%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/cover_hu6990843420303988956.png","permalink":"http://fyshxfish.github.io/p/vscode-%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"VSCode 配置与使用记录"},{"content":" 如何调试一个rust程序？ $ gdb excutable 简单的示例：\n查看变量的地址：\n格式化p s的输出：\n$17 = alloc::string::String { vec: alloc::vec::Vec\u0026lt;u8, alloc::alloc::Global\u0026gt; { buf: alloc::raw_vec::RawVec\u0026lt;u8, alloc::alloc::Global\u0026gt; { ptr: core::ptr::unique::Unique\u0026lt;u8\u0026gt; { pointer: core::ptr::non_null::NonNull\u0026lt;u8\u0026gt; { pointer: 0x5555555abb80 }, _marker: core::marker::PhantomData\u0026lt;u8\u0026gt; }, cap: alloc::raw_vec::Cap (16), alloc: alloc::alloc::Global }, len: 16 } } 提要：p \u0026lt;variable\u0026gt; p \u0026amp;\u0026lt;variable\u0026gt; ptype \u0026lt;variable\u0026gt;\ndbg! 辅助输出调试信息中的所有权问题 错误的：\ndbg!(var); // move dbg!(var); // invalid reference dbg!将拿走var的所有权(Move)，var就不能再用了。\n正确的：\ndbg!(\u0026amp;var); // or let new_var = dbg!(var); dbg!(\u0026amp;new_var); // if u will 关于 gdb 对于想探究的东西，使用gdb去进行探索，例如：[enum的底层表示？] -\u0026gt; 写一个简单的例程，编译成可执行文件，然后进行gdb，使用print var print \u0026amp;var x/x \u0026lt;addr\u0026gt;进行探索。\n关于对 vector 的引用 一个摘录\nch08-01\n/* CANNOT COMPILE */ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n一个问题：如何让一个Vector看起来存储了多种类型的数据？ 答案：让Vector存储enum，enum含有多种类型的variant，在某种程度上可以说Vector存储了多种类型的数据。\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Text(String::from(\u0026#34;word\u0026#34;)), CellType::Float(3.14), ]; let v1 = \u0026amp;v[0]; } enum CellType { Int(i32), Float(f64), Text(String), } gdb 调试 enum 示例与 gdb（以及其他REPL）中的 history variable 源代码：\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Float(3.14), ]; let v1: \u0026amp;CellType = \u0026amp;v[0]; let v2: \u0026amp;CellType = \u0026amp;v[1]; println!(\u0026#34;END\u0026#34;); } enum CellType { Int(i32), Float(f64), } 调试实录：\np v1：打印v1: \u0026amp;CellType的值，也就是指针值，即附带数据存储在堆上的地址，注意到v1, v2对应的数据各占据了16个字节。 x/4x $1：检查v1指针指向的16字节 p *v1：解引用v1查看该内存处存储的实际值 enum在计算机中存储的实际数据分析\n第一个字节应该是variant标识符，对应关系：0-Int 1-Float Int：附带数据存储在第二个字节，0x0000000c即代码中的Int(12) Float：附带的数据存储在第三、四个字节0x40091eb8_51eb851f是3.14的IEEE 754 64bit表示 遗留的问题：为什么上述两变体存储附加数据的位置不同，Float中的0x00005555是什么？ gdb的使用拾遗 (history variable)：\np var 打印出来的 $x 是一种 history variable, 供用户后续复用的，类似的 REPL 行为还有bash 里 echo $(ls)，mit-scheme 也会为返回的 procedure 给出一个可引用的 history variable（不过这个 variable 很长，且包含了 #[] 等特殊字符，真正要复用还是要复制一遍标识符，绑定在某个标识符上再复用。）。\nRUST_BACKTRACE 与命令行拾遗 $ RUST_BACKTRACE=1 cargo run $ A=12 B=23 echo \u0026#34;$A $B\u0026#34; 在命令的最左可以写临时的环境变量。\n花里胡哨的技术：rust的println的色彩转义 println!(\u0026#34;\\x1b[34mMESSAGE\\x1b[0m\u0026#34;); 使用\\x1b[34m进行转义\n\\x1b是什么？\n\\x表十六进制，1b是ESC的ASCII十六进制码\nResult\u0026lt;T, E\u0026gt;的unwrap和expect 之间的区别： 适当地看一些库函数的实现，可以对封装好的函数有更具体的了解，例如Result\u0026lt;T, E\u0026gt;的unwrap和expect，看过源码就可以知道这两者的区别在于何处（只在于unwrap_failed的msg参数，至于unwrap_failed只是一个对panic!的封装）：\nimpl\u0026lt;T, E\u0026gt; Result\u0026lt;Result\u0026lt;T, E\u0026gt;, E\u0026gt; { ... pub fn expect(self, msg: \u0026amp;str) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(msg, \u0026amp;e), } } pub fn unwrap(self) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(\u0026#34;called `Result::unwrap()` on an `Err` value\u0026#34;, \u0026amp;e), } } ... } fn unwrap_failed(msg: \u0026amp;str, error: \u0026amp;dyn fmt::Debug) -\u0026gt; ! { panic!(\u0026#34;{msg}: {error:?}\u0026#34;) } ","date":"2024-08-05T00:00:00Z","permalink":"http://fyshxfish.github.io/p/rust-%E5%9F%BA%E7%A1%80%E4%B8%8E-gdb-%E4%BD%BF%E7%94%A8%E6%8B%BE%E9%81%97/","title":"Rust 基础与 gdb 使用拾遗"}]