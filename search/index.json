[{"content":" å¼•è¨€ æ ‡é¢˜çš„è¿™ä¸ªé—®é¢˜ï¼Œå…¶å®æ˜¯ä¸€ä¸ªä¸å¤ªæ­£ç¡®çš„é—®é¢˜ï¼Œå› ä¸ºå¯¹äºè¯­è¨€è€Œè¨€ï¼Œè®¾è®¡å…ˆäºå®ç°â€”â€”å…ˆè®¾è®¡è¯­è¨€çš„è¯­æ³•å’Œè¯­ä¹‰ï¼Œç„¶åå†™ç¼–è¯‘å™¨å»æ£€æŸ¥ä¸€ä¸ªç¨‹åºè¯­æ³•æ˜¯å¦æ­£ç¡®ï¼Œç„¶åæ ¹æ®è®¾å®šå¥½çš„è¯­ä¹‰å°†å®ƒè½¬å†™æˆç›®æ ‡æœºå™¨ä»£ç ã€‚ä»â€œä¸Šä¸‹æ–‡â€è¿™ä¸ªè§†è§’å»æ€è€ƒï¼Œå¸¸è§æƒ…å†µä¸‹ï¼Œè¯­æ³•æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„ï¼Œè€Œè¯­ä¹‰æ­£æ˜¯ç”¨æ¥å¤„ç†ä¸Šä¸‹æ–‡ç›¸å…³çš„é—®é¢˜çš„ï¼Œx = 1; print(x); å’Œ x = 2; print(x);ï¼ŒåŒæ ·æ˜¯ print(x)ï¼Œå®ƒçš„ä¸Šæ–‡æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‰€ä»¥å®ƒå¯¼è‡´çš„ç»“æœä¹Ÿä¸ä¸€æ ·.\nä¸¾ä¾‹ 1 æ¯”å¦‚ï¼š\nfoo = 3 foo = 4 å‡è®¾å¯¹è¿™ä¸ªç¨‹åºåªåšè¯­æ³•åˆ†æï¼Œé‚£ä¹ˆå®ƒç¬¦åˆ Python è¯­æ³•ï¼Œä¹Ÿç¬¦åˆ Haskell è¯­æ³•ï¼Œä½†æ˜¯å¯¹å®ƒåšè¯­ä¹‰åˆ†æï¼Œä½œä¸ºä¸€ä¸ª Python ç¨‹åºï¼Œå®ƒçš„æ„æ€æ˜¯ï¼Œâ€œå…ˆå°† 3 èµ‹å€¼ç»™ fooï¼Œç„¶åå°† 4 èµ‹å€¼ç»™ fooâ€ï¼›ä½œä¸ºä¸€ä¸ª Haskell ç¨‹åºï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªåˆæ ¼çš„ Haskell ç¨‹åºï¼Œå› ä¸º Haskell è¯­ä¹‰ä¸å…è®¸åšé‡å¤çš„ç»‘å®šï¼Œæ‰€ä»¥æ ¸å¿ƒåŸå› æ˜¯ï¼ŒPython çš„ = çš„è¯­ä¹‰æ˜¯èµ‹å€¼ï¼ˆassignï¼‰ï¼Œå†…å­˜è¦†å†™ï¼ŒHaskell çš„ = çš„è¯­ä¹‰æ˜¯ç»‘å®šï¼ˆname bindingï¼‰ï¼Œä¸ºäº†ä¿è¯æ— å‰¯ä½œç”¨ã€æ‰§è¡Œé¡ºåºæ— å…³ç­‰ç‰¹æ€§ï¼Œåªå…è®¸å•æ¬¡ç»‘å®š.\nä¸¾ä¾‹2 - polyglot ä¸‹é¢è¿™ä¸ªç¨‹åºæ”¹å†™è‡ª polyglot(computing) wikipedia\n#define a /* echo -e \u0026#34;\\033[34mHello, World! from echo\\033[0m\u0026#34;;// \u0026amp;\u0026gt; /dev/null; x=5; if (($x)) // 2\u0026gt; /dev/null; then return 0; // 2\u0026gt; /dev/null; fi #define e ?\u0026gt; #define b */ #include \u0026lt;stdio.h\u0026gt; #define main() int main(void) #define printf printf( #define true ) #define function function main() { printf \u0026#34;\\033[31mHello, World! from main\\033[0m\\n\u0026#34;true/* 2\u0026gt; /dev/null | grep -v true*/; return 0; } #define c /* main #*/ å®ƒæ—¢ç¬¦åˆ C è¯­æ³•ï¼Œåˆç¬¦åˆ Bash è¯­æ³•ï¼Œç„¶è€Œç¼–è¯‘/è§£é‡Šæ‰§è¡Œå®ƒå¾—åˆ°çš„ç»“æœä¸åŒï¼Œå› ä¸ºä¸¤ä¸ªç¨‹åºçš„è¯­ä¹‰ä¸åŒï¼ˆå½“ç„¶ C å’Œ Bash çš„è¯­æ³•ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ï¼Œpolyglot ç¼–å†™çš„æ ¸å¿ƒå°±æ˜¯åˆ©ç”¨å„è¯­è¨€ä¹‹é—´çš„æ³¨é‡Š/å®/\u0026hellip;ä½¿ç”¨çš„ç¬¦å·ä¸åŒï¼Œç¬¦å·ï¼ˆå¹¿ä¹‰ï¼‰çš„ä½¿ç”¨å’Œå¸ƒå±€æ­£æ˜¯è¯­æ³•ä¾§å…³å¿ƒçš„äº‹æƒ…ï¼‰ï¼š\n","date":"2025-02-17T16:32:00+08:00","permalink":"http://localhost:1313/p/context-syntax-/-semantic-analysis/","title":"Context \u0026 Syntax / Semantic Analysis"},{"content":"Preface Inspiration came from a lecture by Yanyan Jiangï¼š[ç®—æ³•ç«èµ›å…¥é—¨] ä¸ºä»€ä¹ˆè¦é€¼å¤§å®¶ç”¨ NOILinuxï¼Ÿï¼Œæœ‰å‚è€ƒï¼Œä½†ä¸å®Œå…¨ä¸€æ ·.\nMastering this skill will allow you toâ€”display \u0026ldquo;slides\u0026rdquo; in the terminal. Its practicality is limited, but itâ€™s fun to play with Â·^v^Â·.\nDemo Implementation Overall Framework Directory .sh files are bash scripts for displaying a single slide, .md files are the Markdown content to be rendered, and .png files are the images to be displayed.\nLauncher First, print the cover (essentially outputting a page of rendered text in the terminal), then use read to take input and control slide behaviors such as page flipping, image display, exiting, etc.\n0_flow.shï¼š\n#!/bin/bash bash ./1_banner.sh ## print the cover pc=1\t# page counter while true do read -p \u0026#34;:\u0026#34; choice ## take input and control slide behaviors if [ \u0026#34;$choice\u0026#34; == \u0026#34;p\u0026#34; ]; then # previous page ((pc--)) bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then # display an image xdg-open ./load_init.png elif [[ $choice =~ ^[1-7]$ ]]; then # go to the specific page pc=$choice bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;E\u0026#34; ]; then # exit the script break else # default: next page ((pc++)) bash ./${pc}* fi done Single Page Display Displaying a single page essentially means showing a page of text. The basic steps are:\nClear the previous page\u0026rsquo;s content using clear; Calculate the total number of lines of the rendered text; To center the content vertically, calculate the padding for the top and bottom; Print the top padding, render and print the content text, then print the bottom padding. For example: (2_question.sh)\nclear length=`python3 renderer.py question.md | wc -l` total=`tput lines` sus=$((($total-$length)/2)) for ((i=1; i\u0026lt;=$sus; i++)) do echo done python3 renderer.py question.md for ((i=1; i\u0026lt;$sus; i++)) do echo done Image Display and External Program Calls Use read to take input. When the input is a specific character, use xdg-open to open a specific image. Close it with the ESC key after displaying.\nread -p \u0026#34;:\u0026#34; choice if [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then xdg-open ./picture.png fi Similarly, replacing xdg-open ... with other commands can play audio/video or execute various programs.\nText Rendering ASCII Art for Cover Pages Use figlet to display the theme word and lolcat to color it. Besides the font styles that come with figlet, you can find and download more font styles from figlet-fonts. The \u0026ldquo;Boot\u0026rdquo; shown above corresponds to the command figlet \u0026quot; Boot\u0026quot; -f roman | lolcat -S 30. (Another optional command-line tool is toilet.)\nESC Escape Sequences The printf command can output fancier text in the terminal using \\033 escape sequences. It can achieve simple effects like color, bold, italics, etc., and multiple effects can be combined. For example, the last line in the image corresponds to printf \u0026quot;\\033[2;34;01;21;09myour text\\033[0m\\n\u0026quot;. (This also applies to output in other programming languages. 033 is the octal ASCII code for ESC. The specific colors depend on the terminal\u0026rsquo;s color scheme.)\nMarkdown Rendering glow: glow is a command-line tool, used as glow foo.md. rich: rich is a Python library that can render Markdown. Other Interesting Command-Line Tools asciiquarium\nASCII Art aquarium, very beautiful. You can find the ASCII fish in my avatar here, above the third seaweed from the left in the image below:\noneko\nSummon a little cat, VERY cute:\ncowsay\ndialog\nInteractive TUI dialog boxes, which are also very suitable for single-page slide presentations, for example:\n#!/bin/bash choice=$(dialog --clear --title \u0026#34;Menu\u0026#34; --menu \u0026#34;Make Your Choice\u0026#34; 10 40 3 \\ 1 \u0026#34;Show Greeting\u0026#34; 2 \u0026#34;Enter Something\u0026#34; 3 \u0026#34;Show Figure\u0026#34; 2\u0026gt;\u0026amp;1 \u0026gt;/dev/tty) case $choice in 3) xdg-open ./figure_1.png ;; # SNIP # esac ","date":"2025-02-07T22:52:00+08:00","permalink":"http://localhost:1313/p/slides-but-in-terminal/","title":"Slides, But in Terminal"},{"content":"Following exercise is from functional and is available on Steam for 29 CNY.\nBasic anything å†™å‡ºä»»æ„ä¸€ä¸ªç¬¦åˆ Lambda Calculus è¯­æ³• (1. variable 2. abstraction 3. application) çš„ term å³å¯.\nidentity x: x two arguments x:y: y x squaring f:x: f (f x) indirection f:x:y: f y x Boolean å®šä¹‰ï¼š\nTRUE = t:f: t FALSE = t:f: f IF p:t:f: p t f Simple LC æ²¡æœ‰ç±»å‹ç³»ç»Ÿï¼Œæ‰€ä»¥ç¼–ç¨‹è€…éœ€è¦è‡ªå·±ç¡®ä¿ p ä¸€å®šèƒ½æ±‚å€¼åˆ° TRUE / FALSEï¼Œç„¶å p t f è¿›ä¸€æ­¥æ±‚å€¼åˆ° t/ fï¼Œå¦‚æœ p ä¸èƒ½è¢«æ±‚å€¼åˆ° TRUE / FALSEï¼Œé‚£ä¹ˆ p t f ä¼šè¢«ä¿ç•™ä¸‹æ¥æˆ–è€…äº§ç”Ÿé¢„æœŸå¤–çš„æ±‚å€¼è¡Œä¸º.\nä½ å¯ä»¥è½»æ¾æ³¨æ„åˆ°çš„ä¸€ç‚¹æ˜¯ï¼šIF P A B â‰¡ P A Bï¼Œä½ å®Œå…¨å¯ä»¥åœ¨æ‰€æœ‰ä½¿ç”¨ IF çš„åœºåˆçœç•¥æ‰ IFï¼Œè¿™ä¸æ”¹å˜è¯­ä¹‰ï¼ŒåŒæ—¶å¯ä»¥å‡å°‘ä¸€æ¬¡ reductionï¼Œä¸è¿‡ä¸ºäº†ä¿è¯å¯è¯»æ€§ï¼Œè¿˜æ˜¯æœ‰ç†ç”±åœ¨æœ‰ç‚¹å¤æ‚çš„ç¨‹åºé‡Œä¿ç•™ IF.\nNOT b: b FALSE TRUE è¿™ä¸ªçœ‹ç€æœ‰ç‚¹éšéšçº¦çº¦çš„å·§å¦™. å¯ä»¥ç›´ç™½åœ°é€šè¿‡ b: IF b FALSE TRUE â†’ b FALSE TRUE å¾—åˆ°ï¼Œæˆ–è€…åˆ©ç”¨ TRUE / FALSE çš„æ„ä¹‰â€”â€”é€‰ç¬¬ä¸€ä¸ª / ç¬¬äºŒä¸ªâ€”â€”ç›´æ¥å¾—åˆ°.\nAND p:q: p q p å¦‚æœ p = TRUEï¼Œé‚£ä¹ˆ AND p q â‰¡ qï¼›å¦‚æœ p = FALSEï¼Œé‚£ä¹ˆ AND p q â‰¡ FALSE â‰¡ p.\nOR p:q: p p q å¦‚æœ p = TRUEï¼Œé‚£ä¹ˆ OR p q â‰¡ p â‰¡ TRUEï¼›å¦‚æœ p = FALSEï¼Œé‚£ä¹ˆ OR p q â‰¡ q.\nXOR p:q: p (NOT q) q ç±»ä¼¼ AND, ORï¼Œå¯ä»¥ç”»ä¸ªçœŸå€¼è¡¨æ•´ç†æ€ç»ª.\nPair and List PAIR x:y:f: f x y PAIR A B â†’ (x:y:f: f x y) A B â†’ (f: f A B) æ˜¯ä¸€ä¸ªè¿™æ ·çš„æŠ½è±¡ï¼šæœ‰åºåœ°å†…æ¶µ A, Bï¼Œç­‰å¾…ä¸€ä¸ªå‡½æ•° f ä½œç”¨äºå†…æ¶µçš„ A, Bï¼Œæ¯”å¦‚å½“ A, B æ˜¯ Booleanï¼Œé‚£ä¹ˆï¼Œf å¯ä»¥æ˜¯ AND / OR / \u0026hellip;ï¼ˆå½“ç„¶è¯­æ³•å¹¶ä¸çº¦æŸ f,A,B çš„å½¢çŠ¶ï¼Œå¦‚æœä½ æƒ³å†™ PAIR TRUE 0 PAIR è§£é‡Šå™¨ä¸ä¼šæ‹¦ä½ ï¼‰\nFST p: p TRUE å½“ p = PAIR A B æ—¶, p TRUE â†’ (PAIR A B) TRUE â†’ (f: f A B) TRUE â†’ TRUE A B â†’ Aï¼Œæ³¨æ„ p æ˜¯ä¸€ä¸ªå¯ä»¥æ¥æ”¶ä¸€ä¸ªå‚æ•° f çš„å‡½æ•°ï¼Œè¿™é‡Œæˆ‘ä»¬è®©å®ƒæ¥æ”¶ TRUE å‡½æ•°æ¥é€‰å–ç¬¬ä¸€ä¸ªå…ƒç´ . åœ¨ LC é‡Œï¼ŒTRUE / FALSE æ›´æ°å½“çš„è§£é‡Šæ˜¯é€‰å–å…¶åè·Ÿéšçš„ç¬¬ä¸€ / äºŒä¸ªé¡¹ï¼Œè€Œä¸æ˜¯è¡¨è¾¾æŸä¸ªå‘½é¢˜çš„çœŸ / å‡ï¼Œè¿™æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºæˆ‘ä»¬å†™å…¶ä»–é«˜çº§è¯­è¨€ç¨‹åºçš„æ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ª Boolean å€¼ X ï¼ŒX æœ€ç»ˆçš„æ•ˆç”¨å¾€å¾€è¿˜æ˜¯å‘æŒ¥åœ¨ then-clause / else-clause çš„é€‰æ‹©ä¸Š.\nSND p: p FALSE ç±»ä¼¼ FST.\nsimple list å–å‡ºåˆ—è¡¨çš„ç¬¬ 3 é¡¹ (1-indexed)ï¼š\nl: FST ( SND ( SND l ) ) åˆ—è¡¨æ˜¯ä¸€ç§ç®€å•çš„é€’å½’ç»“æ„ï¼Œé€’å½’åŸºæ˜¯ç©ºåˆ—è¡¨ï¼Œè¿™é‡Œç”¨ FALSE è¡¨ç¤ºï¼Œé€’å½’æ­¥æ˜¯å‘æŸä¸ªåˆ—è¡¨æ·»åŠ å…ƒç´ ï¼Œè¿™é‡Œç”¨ PAIR å®ç°ï¼Œe.g. [] â†¦ FALSE, 1 â†¦ (PAIR 1 FALSE), [1,3] â†¦ (PAIR 1 (PAIR 3 FALSE))ï¼Œæ³¨æ„ [1,3]çš„ä¾‹å­ï¼Œå¦‚æœä»å‘åˆ—è¡¨æ·»åŠ å…ƒç´ çš„è§†è§’çœ‹ï¼Œè¡¨å¤´æ˜¯æœ€æ¥è¿‘ FALSE çš„é¡¹ï¼Œè¶Šæ¥è¿‘ FALSE çš„å…ƒç´ ç´¢å¼•è¶Šå°ï¼Œå› ä¸ºå®ƒæ¯”è¾ƒæ—©åœ°è¢«æ·»åŠ è¿›æ¥ï¼Œåœ¨è¿™ç§è§£é‡Šä¸‹ï¼Œ[1,3] â†¦ (PAIR 3 (PAIR 1 FALSE))ï¼Œç„¶è€Œæ¸¸æˆé‡Œä¸é‡‡å–è¿™ä¸ªè§£é‡Šï¼Œè€Œæ˜¯å’Œæˆ‘ä»¬ç†Ÿæ‚‰çš„ [a,b,..] ä¿æŒè§†è§‰ä¸Šçš„å¯¹é½ï¼Œå°†æœ€æ™šè¢«æ·»åŠ çš„é¡¹â€”â€”æœ€å·¦çš„é¡¹â€”â€”ä½œä¸ºè¡¨å¤´ï¼Œåœ¨åç»­æ¶‰åŠå‡é™åºçš„é—®é¢˜çš„æ—¶å€™è®°å¾—ç•™æ„è¿™ä¸€ç‚¹.\nANY å¯¹ä¸€ä¸ªå« 3 ä¸ª Boolean çš„åˆ—è¡¨ï¼Œè‹¥ä»»ä¸€é¡¹ä¸º TRUEï¼Œè¿”å› TRUEï¼Œå¦åˆ™è¿”å› FALSEï¼š\n(l: IF (OR (FST (SND (SND l))) (OR (FST l) (FST (SND l)) ) ) TRUE FALSE ) ç›´ç™½åœ°æŒ‰é€»è¾‘å†™å³å¯. è¿™é‡Œçš„åˆ—è¡¨æ˜¯å®šé•¿çš„ï¼Œæ¯”è¾ƒæ–¹ä¾¿ï¼Œéå®šé•¿åˆ—è¡¨å°±éœ€è¦é€’å½’ï¼Œè§å.\nPUSH (m:l: PAIR m l) ç”¨ PUSH å‘åˆ—è¡¨ l æ·»åŠ æ–°é¡¹ mï¼Œæ ¹æ® $\\eta$-reductionï¼ŒPUSH â‰¡ PAIRï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥å†™ PAIR ä¹Ÿè¶³å¤Ÿäº†.\nPOP SND å¼¹å‡ºæœ€å¤–å±‚çš„é¡¹.\nEMPTY l: l (t:x:y: FALSE) TRUE é¦–å…ˆ EMPTY è¦æ¥æ”¶ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥å®ƒçš„åŸºæœ¬å½¢çŠ¶æ˜¯ EMPTY = l: ...ï¼Œè€ƒè™‘ l' = FALSE çš„æƒ…å½¢ï¼ŒEMPTY l' ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ TRUEï¼Œæ ¹æ® FALSE çš„é€‰æ‹©èƒ½åŠ›ï¼Œæˆ‘ä»¬ä½¿ EMPTY = l: l ğ• TRUEï¼›è€ƒè™‘ l* = PAIR a (PAIR b (...)) = (f: f a (PAIR b (...))) â‰ˆ (f: f a _tail)ï¼ŒæŠŠ l* è§†ä½œæ¥æ”¶ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼ŒEMPTY l* = (f: f a _tail) ğ• TRUE â†’ ğ• a _tail TRUE ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ FALSE, é‚£ä¹ˆ ğ• çš„å·¥ä½œå°±æ˜¯æ¥æ”¶åé¢çš„ 3 é¡¹ï¼Œç„¶åè¿”å› FALSEï¼Œæ‰€ä»¥ ğ• = (t:x:y: FALSE)ï¼Œç»¼åˆä»¥ä¸Šå¾—åˆ°æœ€ç»ˆçš„è§£ EMPTY = l: l (t:x:y: FALSE) TRUE\nRecursion create recursion - Y combinator åŠ¨æœºï¼šLC ä¸­çš„é€’å½’ å°è¯•ç€åœ¨ LC ä¸­å®šä¹‰é€’å½’çš„é˜¶ä¹˜å‡½æ•°ï¼š\nf = a: IF (EQ a 1) 1 (a * f (a - 1)) ä¸Šè¿°çš„å®šä¹‰æ˜¯ä¸ç¬¦åˆ LC çš„è¯­æ³•çš„ï¼Œå› ä¸º LC çš„å‡½æ•°éƒ½æ˜¯åŒ¿åå‡½æ•°ï¼Œä¸æ”¯æŒé€šè¿‡åç§°æ¥è°ƒç”¨å‡½æ•°ï¼ˆå¦‚ä¸Šé¢çš„ fï¼‰ï¼Œè€Œé€’å½’å‡½æ•°ä¸å¯é¿å…çš„éœ€è¦è‡ªæŒ‡ï¼Œå¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ\nå°†å‡½æ•° $F$ åº”ç”¨äºå‚æ•° $A$ï¼Œå¯ä»¥è¿™æ ·è¡¨è¾¾ $F A$ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨é«˜é˜¶å‡½æ•°è¿™æ ·è¡¨è¾¾ï¼š$(\\lambda fa.\\ f\\ a) F A$ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ·»åŠ ä¸€äº›é€»è¾‘ï¼Œæ¯”å¦‚è¡¨è¾¾\u0026quot;å‚æ•°ä¸º $a$ å’Œ $p$ï¼Œå‡½æ•°ä¸º $f$ï¼Œè‹¥ $p\\ a$ ä¸ºçœŸï¼Œé‚£ä¹ˆè¿”å› $f\\ a$ï¼Œå¦åˆ™ç›´æ¥è¿”å› $a$ æœ¬èº«\u0026quot;ï¼š$(\\lambda fap.\\ IF\\ (p\\ a)\\ (f\\ a)\\ a)$. æ ¹æ®è¿™ä¸ªæƒ³æ³•ï¼Œå‡è®¾æˆ‘ä»¬çš„ç›®æ ‡é˜¶ä¹˜å‡½æ•°ä¸º Fï¼Œé‚£ä¹ˆ F æ»¡è¶³è¿™ä¸ªç­‰å¼ï¼Œå°† (f:a: ..) è®°ä½œ F'ï¼š\nF = (f:a: IF (EQ a 1) 1 (a * f (a - 1)) ) F â‰¡ F\u0026#39; F çœ‹ç­‰å¼çš„å³ä¾§ï¼ŒF' çš„æ¶µä¹‰æ˜¯ï¼Œæ¥æ”¶å‡½æ•° f å’Œå‚æ•° aï¼Œè‹¥ EQ a 1 é‚£ä¹ˆè¿”å› 1ï¼Œå¦åˆ™è¿”å›è¿”å› a * f (a - 1). å‘ F' ä¼ é€’é€’å½’å‡½æ•° Fï¼Œç”±æ­¤å¾—åˆ°çš„å‡½æ•° F' F çš„è¡Œä¸ºå’Œæˆ‘ä»¬ç›®æ ‡çš„é˜¶ä¹˜å‡½æ•° F æ˜¯ä¸€è‡´çš„ï¼Œä»è¯­ä¹‰ä¸Šæ¥è®²ï¼Œå·¦å³ä¾§ç›¸ç­‰.\nç›®å‰æˆ‘ä»¬æœ‰çš„ç­‰å¼æ˜¯ F = F' F â‘ ï¼Œå…¶ä¸­ F' æ˜¯å·²çŸ¥çš„ closed termï¼Œå› ä¸º F æ¶‰åŠè‡ªå¼•ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ normal formï¼Œäºæ˜¯è€ƒè™‘æ˜¯å¦å­˜åœ¨æŸä¸ª Y s.t. Y F' = Fâ‘¡ï¼Œå°† â‘¡ ä»£å…¥ â‘ ï¼ŒY F' = F' (Y F')ï¼Œæ¥ä¸‹æ¥çš„ç›®æ ‡å°±æ˜¯è§£å‡º Y çš„ normal formï¼Œå¾—åˆ° Y ä¹‹åï¼Œç›®æ ‡é€’å½’å‡½æ•° F = Y F' ä¹Ÿéšä¹‹å¾—åˆ°äº†.\nä¸ºä»€ä¹ˆè¦è¯•å›¾å°† F åˆ†è§£æˆ Y F'ï¼Ÿ\nä¸ä¸¥è°¨åœ°è¯´ï¼Œä»æ–¹ç¨‹çš„è§’åº¦çœ‹ F = F' F åªæœ‰ä¸€ä¸ªæœªçŸ¥é‡ Fï¼Œå°† F è½¬åŒ–æˆ Y F'ï¼ŒåŒæ ·åªå«ä¸€ä¸ªæœªçŸ¥é‡ Yï¼Œè€Œ F'å·²çŸ¥ä¸”å’Œæˆ‘ä»¬çš„æ±‚è§£ç›®æ ‡ï¼ˆé€’å½’å‡½æ•° Fï¼‰ç´§å¯†ç›¸å…³.\nY combinator è®¾è®¡ Y æ˜¯ä¸€ä¸ªè¿™æ ·çš„ termï¼šY F = F (Y F) = F (F (Y F)) = ....\nä¸ºè®¾è®¡æ»¡è¶³ä»¥ä¸Šç›®æ ‡çš„ Y ï¼Œåšå‡ºå¦‚ä¸‹çš„åˆæ­¥åˆ†æï¼š\næ ¹æ® inversion lemmaï¼ŒY çš„å½¢çŠ¶æ¯«æ— ç–‘é—®æ˜¯ (f: ...).\nY çš„è‡ªæŒ‡ï¼Ÿâ€”â€” æˆ‘ä»¬éœ€è¦é‡å¤ Yï¼Œæˆ–è€…è¯´æ„å»ºå³ä¾§çš„ Y.\nFunction / Abstraction is All You Need â€”â€” å› ä¸º LC æ²¡æœ‰å­˜å‚¨ï¼Œæ‰€ä»¥ Y F = F (Y F)ï¼Œç­‰å·å·¦å³çš„ Y å¹¶ä¸æ˜¯åŒä¸€ä¸ª Yï¼Œä¸æ˜¯å€¼æ‹·è´æˆ–è€…åœ°å€æ‹·è´ï¼ˆå› ä¸º LC ä¸æä¾›å­˜å‚¨çš„æ¦‚å¿µï¼Œæ— å¤„å®‰æ”¾å€¼æˆ–è€…åœ°å€ï¼Œè¿™é‡Œåªæœ‰å‡½æ•°ï¼‰ï¼Œå³ä¾§çš„ Y éœ€è¦é€šè¿‡æ„å»ºå¾—åˆ°ï¼Œä¸å·¦ä¾§çš„ Y åœ¨ alpha-conversion çš„æ„ä¹‰ä¸‹ç›¸ç­‰.\nå¦‚ä½•é‡å¤ Fï¼Ÿè¿™å¾ˆç®€å•ï¼ŒY = (f: ...) æ¥æ”¶å‚æ•° Fï¼Œåœ¨ Y çš„å‡½æ•°ä½“å†…ï¼Œæƒ³æ€ä¹ˆé‡å¤å°±æ€ä¹ˆé‡å¤.\nè®¾è®¡ä¸€ä¸ª abstraction M åšæ„å»ºï¼ŒM å°†æ¥æ”¶ä¸€äº›å¿…è¦çš„å‚æ•°ï¼Œåœ¨å‡½æ•°ä½“å†…ç»„ç»‡è¿™äº›å‚æ•°ï¼Œå½¢æˆå’Œ Y ä¸€æ ·çš„ç»“æ„.\nY = f: M f ... ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ M = f: f (Wai f)ï¼šæ¯«æ— ç–‘é—®ï¼ŒM éœ€è¦æ‹¿åˆ° Y çš„å‚æ•° fï¼ŒM å†…éƒ¨éœ€è¦å»ºç«‹èµ·å’Œ Y F ä¸€è‡´çš„ç»“æ„ï¼› Y = f: M f M ... ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ M = f:m: f (m f m)ï¼šå› ä¸ºæˆ‘ä»¬å¸Œæœ› M å¯ä»¥å»ºç«‹èµ·å’Œ Y F ä¸€è‡´çš„ç»“æ„ï¼Œè€Œ Y åŒ…å«äº† Mï¼Œé‚£ä¹ˆ M ä¹Ÿéœ€è¦åŒ…å« Mï¼Œæ‰€ä»¥é€šè¿‡å‚æ•° m å°† M åŸå°ä¸åŠ¨åœ°ä¼ è¿› M. M çš„å‡½æ•°ä½“ä¸­ï¼Œæœ€å·¦çš„ f å®ç° f çš„å†æ¬¡åº”ç”¨ï¼Œ(m f m) æ„å»ºäº†å’Œå·¦ä¾§çš„ Y F alpha ç­‰ä»·çš„ç»“æ„. Y = f: M f M, å…¶ä¸­ M = f:m: f (m f m)ï¼Œå¯ä»¥éªŒè¯è¿™å·²ç»æ˜¯ä¸€ä¸ªå¯è¡Œçš„ Y ç»„åˆå­äº†ï¼ŒY F = M F M = (f:m: f (m f m)) F M = F (M F M) = F (M F M) = F (Y F). Y ç»„åˆå­å¯ä»¥æœ‰æ— æ•°ç§ï¼Œæ¯”å¦‚ (a) Y = f: M M f, M = m:f: f (m m f) è¿™å’Œä¸Šæ–‡æ‰€å‘ˆç°çš„ Y ç»„åˆå­æ˜¯å‡ ä¹ä¸€æ ·çš„ï¼Œåªæ˜¯æ”¹å˜äº† M, f å‚æ•°çš„é¡ºåºï¼Œåˆ©ç”¨ä¸€æ­¥ $\\eta$ è§„çº¦ï¼Œä½¿ä¹‹æ›´ç®€æ´â€”â€”Y = M M, M = ...ï¼Œè¿™ä¹Ÿæ˜¯å›¾çµç»™å‡ºçš„ Y ç»„åˆå­ï¼›(b) Y = f: E (E f) E f, E = r:s:f: f (s r s f) ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œçœ‹èµ·æ¥ä¸å¤Ÿç®€æ´ï¼Œä½†æ˜¯ç†å¿µå’Œä¸Šé¢çš„é™ˆè¿°æ˜¯ä¸€è‡´çš„ï¼Œç”¨ E æ¥æ”¶éœ€è¦çŸ¥é“çš„å‚æ•°ï¼Œç„¶ååšæ„å»ºï¼Œä½ ä¼šå‘ç° E æ¥æ”¶äº† E å’Œ fï¼Œåˆå¤šä½™åœ°æ¥æ”¶äº† (E f)ï¼ŒæŠŠ (E f) æ‹¿æ‰å¹¶åšç›¸åº”çš„ä¿®æ”¹ï¼Œå°±å¾—åˆ°äº†æœ¬æ®µè½é™ˆè¿°çš„ç¬¬ä¸€ç§ Y ç»„åˆå­ï¼›(c) æœ€ç®€æ´çš„ Y = f: (x: f (x x)) (x: f (x x))ï¼Œå®ƒå’Œå‰é¢æåˆ°çš„ Y ç»„åˆå­çš„åŒºåˆ«åœ¨äºï¼Œå‰é¢çš„ Y ç»„åˆå­æ˜¯ç”¨ç»„åˆå­ç»„æˆçš„ï¼Œæ¯”å¦‚ 4 ä¸­çš„ Y = f: M f M ä¸­çš„ M æœ¬èº«ä¹Ÿæ˜¯ç»„åˆå­ï¼Œè€Œè¿™ä¸ª Y ç»„åˆå­ä¸åŒ…å«ç»„åˆå­å­é¡¹.\nå°ç»ƒä¹ ï¼šå¦‚ä½•å®ç°æ»¡è¶³åŒè¾¹å»¶å±•çš„ D F D = D (D F D) D = ... çš„ç»„åˆå­ Dï¼Ÿ\nä¸€ç§è§£æ³•å¯ä»¥æ˜¯ D = f:d: d (d f d) dï¼Œé“ç†å’Œä¹‹å‰æ‰€è¯´çš„æ˜¯ä¸€è‡´çš„.\nY ä¸€å®šè¦æ˜¯ç»„åˆå­å—ï¼Œå¯ä»¥å¼•å…¥è‡ªç”±å˜é‡å—ï¼Ÿ\nå‡è®¾ Y åŒ…å«è‡ªç”±å˜é‡ zï¼Œå› ä¸º Y åŒ…å« zï¼Œé‚£ä¹ˆç”¨ M æ„å»º Y æ—¶ä¹Ÿè¦è€ƒè™‘åˆ° zï¼š\nclosed Mï¼šå°† z ä½œä¸ºå‚æ•°ä¼ ç»™ Mï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ä¹‹å‰çš„ Y ç»„åˆå­çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼Œå¾—åˆ° Y = f: M f c M, M = f:c:m: f (m f c m)ï¼Œå¯ä»¥éªŒè¯ï¼Œè¿™å¯ä»¥è¾¾æˆ Y F = F (Y F) = ... çš„ç›®æ ‡ï¼ŒåŒæ—¶ä½ å¯ä»¥æ³¨æ„åˆ°å¼•å…¥ z å¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œåªæ˜¯å¹³æ·»è´Ÿæ‹…; open Mï¼šå³ M æœ¬èº«åŒ…å«äº†è‡ªç”± zï¼Œå¯ä»¥å°è¯• Y = f: K f K z, K = f:k: f (k f k z)è¿™ä¸ªä¾‹å­ï¼Œä½ ä¼šå‘ç°è¿™æ˜¯è¡Œä¸é€šçš„ï¼š Y F = F (K F K z) z = F (Y F) z = F (F (Y F) z) zï¼Œè¿™ä¸ª Y çš„æ•ˆæœæ˜¯åœ¨å·¦ä¾§ä¸æ–­åš F çš„åº”ç”¨ï¼Œå³ä¾§ä¸æ–­äº§ç”Ÿæ–°çš„ z. æ ¹æ®ä»¥ä¸Šçš„è®¨è®ºï¼Œè¿™ä¸ªé—®é¢˜çš„ç­”æ¡ˆæ˜¯ï¼šå¯ä»¥ï¼Œä½†æ²¡å¿…è¦. ä¸”ä»ç›´è§‰ä¸Šå»ç†è§£ï¼Œéšæ„åœ°å¼•å…¥è‡ªç”±å˜é‡ä¹Ÿæ²¡æœ‰æ„ä¹‰. æˆ‘æå‡ºè¿™ä¸ªé—®é¢˜çš„åŸå› æ˜¯ï¼Œæœ‰ä¸€ç¬é—´çªç„¶è§‰å¾— Y ç»„åˆå­å¤ªç†Ÿæ‚‰äº†ï¼Œç¬¬ä¸€æ¬¡åœ¨ LC é‡Œè§åˆ° Y è¿™ä¸ªå¤§å†™å­—æ¯åé¢æ¥çš„å°±æ˜¯\u0026quot;ç»„åˆå­\u0026quot;ä¸‰ä¸ªå­—ï¼Œæ‰€ä»¥å¼€å§‹è€ƒè™‘ï¼Œå¦‚æœä¸æ˜¯ç»„åˆå­æ˜¯å¦å¯ä»¥.\nY combinator ä½¿ç”¨ æ‰¿æ¥åŠ¨æœºéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç”¨ F' = f:a: ... è¡¨è¾¾é€’å½’å‡½æ•° f ä¸å…¶å‚æ•° a ä¹‹é—´çš„åº”ç”¨é€»è¾‘ï¼Œå°†ç›®æ ‡é€’å½’å‡½æ•°ä¸º Fï¼Œé‚£ä¹ˆ F = F' Fï¼Œå› ä¸ºè‡ªå¼•çš„ä¸åˆæ³•ï¼Œè€ƒè™‘ç”¨ Y F' æ¥è¡¨ç¤º Fï¼Œåœ¨ä¸Šä¸€èŠ‚ä¸­æˆ‘ä»¬æ¶‰åŠå‡ºäº†å¯è¡Œçš„ Yï¼Œäºæ˜¯ F = Y F' å°±æ˜¯æˆ‘ä»¬å¸Œæœ›å¾—åˆ°çš„ç›®æ ‡å‡½æ•°.\næƒ³æ˜ç™½ Y ç»„åˆå­çš„ä½¿ç”¨ï¼Œæœ¬ section çš„å…³å¡éƒ½å¾ˆç®€å•äº†ï¼Œå”¯ä¸€å€¼å¾—æç¤ºçš„æ˜¯ 1. ä½¿ç”¨ä»¥å¾€å…³å¡å·²å®šä¹‰è¿‡çš„å‡½æ•°æ—¶ï¼Œæ³¨æ„å‡½æ•°çš„å‚æ•°é¡ºåºï¼Œä¾‹å¦‚ FILTER å…ˆä¼ åˆ—è¡¨ï¼Œå†ä¼ è¿‡æ»¤ä¾èµ–çš„å‡½æ•°ï¼Œå› ä¸º Simple LC è¯­æ³•å±‚é¢çš„çº¦æŸå¾ˆå°‘ï¼Œæ‰€ä»¥ç¼–ç¨‹è€…è‡ªå·±è¦å¤šå½“å¿ƒä¸€äº› 2. æœ‰è‹¥å¹²ä¸ªå…³å¡å¯èƒ½æ¶‰åŠåˆ—è¡¨åè½¬ï¼Œæ‰€ä»¥ REVERSE å¯ä»¥å…ˆå†™ï¼Œç„¶åç›´æ¥æ‹¿æ¥ç”¨ 3. æ³¨æ„æ‹¬å·é…å¯¹ï¼Œå¯ä»¥ç°åœ¨å…ˆè¿›çš„ç¼–è¾‘å™¨é‡Œå…ˆå†™ï¼Œç¡®ä¿ä¸çŠ¯ä½çº§é”™è¯¯ï¼Œå†å¤åˆ¶è¿›æ¥è¯„æµ‹. ä¸‹é¢ç»™å‡ºçš„ç­”æ¡ˆä»…ä¾›å‚è€ƒï¼Œå¯ä»¥è¿‡è¯„æµ‹ï¼Œä½†æœªå¿…æœ€ç®€.\nstrip prefix å»é™¤ä¸å®šé•¿åˆ—è¡¨å‰ç¼€çš„ FALSEï¼š\nY (f:l: IF (FST l) l (f (SND l)) ) ACC Y (a:l:f:i: IF (EMPTY l) i (a (SND l) f (f i (FST l))) ) ALL l: ACC l AND TRUE REVERSE Y (i:c:l: IF (EMPTY l) c (i (PAIR (FST l) c) (SND l)) ) FALSE MAP Y (m:c:l:f: IF (EMPTY l) (REVERSE c) (m (PAIR (f (FST l)) c) (SND l) f) ) FALSE NONE (l: ALL (MAP l NOT)) FILTER Y (m:c:l:f: IF (EMPTY l) (REVERSE c) ( IF (f (FST l)) (m (PAIR (FST l) c) (SND l) f) (m c (SND l) f) ) ) FALSE ZIP Y (z:c:m:n: IF (EMPTY m) (REVERSE c) (z (PAIR (PAIR (FST m) (FST n)) c) (SND m) (SND n)) ) FALSE EQBLIST (m:n: ALL (MAP (MAP (ZIP m n) (p: XOR (FST p) (SND p)) ) NOT ) ) CONCAT (m:n: (Y (g:c:r: IF (EMPTY r) c (g (PAIR (FST r) c) (SND r)) ) ) n (REVERSE m) ) Numerals Church Numeral ç”¨å‡½æ•°è¡¨è¾¾è‡ªç„¶æ•°ï¼Œä¸¤ä¸ªå…³é”®ç‚¹æ˜¯ 1. åŸº (0 := f:x: x) 2. åç»§ (SUC)ï¼Œåœ¨åŸºä¹‹ä¸Šä¸æ–­åšåç»§ï¼Œå°±å¯ä»¥å¾—åˆ°æ‰€æœ‰ Church Numeral.\nSUC ç»™å®š Church Numeral nï¼Œn æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå‚æ•°ä¸º f, xï¼Œn f x è¡¨ç¤ºå°† f åº”ç”¨äº x $n$ æ¬¡ï¼ŒSUC n æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„èƒ½åŠ›æ˜¯æ¥æ”¶ f, xï¼Œå°† f åº”ç”¨äº x $(n+1)$ æ¬¡.\n(n: (f:x: f (n f x) ) ) ZERO åˆ©ç”¨é€»è¾‘è¿ç®—æ¥åˆ¤æ–­ç»™å®šçš„ n æ˜¯ä¸æ˜¯ f:x: x.\n(n: n (x: AND FALSE x) TRUE) PRE ä¸€ä¸ªåŸºæœ¬çš„è§‚å¯Ÿæ˜¯ n = n SUC 0ï¼Œè¿™é‡Œçš„ç­‰å·è¡¨ç¤ºå†…æ¶µç­‰ä»·ï¼ˆintensional equalityï¼‰ï¼Œé‚£ä¹ˆåœ¨ PAIR 0 0 ä¸Šåš $n$ æ¬¡è¿­ä»£ï¼Œä¸€è½®è¿­ä»£çš„å·¥ä½œæ˜¯ï¼š1. å³ä¾§æ•°å¯¹é½å·¦ä¾§æ•° 2. å·¦ä¾§æ•°åšä¸€æ¬¡åç»§ï¼Œé‚£ä¹ˆå³ä¾§æ•°å§‹ç»ˆæ…¢å·¦ä¾§æ•°ä¸€æ­¥ï¼Œå³ $n$ è½®è¿­ä»£åï¼Œå·¦ä¾§æ•°æ˜¯ nï¼Œå³ä¾§æ•°æ˜¯å·¦ä¾§æ•°çš„åç»§.\n(n: SND (n (p: PAIR (SUC (FST p)) (FST p)) (PAIR 0 0) ) ) ADD ç»™å®š x, yï¼Œç›®æ ‡æ˜¯ç»™å‡º x+yï¼Œx+y çš„å«ä¹‰æ˜¯ï¼šé¢„å¤‡æ¥æ”¶ f, zï¼Œå°† f åº”ç”¨äº z $(x+y)$ æ¬¡. å…ˆå°† f åº”ç”¨äº z $x$ æ¬¡ï¼Œå¾—åˆ°ç»“æœ x f zï¼Œå†å°† f åº”ç”¨äº (x f z) $y$ æ¬¡.\n(x:y: (f:z: y f (x f z)) ) SUB (x:y: (f:z: (y PRE x) f z)) MUL (x:y:f:z: y (x f) z ) DIV (Y (d:c:x:y: IF (ZERO x) 0 ( IF (ZERO (y PRE x)) (SUC c) (d (SUC c) (y PRE x) y) ) ) ) 0 EQ (x:y: AND (ZERO (x PRE y)) (ZERO (y PRE x)) ) MIN (x:y: IF (ZERO (x PRE y)) y x ) MAX (x:y: IF (ZERO (x PRE y)) x y ) More Numerals is odd (n: (n NOT FALSE)) é¡ºä¾¿æƒ³èµ·äº†åˆ¤æ–­å¥‡å¶çš„é€’å½’æ–¹æ³•ï¼šï¼ˆçœ‹èµ·æ¥è¿˜æŒºæœ‰æ„æ€çš„ï¼Œæ¯”ç†Ÿæ‚‰çš„ mod 2 æ–°é²œä¸€äº›ï¼‰\nisEven :: Int -\u0026gt; Bool isEven 0 = True isEven x = isOdd (x-1) isOdd :: Int -\u0026gt; Bool isOdd 0 = False isOdd x = isEven (x-1) increasing list å°¾é€’å½’ï¼š\n(Y (f:c:n: IF (ZERO n) (PAIR 0 c) (f (PAIR n c) (PRE n)) ) ) FALSE éå°¾é€’å½’ï¼š\n(n: REVERSE ( (Y (f:x: IF (ZERO x) (PAIR 0 FALSE) (PAIR x (f (PRE x)))) ) n ) ) decomposition å°†ç»™å®šæ•°åˆ†è§£æˆ 2 çš„å¹‚ä¹‹å’Œï¼š\n(Y (f:c:k:n: IF (ZERO n) c (IF (AND (EQ n (MIN k n)) (NOT (EQ k n))) (f c (DIV k 2) n) (f (PAIR k c) (DIV k 2) (SUB n k) ) ) ) ) FALSE 8 * primes å’Œ sort éƒ½éœ€è¦å¤§æŠŠæ—¶é—´è¿è¡Œï¼ˆæœ¬æœºæµ‹è¯•ä¸¤å…³å„è‡ªè€—æ—¶éƒ½åœ¨ 30min å·¦å³ï¼‰\nprimes Y (f:l:p:n: IF (EQ n (FST p)) (PAIR n l) (IF (EQ (FST p) (MAX n (FST p))) (f l (SND p) n) ( IF ( (Y (f:n:p: IF (EQ n (MIN n p) ) (IF (EQ n p) TRUE FALSE ) (f (SUB n p) p) ) ) n (FST p) ) (f (PAIR (FST p) l) p (DIV n (FST p))) (f l (SND p) n) ) ) ) FALSE (PAIR 47 (PAIR 43 (PAIR 41 (PAIR 37 (PAIR 31 (PAIR 29 (PAIR 23 (PAIR 19 (PAIR 17 (PAIR 13 (PAIR 11 (PAIR 7 (PAIR 3 (PAIR 2 FALSE)))))))))))))) sort é€‰æ‹©æ’åºï¼š\nY (f:c:l: IF (EMPTY l) c ( (m: (f (PAIR m c) (FILTER l (x: NOT (EQ x m)) )) ) (ACC l MAX 0) ) ) FALSE trees NODE l:v:r:f: f l v r LEF t: t (l:v:r: l) RIG t: t (l:v:r: r) VAL t: t (l:v:r: v) BEMPTY ç±»ä¼¼äºåˆ—è¡¨åˆ¤ç©ºï¼ŒNODE l v r = f: f l v rï¼Œç©ºæ ‘ç”¨ FALSE := a:b: bï¼Œå°†ä¸€ä¸ªæ ‘ t ä½œä¸ºå‡½æ•°ä½¿ç”¨ï¼Œè‹¥æ˜¯ç©ºæ ‘ï¼Œt A B = FALSE A B = B ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ TRUEï¼Œè‹¥ä¸æ˜¯ç©ºæ ‘ t A B = (f: f l v r) A B = A l v r B ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ FALSEï¼Œæ ¹æ®ä»¥ä¸Šï¼ŒB = TRUE, A = l:v:r:x FALSEï¼Œæ‰€ä»¥ï¼š\n(t: t (l:v:r:x: FALSE) TRUE ) FIND åˆ¤æ–­æ ‘ t ä¸­æ˜¯å¦å­˜åœ¨å€¼ä¸º v çš„ç»“ç‚¹ï¼š\nY (f:t:v: IF (BEMPTY t) FALSE (IF (EQ (VAL t) v) TRUE (OR (f (LEF t) v) (f (RIG t) v)) ) ) BSIZE è®¡ç®—æ ‘çš„è§„æ¨¡ï¼š\nY (f:t: IF (BEMPTY t) 0 (SUC (ADD (f (LEF t)) (f (RIG t)))) ) BUILD äºŒå‰æœç´¢æ ‘çš„æ„é€ ï¼š\nY (f:c:l: IF (EMPTY l) c ( f ( ( Y (f:v:t: IF (BEMPTY t) (NODE FALSE v FALSE) ( IF (EQ v (MIN v (VAL t))) (NODE (f v (LEF t)) (VAL t) (RIG t)) (NODE (LEF t) (VAL t) (f v (RIG t))) ) ) ) (FST l) c) (SND l) ) ) FALSE [ æ¸¸æˆé‡Œçš„ PREORDER å’Œ INORDER ä¸¤ä¸ªå‡½æ•°ä¼¼ä¹åäº†ï¼Ÿ ]\nPREORDER äºŒå‰æ ‘çš„ä¸­åºéå†ï¼š\nY (f:t: IF (BEMPTY t) FALSE (CONCAT (f (LEF t)) (PUSH (VAL t) (f (RIG t)) ) ) ) INORDER äºŒå‰æ ‘çš„å‰åºéå†ï¼š\nY (f:t: IF (BEMPTY t) FALSE (PUSH (VAL t) (CONCAT (f (LEF t)) (f (RIG t)) ) ) ) SPLIT æ ‘ t ä»¥ v ä¸ºç•Œè¿›è¡Œåˆ†å‰²ï¼š\nY (f:t:v: IF (BEMPTY t) (PAIR FALSE FALSE) ( IF (EQ v (MAX v (VAL t))) ( (p: PAIR (NODE (LEF t) (VAL t) (FST p)) (SND p)) (f (RIG t) v) ) ( (p: (PAIR (FST p) (NODE (SND p) (VAL t) (RIG t) ))) (f (LEF t) v) ) ) ) KTH å¯¹ç»™å®šçš„äºŒå‰æœç´¢æ ‘ï¼Œç»™å‡ºå…¶ä¸­ç¬¬ k å¤§çš„å…ƒç´ ï¼Œå–å‡ºæ ‘çš„ä¸­åºéå†åˆ—è¡¨ä¸­çš„ç¬¬ k é¡¹å³å¯ï¼š\n(t:k: Y (f:c:l: IF (EQ c 0) (FST l) (f (PRE c) (SND l) ) ) k (PREORDER t) ) inverse 6 å¯¹ç»™å®šçš„äºŒå‰æœç´¢æ ‘ tï¼Œæ‰¾å‡º [1..6] ä¸­çš„è‹¥å¹²ä¸ªç¼ºå¸­è€…ï¼Œå‡åºæ’åˆ—ï¼š\nt: IF (BEMPTY t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ( Y (f:c:m:n: IF (EMPTY n) (REVERSE c) ( IF (EQ (FST m) (FST n)) (f c (SND m) (SND n)) (f (PAIR (FST n) c) m (SND n)) ) ) FALSE (PREORDER t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ) ","date":"2025-02-02T21:29:00+08:00","permalink":"http://localhost:1313/p/programming-in-lambda-calculus-basic/","title":"Programming in Lambda Calculus, Basic"},{"content":"-Inspired by Algorithm Design and Analysis course, 2024 Fall-\nIntroduction In this semester\u0026rsquo;s algorithms course, we focused on two major categories of search algorithms: backtracking and branch-and-bound. Previously, I always treated various search algorithms like DFS and BFS separately, comparing their differences. In this article, I aim to abstract search algorithms, expecting to derive familiar search strategies from a concise abstract model.\nAbstracting the Search Model and Process Here\u0026rsquo;s the model I\u0026rsquo;ve summarized, demonstrated in Haskell:\nclass (Ord node) =\u0026gt; Search env node where initN :: env -\u0026gt; node check :: env -\u0026gt; node -\u0026gt; Bool child :: env -\u0026gt; node -\u0026gt; [node] search :: env -\u0026gt; node Search env node: A search requires two elements: the search environment env and the search node node. Since we need to determine the expansion order based on the priority of node, we want node to be orderable, hence the Ord constraint. initN :: env -\u0026gt; node: A search needs initialization. The search tree requires a root node, so we want to generate a simple root node from the search environment env. check :: env -\u0026gt; node -\u0026gt; Bool: A search needs a stopping condition. We need a function to determine if the current node is a solution based on the properties of env. child :: env -\u0026gt; node -\u0026gt; [node]: A search needs to continue. The live nodes of the search tree are expandable, so we need a function child to generate a list of child nodes [node] based on env and the current node. search :: env -\u0026gt; node: The main search function. Its goal is to search within the environment env and eventually return the terminal node node, which is the optimal solution we seek. To implement a search algorithm for a specific problem, we need to define the abstraction of the search environment env, design the node node, and implement the above functions: initN, check, child, and search.\nThe search model can be abstracted, and so can the search process. Therefore, I provide a default implementation of the search function (since initN, check, and child are often strongly tied to the specific problem and need to be provided during instantiation, they cannot rely on default implementations). This function abstracts the basic search processâ€”starting from the root node (initN), checking (check) if the highest-priority node is a solution, returning it if true, otherwise expanding (child) its child nodes, reordering the live node list based on priority, and repeating this process:\nsearch e = let step :: [node] -\u0026gt; node step (n:ns) | check e n = n | otherwise = step $ sort (ns ++ child e n) in step [initN e] Example: Instantiating the TSP Search from the Model Search Environment: The directed weighted graph Graph is abstracted as follows:\ntype Vertex = Int type Distance = Int type Edge = (Vertex, Vertex, Distance) data Graph = Graph { vertices :: [Vertex], edges :: [Edge] } Additionally, the search process relies on graph functions like minOut and distance:\nminOut :: Graph -\u0026gt; [(Vertex, Distance)] minOut (Graph vs es) = [ (v, minimum ds) | v \u0026lt;- vs, let es\u0026#39; = filter (\\(v1, _, _) -\u0026gt; v1 == v) es, let ds = [ d | (_, _, d) \u0026lt;- es\u0026#39;]] distance :: Graph -\u0026gt; (Int, Int) -\u0026gt; Maybe Distance distance (Graph _ []) _ = Nothing distance (Graph vs ((v1, v2, d):es)) (s, t) | s == v1 \u0026amp;\u0026amp; t == v2 = Just d | otherwise = distance (Graph vs es) (s, t) Node Design (TspNode):\nA node needs to store the current cost, the list of visited vertices, and the heuristic value (upper bound of the total cost):\ndata TspNode = TspNode { cost :: Int, visited :: [Vertex], -- reverse heuristic :: Int -- heuristic / priority } deriving (Show) The lower the heuristic value of a node, the higher its expansion priority.\ninstance Ord TspNode where compare :: TspNode -\u0026gt; TspNode -\u0026gt; Ordering compare n1 n2 | heuristic n1 \u0026gt; heuristic n2 = GT | heuristic n1 \u0026lt; heuristic n2 = LT | otherwise = EQ Search Function Instantiation:\nTo make Graph TspNode an instance of the Search type class, we can use the default search implementation. However, we still need to implement the initN, check, and child functions:\ninitN:\nThe root node\u0026rsquo;s cost is 0, the visited list is empty, and the heuristic value is irrelevant since the root node will always be the first to be checked and removed from the live node list, never participating in sorting. Thus, heuristic can be set to 0:\ninitN :: Graph -\u0026gt; TspNode initN _ = TspNode 0 [] 0 If the current node has visited all vertices (starting from the origin, traversing a loop, and returning to the origin), then it is considered a solution:\ncheck :: Graph -\u0026gt; TspNode -\u0026gt; Bool check g (TspNode _ vs _) | length vs == length (vertices g) = True | otherwise = False child:\nBased on the visited list, calculate unvisited adjacent nodes. If all other vertices have been visited, attempt to return to the origin:\nchild :: Graph -\u0026gt; TspNode -\u0026gt; [TspNode] child g n = let upBound :: [Vertex] -\u0026gt; Int upBound vs = sum [ d | (s,d) \u0026lt;- minOut g , s `notElem` vs ] at = if null (visited n) then 0 else head (visited n) -- then-clause only for initNode nodes = [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39; | v \u0026lt;- filter (\\v\u0026#39; -\u0026gt; v\u0026#39; `notElem` visited n \u0026amp;\u0026amp; isJust (distance g (at, v\u0026#39;))) -- or abstract this function to `checkChildValid` ((tail . vertices) g), -- `tail` for drop the origin vertex (0 here) let way = fromJust $ distance g (at, v), let cost\u0026#39; = cost n + way, let visited\u0026#39; = v: visited n, let heuristic\u0026#39; = upBound visited\u0026#39; + cost\u0026#39;] back = case distance g (at, 0) of Just wayback -\u0026gt; let cost\u0026#39; = cost n + wayback visited\u0026#39; = 0: visited n heuristic\u0026#39; = cost\u0026#39; in [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39;] Nothing -\u0026gt; [] in if length (visited n) == length (vertices g) - 1 then back else nodes Overall Program Framework:\nBrief Description of Other Instances We can also represent DFS and BFS using this model. In data structure courses, we often use recursion for DFS and queues + iteration for BFS. In this model, changing the priority criteria of nodes changes the strategy for selecting nodes to expand, thereby altering the search behavior.\nAssume we have a node like this:\ndata Node a = Node { info :: a, -- Problem-specific node information level :: Int, -- The level of the node in the search tree order :: Int -- The order in which the node was generated } DFS always expands the deepest live node in the current search tree. To perform depth-first search in any search environment using this node, the priority should be set to level:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | level n1 \u0026gt; level n2 = LT -- DEPTH first | level n1 \u0026lt; level n2 = LT | otherwise = EQ BFS always expands the earliest generated live node in the current search tree. To perform breadth-first search in any search environment using this node, the priority should be set to order:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | order n1 \u0026gt; order n2 = LT -- BREADTH first | order n1 \u0026lt; order n2 = LT | otherwise = EQ Limitations Lack of Application to More Specific Problems:\nI initially planned to implement classic textbook cases using this model, butâ€”time ran out. The deadline is approaching, so I only provided the instantiation of the TSP problem under this model.\nNumber of Solutions:\nHere, I limited the number of solutions to 1, defaulting to the first solution as the problem\u0026rsquo;s solution. This is effective in some cases, such as the TSP problem implemented here, where the heuristic calculation ensures the first solution is the optimal one. However, there may be other scenarios: (a) the first solution is only an approximation of the optimal solution, which may be found later, or (b) multiple solutions need to be retained. These cases are not handled by the current model.\n","date":"2024-11-24T12:09:00+08:00","permalink":"http://localhost:1313/p/abstractions-for-search-algorithms/","title":"Abstractions for Search Algorithms"},{"content":"å‰è¨€ è¿™ä¸ªå­¦æœŸåŒ…å«ç¼–è¯‘ç³»ç»Ÿå’Œç®—æ³•è®¾è®¡ä¸åˆ†æä¸¤é—¨ä¸“ä¸šè¯¾ï¼Œé‡åˆ°ä¸€äº›é—®é¢˜æ€»ä¼šæƒ³ç€æ”¾åœ¨ Haskell é‡Œå®ç°ä¸€ä¸‹ï¼Œå¯¹äºç¨‹åºæ„é€ å¤šå°‘æœ‰ç‚¹æ–°çš„ä½“ä¼šï¼Œä¹Ÿåº¦è¿‡äº†å¯¹äº Haskell ä¸å¹³é™çš„ç‹‚çƒ­æœŸï¼Œç°åœ¨çš„æˆ‘å·²ç»ä¸ä¼šæƒ³ç€åˆ°å¤„ä¼ æ•™äº†ï¼ˆâ˜ºï¸ï¼‰. æœ¬æ¥åªæ˜¯å‡†å¤‡éšä¾¿å†™å†™åš 0-1 èƒŒåŒ…çš„ Haskell å®ç°ä¸­çš„ä¸€äº›å°æ€è€ƒï¼Œä¸è¿‡çœŸå¼€å§‹åŠ¨ç¬”äº†å°±è¶Šå†™è¶Šæ­£å¼äº†ï¼Œä¹Ÿç®—æ˜¯æ¥è§¦ FP / Haskell ä»¥æ¥çš„ä¸€ç‚¹ç‚¹å°æ€»ç»“. Haskell å®˜ç½‘ å¯¹ Haskell çš„æè¿°æ˜¯ \u0026ldquo;An advanced, purely functional programming language\u0026rdquo;ï¼Œæœ¬æ–‡è¯•å›¾å›´ç»• \u0026ldquo;purely\u0026rdquo; åšä¸€äº›è®¨è®ºï¼šä»€ä¹ˆæ˜¯çº¯ï¼Œæ€ä¹ˆæ ·ç®—ä¸çº¯ï¼Œè¿½æ±‚çº¯åº¦çš„ç†ç”±æ˜¯ä»€ä¹ˆï¼Œçº¯åº¦å¸¦æ¥çš„æ•ˆç›Šæ˜¯ä»€ä¹ˆ.\né¦–å…ˆä» 0-1 èƒŒåŒ…çš„è¿‡ç¨‹å¼å®ç°å‡ºå‘ï¼Œæˆ‘æŠŠè¿‡ç¨‹å¼å®ç° 1:1 æŠ•å°„åˆ° Haskell é‡Œï¼Œæ„Ÿè§‰è¿™æ®µä»£ç ä¸æ˜¯å¾ˆç¬¦åˆ Haskell çš„æ°”è´¨ï¼ˆğŸ˜¯ï¼‰ï¼Œäºæ˜¯å›åˆ°äº†é€’æ¨å¼ï¼Œå›åˆ°äº†ç®—æ³•è¯¾ä¸Šä¸€ç¬”å¸¦è¿‡çš„é€’å½’å®ç°ï¼Œå¯¹è¿‡ç¨‹å¼è¯­è¨€çš„é€’æ¨å®ç°å’Œå‡½æ•°å¼è¯­è¨€çš„é€’å½’å®ç°åšäº†ä¸€äº›æ¯”è¾ƒï¼Œçœ‹çœ‹ä¸¤è€…å¯¹äºâ€œå¦‚ä½•é¿å…é‡å¤è®¡ç®—çš„å¼€é”€â€è¿™ä¸ªé—®é¢˜ï¼ˆä¸å±€é™äº 0-1 èƒŒåŒ…é—®é¢˜ï¼‰ç»™å‡ºçš„ä¸åŒç­”æ¡ˆï¼Œå‰è€…åˆ©ç”¨æºä»£ç ä¸Šçš„è®°å¿†æ•°ç»„ï¼Œåè€…åˆ™å¯ä»¥åˆ©ç”¨çº¯å‡½æ•°çš„ç‰¹æ€§ï¼Œé€šè¿‡æ±‚å€¼ç­–ç•¥å®ç°å‡å°‘é‡å¤è®¡ç®—.\nä¸€æ®µç®—æ³•è®¾è®¡ä¸è®¡ç®—æ¨¡å‹çš„è®¨è®ºï¼šä» 0-1 èƒŒåŒ…é—®é¢˜è¿™ä¸ªä¾‹å­é‡Œä¹Ÿå¯ä»¥çœ‹å‡º\u0026quot;ç®—æ³•è®¾è®¡\u0026quot;å…¶å®æ˜¯ä¸å®Œå…¨ç‹¬ç«‹äºç¼–ç¨‹èŒƒå¼çš„ï¼Œä¹Ÿè®¸æ›´åˆé€‚çš„è¯´æ³•æ˜¯ï¼Œç®—æ³•è®¾è®¡å¼ºç›¸å…³äºç‰©ç†è®¡ç®—æœºçš„å®é™…è¿è¡Œæ–¹å¼ï¼Œæ¯•ç«Ÿç®—æ³•è®¾è®¡é™¤äº†è§£å†³é—®é¢˜ï¼Œè¿˜æœ‰ä¸€ä¸ªè¿½æ±‚æ˜¯é™ä½åœ¨ç‰©ç†æœºä¸Šè¿è¡Œæ—¶çš„æ—¶ç©ºè®¡ç®—èµ„æºæ¶ˆè€—ï¼Œè¿™å’Œå‘½ä»¤å¼è¯­è¨€çš„ç‰¹æ€§æ˜¯ç›¸å¥‘åˆçš„ï¼Œè€Œå‡½æ•°å¼è¯­è¨€æœ‰ç‚¹ Lambda Calculus è™šæ‹Ÿæœºçš„æ„æ€ï¼›æ¯”å¦‚å¤æ‚åº¦çš„è®¡ç®—ï¼Œç›´æ¥æŠŠå‘½ä»¤å¼ç¨‹åºçš„æ—¶é—´å¤æ‚åº¦è®¡ç®—æ–¹å¼ç…§æ¬ç»™å‡½æ•°å¼ç¨‹åºæ˜¯æœ‰é—®é¢˜çš„ï¼Œå‰è€…çš„ç†è®ºåŸºç¡€æ˜¯å›¾çµæœº - çŠ¶æ€è½¬ç§»æ¬¡æ•°ï¼Œåè€…çš„ç†è®ºåŸºç¡€æ˜¯ $Î»$ æ¼”ç®— - è§„çº¦æ¬¡æ•°ï¼Œè®¡ç®—æ¨¡å‹çš„ä¸åŒåŠ¿å¿…å¸¦æ¥ä¸€äº›å·®å¼‚. å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„è®¡ç®—æœºé‡‡å–å†¯è¯ºä¾æ›¼ä½“ç³»ç»“æ„ï¼Œå³ å›¾çµæœºçš„ç‰©ç†å®ç°ï¼Œæ‰€ä»¥ç®—æ³•è¯¾ä¹Ÿé‡‡ç”¨æ›´æ¥è¿‘ç¡¬ä»¶çš„å‘½ä»¤å¼çš„ç¼–ç¨‹èŒƒå¼ï¼Œè¿˜æ˜¯å¾ˆåˆç†çš„. ä¸ç”±å¾—æƒ³èµ·å¤§ä¸€ä¸Š CPP ç¨‹åºè®¾è®¡æ—¶è€å¸ˆè¯´ â€œåªè¦å†¯è¯ºä¾æ›¼ä½“ç³»ç»“æ„è¿˜å­˜åœ¨ï¼Œæˆ‘ä»¬å°±\u0026hellip;(ååŠå¥å¿˜äº†)â€ï¼Œä¸çŸ¥ä¸è§‰æˆ‘å·²ç»å°è¯•èµ°äº†èµ°å¦ä¸€æ¡è·¯. è¯´èµ·å‡½æ•°å¼è¯­è¨€çš„æœºå™¨è¿™ä»¶äº‹æƒ…ï¼Œå…¶å® 1970s,1980s æœ‰å­¦è€…ä¸ºå‡½æ•°å¼çš„è¯­è¨€è®¾è®¡è¿‡ä¸“é—¨çš„éå†¯è¯ºä¾æ›¼æœºå™¨ï¼ˆcombinator machine, dataflow machine, etc.ï¼‰ï¼Œåæ¥å¤§å®¶å‘ç°åœ¨æ•ˆç‡çš„æ–¹é¢ï¼Œç°æœ‰æœºå™¨ + å¥½çš„ç¼–è¯‘å™¨ \u0026gt; ä¸“ç”¨æœºå™¨ï¼Œå¯å‚è€ƒ A History of Haskell: Being Lazy With Class, Part I - 2.1\nå‘½ä»¤å¼ç¨‹åºå¦‚ä½•é¿å…é‡å¤è®¡ç®— å…³äºè¿‡ç¨‹å¼çš„ 0-1 èƒŒåŒ…ï¼Œä½ ç†Ÿæ‚‰åˆ°å‡ ä¹å¯ä»¥é»˜å†™çš„ä¸€æ®µç¨‹åºï¼š\nå›å¿†ï¼šä½¿ç”¨ dp æ•°ç»„ï¼Œè€Œä¸æ˜¯é€’å½’çš„åŸå› æ˜¯ â€”â€” å°†é€’å½’è½¬ä¸ºè¿­ä»£ï¼Œé¿å…é‡å¤è®¡ç®—ï¼›å¦ä¸€ç§é™ˆè¿°æ˜¯å°†å‡½æ•°è°ƒç”¨ dp(i, j) çš„ç»“æœå­˜å‚¨åˆ°å†…å­˜ä¸­çš„æ•°ç»„ dp[i][j] é‡Œï¼Œå®ç°è®°å¿†åŒ–. int knapsack(int n, int* weight, int* value, int capacity) { int dp[n+1][capacity+1]; // INIT: BASE CASE// for (int j = 0; j \u0026lt;= capacity; j++) dp[0][j] = 0; for (int i = 0;i \u0026lt;= n;i++) dp[i][0] = 0; // DP // for (int i = 1; i \u0026lt;= n;i++) { int w = weight[i], v = value[i]; for (int j = 1; j \u0026lt;= capacity; j++) { if (j \u0026lt; w) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v); } } return dp[n][capacity]; } å°†ä¸Šè¿°ä»£ç  1:1 ç¿»è¯‘æˆ Haskell ç¨‹åºï¼Œä½ å°†å¾—åˆ°ï¼š\nimport Data.Array type Value = Int type Weight = Int type Item = (Value, Weight) knapsack01 :: Weight -\u0026gt; [Item] -\u0026gt; Value knapsack01 capacity items = dp ! (n, capacity) where n = length items dp = array((0,0), (n,capacity)) [((i, w), step i w) | i \u0026lt;- [0..n], w \u0026lt;- [0..capacity]] step 0 _ = 0 step _ 0 = 0 step i w | curWgt \u0026gt; w = dp ! (i - 1, w) | otherwise = max (dp ! (i - 1, w)) (curVal + dp ! (i - 1, w - curWgt)) where curVal = fst $ items !! (i - 1) curWgt = snd $ items !! (i - 1) å†™çš„æ—¶å€™æ„Ÿè§‰ä¸å¤ªå¯¹åŠ²ï¼Œç¬¬ä¸€æ„Ÿè§‰æ˜¯ï¼šè¿™ä¸¤æ®µä»£ç æ²¡æœ‰åŒºåˆ«. è¿™å°±æ˜¯åœ¨å‡½æ•°å¼çš„è¯­è¨€é‡Œå†™å‘½ä»¤å¼ç¨‹åº. å‘¨äº”æ™šä¸Šæˆ‘ä»ç‚¸é¸¡åº—èµ°å‡ºæ¥çš„æ—¶å€™ï¼Œæœ‰äº†ä¸€äº›æ–°çš„æƒ³æ³•ï¼š\nå‡½æ•°å¼ç¨‹åºå¦‚ä½•é¿å…é‡å¤è®¡ç®— å½“æˆ‘ä»¬ä¸èƒ½åƒè¿‡ç¨‹å¼è¯­è¨€é‚£æ ·åœ¨å†…å­˜æ¡é‡Œéšæœºå­˜å–çš„æ—¶å€™ï¼Œå½“æˆ‘ä»¬å»ºç«‹èµ·ä¸€å±‚å±‚æŠ½è±¡çš„æ—¶å€™ï¼Œå¦‚ä½•è¿½æ±‚æ€§èƒ½å‘¢ï¼Ÿé™¤äº†åœ¨ CSAPP ç¬¬äº”ç« é‡Œå­¦ä¹ åˆ©ç”¨å±€éƒ¨æ€§ã€å¾ªç¯å±•å¼€ã€æé«˜å¹¶è¡Œæ€§ç­‰æ–¹æ³•ï¼Œè¿˜æœ‰ä»€ä¹ˆæ–¹å¼å¯ä»¥æé«˜ç¨‹åºçš„æ€§èƒ½ï¼Ÿé™¤äº†ç¨‹åºå‘˜æœ¬èº«ä»æºä»£ç å±‚é¢æé«˜æ€§èƒ½ï¼Œè¿˜å¯ä»¥åœ¨å“ªé‡Œä¼˜åŒ–æ€§èƒ½ï¼Ÿç¼–è¯‘å™¨ä»ç¨‹åºå‘˜æ‰‹ä¸Šæ¥ç®¡ä»£ç ï¼Œç¼–è¯‘å™¨å¯ä»¥åšä»€ä¹ˆï¼Ÿ\n0-1 èƒŒåŒ…ï¼šå›åˆ°èµ·ç‚¹ æ‰€æœ‰ç‰©å“ä¸º $items$ï¼Œè§„æ¨¡ä¸º $N$, ç‰©å“å±æ€§ä¸ºä»·å€¼ $v_i, w_i$ï¼ŒèƒŒåŒ…æ€»å®¹é‡ä¸º $W$ï¼Œå®šä¹‰ $z(i, j)$ ä¸ºå¯é€‰ç‰©å“ä¸º $items[1..i]$ï¼ŒèƒŒåŒ…å®¹é‡ä¸º $j$ æ—¶ï¼Œå¯è·å¾—çš„æœ€å¤§ä»·å€¼ï¼Œé‚£ä¹ˆ\né€’æ¨åŸºï¼š$\\forall i, j,\\quad z(i, 0) = 0, z(0,j) = 0;$\né€’æ¨æ­¥ï¼š$z(i,j) = max(z(i-1, j), v_i + z(i-1, j-w_i));$\nç›®æ ‡å€¼ï¼š$z(N, W)$ æ¯«æ— ç–‘é—®è¿™æ˜¯é€’å½’çš„ç»“æ„ï¼Œåœ¨ Haskell é‡Œå†™é€’å½’å®ç°ï¼Œå¦‚åŒå‘¼å¸èˆ¬è‡ªç„¶ï¼š\nï¼ˆNOTEï¼š1. çœ‹åˆ°è¿™é‡Œä¹Ÿè®¸ä½ å·²ç»å¼€å§‹æ‹…å¿§é‡å¤è®¡ç®—ã€å†…å­˜å ç”¨çš„äº‹æƒ…äº† ï¼›2. å€¼å¾—ç¨ç¨æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œè¿™ä¸€æ®µä»£ç å®Œå…¨ä¸æ¶‰åŠåŸºäºç´¢å¼•çš„æ•°æ®å­˜å–ï¼‰\ntype Item = (Value, Weight) knapsack :: [Item] -\u0026gt; Int -\u0026gt; Int -- items + capacity -\u0026gt; maximal value knapsack _ 0 = 0 knapsack [] _ = 0 knapsack ((v,w):items) c = let choose = v + knapsack items (c-w) -- choose current item chxxse = knapsack items c -- not choose current item in if w \u0026gt; c then chxxse else max choose chxxse ä¸¥æ ¼æ±‚å€¼ - ä¸é€’å½’çš„ç†ç”± åœ¨èƒŒåŒ…é—®é¢˜çš„ C++ ï¼ˆä¸¥æ ¼æ±‚å€¼è¯­è¨€ï¼‰å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¸ç”¨é€’å½’çš„ç†ç”±æ˜¯å¯¹äºæ€§èƒ½çš„è¿½æ±‚ï¼Œå› è€Œä½¿ç”¨ dp[i][j] ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œå°†é€’å½’ä¸­çš„é‡å¤è®¡ç®—è½¬æ¢ä¸ºæ•°ç»„çš„ç´¢å¼•è®¿é—®. è¿™ä¸ªè®°å¿†åŒ–çš„å·¥ä½œï¼Œé™¤äº†æˆ‘ä»¬è‡ªå·±åšï¼ˆä¹Ÿå°±æ˜¯ä½¿ç”¨ dp æ•°ç»„ï¼‰ï¼Œè¿˜å¯ä»¥ â€”â€” äº¤ç»™ç¼–è¯‘å™¨. å½“ç„¶è¿™ç§å½¢å¼çš„è®°å¿†åŒ–å°±ä¸æ˜¯åœ¨æºä»£ç å±‚é¢ä¸Šå‘ˆç°ä¸€ä¸ªè®°å¿†æ•°ç»„äº†ï¼Œè€Œæ˜¯é€šè¿‡æ±‚å€¼ç­–ç•¥æ¥å®ç°. åœ¨è®¨è®ºæ±‚å€¼ç­–ç•¥å‰ï¼Œå…ˆçœ‹çœ‹ä»€ä¹ˆæ˜¯çº¯å‡½æ•°.\nå¯¹äº \u0026quot; çº¯ \u0026quot; å‡½æ•°çš„è®¨è®º å‡½æ•°æ˜¯ä»€ä¹ˆï¼Ÿ/ å‡½æ•°çš„è¡¨ç¤ºæ³• / LUT çš„ç±»æ¯” / ç¼–è¯‘å™¨è¡Œä¸º / çº¯å‡½æ•°çš„æ±‚å€¼ç­–ç•¥\nâ€”â€” å¤šå¹´ä»¥åï¼Œé¢å¯¹ \u0026ldquo;å‡½æ•°å¼ç¨‹åºè®¾è®¡\u0026rdquo;ï¼ŒğŸŸå°†ä¼šå›æƒ³èµ·æ•°å­¦è€å¸ˆå¸¦å¥¹å»è§è¯†å‡½æ•°çš„é‚£èŠ‚é¥è¿œçš„æ•°å­¦è¯¾.\nå‡½æ•°æ˜¯ä¸€ç§æ˜ å°„å…³ç³». ä½“ç°è¿™ç§å…³ç³»çš„æ–¹å¼ï¼Œå³ å‡½æ•°çš„è¡¨ç¤ºæ³•ï¼Œé™¤äº†å‡½æ•°è¡¨è¾¾å¼ã€å‡½æ•°å›¾åƒï¼Œè¿˜æœ‰è¡¨æ ¼.\nå¦‚æœæˆ‘ä»¬éœ€è¦ä¸€å°æœºå™¨æ¥æ‰§è¡Œå®šä¹‰åŸŸä¸ºæŸæœ‰ç©·é›†çš„å®Œå…¨å¹³æ–¹å‡½æ•° f(x, y) = x*x + y*yï¼Œé™¤äº†ä¾èµ–åŠ æ³•å™¨ã€ä¹˜æ³•å™¨æ„æˆçš„ç»„åˆé€»è¾‘ç”µè·¯ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨ LUTï¼ˆLookUp Tableï¼‰ï¼Œè™½ç„¶å¬èµ·æ¥æœ‰ç‚¹ç¦»è°±ï¼Œä½†æ˜¯å®ƒçš„å¯è¡Œæ€§æ˜¯ä¸å¯å¦è®¤çš„.\nNOTE: å¯èƒ½äº§ç”Ÿçš„ç–‘æƒ‘ - å¦‚ä½•ç¡®å®š / å¦‚ä½•æè¿°ç”µè·¯å®ç°çš„å‡½æ•°ä¸æˆ‘ä»¬é¢„æœŸçš„å‡½æ•°ä¹‹é—´çš„ç­‰ä»·æ€§ï¼Ÿæˆ–è€…è¯´ï¼Œæˆ‘ä»¬é¢„æœŸçš„æ˜¯å‡½æ•° $f$ï¼Œç”µè·¯å®ç°çš„æ˜¯å‡½æ•° $f\u0026rsquo;$ï¼Œå¦‚ä½•ç¡®å®š $f\u0026rsquo; \\equiv f$ï¼Ÿå¦‚æœä½ å¯¹ $Î»$ æ¼”ç®—ï¼ˆé€»è¾‘å­¦ï¼‰ä¸­å‡½æ•°ç­‰ä»·çš„å½¢å¼åŒ–ç†è®ºæ„Ÿå…´è¶£ï¼Œå¯ä»¥å‚çœ‹ Lambda Calculus and Combinators, an introduction - Chapter 5~8. è¿™é‡Œ LUT å®ç°çš„å‡½æ•° $f_1\u0026rsquo;$ ä¸é¢„æœŸå‡½æ•° $f$ å¤–å»¶ç­‰ä»·ï¼ˆextensional equivalenceï¼‰ï¼Œç»„åˆé€»è¾‘å®ç°çš„å‡½æ•° $f_2\u0026rsquo;$ ä¸é¢„æœŸå‡½æ•° $f$ å†…æ¶µç­‰ä»·ï¼ˆintensional equivalenceï¼‰.\næˆ‘ä»¬ä¹ æƒ¯çš„ç¼–è¯‘å™¨çš„è¡Œä¸ºå¤§è‡´æ˜¯ï¼šçœ‹åˆ°å‡½æ•°+å‚æ•° â†’ æ”¾å…¥ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—ï¼›å¦‚æœåªä¾èµ–æ˜ å°„è¡¨ï¼ˆLUTï¼‰ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨çš„è¡Œä¸ºå¤§è‡´æ˜¯ï¼šçœ‹åˆ°å‡½æ•°+å‚æ•° â†’ åœ¨ LUT ä¸­æŸ¥æ‰¾å¯¹åº”è¾“å‡ºï¼Œè¿™éœ€è¦ LUT å­˜å‚¨å¥½æ‰€æœ‰å‡½æ•°è¾“å…¥å¯¹åº”çš„è¾“å‡ºï¼Œäºæ˜¯å‹åŠ›ç»™åˆ° LUTï¼›æŠ˜ä¸­çš„ç­–ç•¥æ˜¯ï¼Œç¬¬ä¸€æ¬¡è§åˆ°å‡½æ•°+å‚æ•°æ—¶ï¼Œåˆ©ç”¨ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—ï¼Œå¹¶ç¼“å­˜åˆ° LUTï¼Œå†æ¬¡è§åˆ°è¿™ç»„å‡½æ•°+å‚æ•°ï¼Œç›´æ¥åœ¨ LUT ä¸­æŸ¥æ‰¾.ï¼ˆå‡½æ•°å¼æœ‰è‡ªå·±çš„é«˜é€Ÿç¼“å­˜:ï¼‰\nå­è¿‡ç¨‹ä¸å‡½æ•° / å‰¯ä½œç”¨ä¸çº¯åº¦\nè¿™é‡Œæˆ‘ä»¬ç”¨å‡½æ•°æŒ‡ä»£â€œçº¯â€å‡½æ•°ï¼ˆå®šä¹‰è§ä¸‹ï¼‰ï¼Œå°†éçº¯çš„è¿‡ç¨‹ç§°ä¸ºå­è¿‡ç¨‹.\nä½¿ç”¨ LUT å®ç°å‡½æ•°çš„å‰ææ˜¯ï¼šå‡½æ•°æ˜¯çº¯çš„ï¼Œå³å¯¹ç›¸åŒçš„è¾“å…¥æ€»æ˜¯è¿”å›ç›¸åŒçš„è¾“å‡ºï¼Œå¹¶ä¸”ä¸äº§ç”Ÿå‰¯ä½œç”¨. å½¢è±¡åœ°è¯´ï¼Œæˆ‘ä»¬å¸Œæœ› LUT æ˜¯ä¸¥æ ¼çš„ï¼ŒIN / OUT å¼•è„šä¿æŒå¹²å‡€ï¼ŒIN æ¥æ”¶å‡½æ•°å‚æ•°ï¼ŒOUT ç»™å‡ºå‡½æ•°è¾“å‡ºï¼Œä¸å¸Œæœ›åœ¨ IN ä¹‹å¤–ï¼Œå†ä»æŸä¸ªå¯„å­˜å™¨æ¥è¿›æ¥ä¸€ä¸ªè¾“å…¥ï¼Œä¹Ÿä¸å¸Œæœ›åœ¨ OUT çš„æ—è¾¹ï¼Œå¤šè¿æ¥ä¸€ä¸ªå¯„å­˜å™¨ï¼ŒæŠŠå¯„å­˜å™¨å­˜å‚¨å€¼çš„æ”¹å˜ä½œä¸ºå‡½æ•°æ‰§è¡Œçš„ç»“æœï¼›å³ å‡½æ•°æœ¬èº«æ€»æ˜¯ç‹¬ç«‹äºç¨‹åºçš„å…¶ä»–éƒ¨åˆ† - LUT æ€»æ˜¯ç‹¬ç«‹äºç”µè·¯çš„å…¶ä»–éƒ¨åˆ†ï¼Œä¸å—å…¶ä»–éƒ¨åˆ†å½±å“.\nè¾“å…¥è¾“å‡ºçš„çº¯åº¦ï¼š\naddx æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºè¿™ä¸ªå‡½æ•°æ— æ³•ä¿è¯å¯¹äºåŒæ ·çš„ a æ€»æ˜¯ç»™å‡ºç›¸åŒçš„è¾“å‡ºï¼Œå› ä¸ºå…¨å±€å˜é‡ x å¯èƒ½éšæ—¶è¢«ä¿®æ”¹ï¼Œå¯¼è‡´ä¿®æ”¹å‰å a + x çš„å€¼ä¸åŒï¼›readOneWord æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºæ— æ³•ä¿è¯å¯¹äºåŒä¸€ä¸ªè·¯å¾„ pï¼Œå§‹ç»ˆè¿”å›åŒæ ·çš„ firstWordï¼Œå› ä¸º p å¯¹åº”çš„æ–‡ä»¶å¯èƒ½è¢«å…¶ä»–ç¨‹åºéšæ—¶ä¿®æ”¹.\nint x; // global int addx(int a){ return a + x; } string readOneWord(path p) { // IO return head(getFile(p)); } å‰¯ä½œç”¨ï¼š\ngreeting æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºå®ƒäº§ç”Ÿäº† print çš„å‰¯ä½œç”¨ï¼› write æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºå®ƒé€ æˆäº†å†™æ–‡ä»¶çš„å‰¯ä½œç”¨.\nvoid greeting(string name){ print(f\u0026#34;Hello, {name}\u0026#34;); } void writeLine(path p) { getFile(p).append(\u0026#34;Append this line\u0026#34;); } \u0026ldquo;æçº¯\u0026rdquo;ï¼Ÿ\nå¯¹äºä¸Šè¿°çš„éçº¯å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‰¯ä½œç”¨åˆ†ç¦»ï¼Œå¾—åˆ°å¯¹åº”çš„çº¯å‡½æ•°å¦‚ä¸‹ï¼š\nint addx(int a, int x) { return a + x; } string readOneWord(file f) { string firstWord = head(f); return firstWord; } string greeting(string name){ return f\u0026#34;Hello, {name}\u0026#34;; } file writeLine(file f){ return f.append(\u0026#34;Append this line\u0026#34;); } åˆ†ç¦»å‰¯ä½œç”¨çš„ç¤ºä¾‹ / Imperative Shell, Functional Core\næé—®ï¼šå‡è®¾æœ‰ä¸¤ä¸ªç±» Camera, FaceRecognizerï¼ŒCamera ç±»æœ‰ä¸€ä¸ªæ–¹æ³• getFrame ç”¨äºä»ç‰©ç†æ‘„åƒå¤´æ•è·ä¸€å¸§å›¾åƒï¼ŒFaceRecognizer ç±»æœ‰ä¸€ä¸ªæ–¹æ³• recognizePerson ç”¨äºè¯†åˆ«ä¸€å¸§å›¾åƒä¸­çš„äººè„¸å¹¶è¿”å›å¯¹åº”ç”¨æˆ·å. è‹¥éœ€è¦å®ç°å‡½æ•° getFrameAndRecognize ç”¨äºæ•è·å½“å‰å¸§ã€è¯†åˆ«å¹¶è¿”å›ç”¨æˆ·åï¼Œå¦‚ä½•ç»„ç»‡ç¨‹åºç»“æ„ï¼Ÿ\nä¸€ç§ç­”æ¡ˆï¼šå°† FaceRecognizer çš„å®ä¾‹ä½œä¸º Camera çš„æˆå‘˜ï¼Œä¿è¯ FaceRecognizer çš„çº¯åº¦ï¼Œå³ FaceRecognizer çš„æ–¹æ³•æ€»æ˜¯å¯¹å¸§åšè®¡ç®—ï¼Œå°† getFrame è¿™æ ·çš„å‰¯ä½œç”¨åˆ†ç¦»ã€æ­¢æ­¥äº Camera ç±».\nclass Camera: self.face_recognizer = FaceRecognizer() def getFrame(): # snip # return frame def getFrameAndRecognize(): frame = getFrame() name = face_recognizer.recognizePerson(frame) return name class FaceRecognizer: def recognizePerson(frame: image): # snip # return name å³ï¼šä¿è¯åŠŸèƒ½å‡½æ•°çš„çº¯åº¦ï¼Œå¹¶å°†å…¶ä½œä¸ºç¨‹åºçš„æ ¸å¿ƒï¼Œå°† IO ç­‰éçº¯æ“ä½œåˆ†ç¦»åˆ°å¤–å±‚ â€”â€” Imperative Shell, Functional Core. ï¼ˆæ­¤å¤„åº”æœ‰ä¸€åœº Simon Peyton Jones çš„è®²åº§é“¾æ¥ï¼Œä½†æˆ‘ä¸€æ—¶æ‰¾ä¸åˆ°äº†.ï¼‰\nè¿½æ±‚çº¯åº¦çš„ç†ç”±\næ–¹ä¾¿å•å…ƒæµ‹è¯•ä¸ç»´æŠ¤ï¼›\næ˜“äºå¹¶è¡Œï¼›\nå¯ä»¥ç”¨æŸ¥è¡¨ä½œä¸ºä¸€ç§æ±‚å€¼ç­–ç•¥ï¼Œæˆ–è€…ä½œä¸ºæ±‚å€¼ç­–ç•¥çš„ä¸€éƒ¨åˆ†ï¼Œé¿å…äº†é‡å¤è®¡ç®—å¸¦æ¥çš„å¼€é”€.\nè¯­æ³•æ ‘ä¸è¯­æ³•å›¾ / é‡å¤è®¡ç®— / æ±‚å€¼ç­–ç•¥\nä¸€äº›å‚è€ƒèµ„æ–™\nHaskell Wiki - Graph Reduction\nä» Lambda Calculus è§’åº¦è§£é‡Šæ“ä½œè¯­ä¹‰ call-by-value / call-by-name / call-by-needï¼Œå¯ä»¥å‚è€ƒ Types and Programming Language, Section 5.1\n[TODO]\nè¿™ä¸€èŠ‚è¿˜æ²¡å†™çš„åŸå› æ˜¯ï¼šæˆ‘ ä¹Ÿ ä¸ æ˜¯ å¾ˆ æ‡‚.\ngraph reduction çš„å›¾ç¤º\nè¯­æ³•æ ‘ä¸è¯­æ³•å›¾æ¯”è¾ƒ\nlet å¯¹åº”çš„è¯­æ³•å›¾ï¼ˆåŠå…¶ Core è§£é‡Šï¼Ÿï¼‰\n\u0026hellip;\næƒ°æ€§æ±‚å€¼ - é€’å½’çš„ç†ç”± ç…§åº”æœ¬æ–‡ 3.2 ä¸é€’å½’çš„ç†ç”± é¿å…é‡å¤è®¡ç®—çš„æ–¹å¼é™¤äº†é€šè¿‡æ˜¾å¼ç¼“å­˜ï¼ˆè®°å¿†æ•°ç»„ï¼‰ï¼Œè¿˜å¯ä»¥ä¾èµ–ç¼–è¯‘å™¨é‡‡å–çš„æ±‚å€¼ç­–ç•¥ï¼ˆæƒ°æ€§æ±‚å€¼ Lazy Evaluationï¼‰ï¼Œå°†è¯­æ³•æ ‘ä¸­çš„æ‰€æœ‰ç›¸åŒçš„è¡¨è¾¾å¼ç»“ç‚¹æŒ‡å‘åŒä¸€ä¸ªç»“ç‚¹ï¼Œå®ç°è®¡ç®—ç»“æœçš„å¤ç”¨.\nå…¶ä»– å‰æ–‡è¯•å›¾åœ¨ å‘½ä»¤å¼è¯­è¨€ / å‡½æ•°å¼è¯­è¨€ï¼Œé€’å½’ / éé€’å½’ ä¹‹é—´åšæ¯”è¾ƒæ˜ç¡®çš„åŒºåˆ†ï¼Œå…¶å®ï¼Œå½“ç„¶é€’å½’ä¸æ˜¯ FP çš„ä¸“åˆ©ï¼Œè®°å¿†åŒ–æ•°ç»„ä¹Ÿä¸åªæ˜¯åœ¨å‘½ä»¤å¼ç¨‹åºé‡Œå¥½ç”¨ï¼Œåªæ˜¯ä¸åŒè¯­è¨€ / ç¼–ç¨‹èŒƒå¼æœ¬èº«çš„ç‰¹æ€§ï¼ˆä¾‹å¦‚ C++ çš„ä¸¥æ ¼æ±‚å€¼ / Haskell çš„æƒ°æ€§æ±‚å€¼ï¼‰ï¼Œä½¿å¾—æˆ‘ä»¬å¯¹äºç¨‹åºäº§ç”Ÿäº†ä¸ä¸€æ ·çš„æ€è€ƒå’Œä¸ä¸€æ ·çš„æƒ¯æ€§. å¯¹äºçº¯åº¦ä¸æƒ°æ€§æ±‚å€¼ï¼Œå‘½ä»¤å¼è¯­è¨€ä¹Ÿå¯ä»¥æœ‰çµæ´»çš„æ±‚å€¼ç­–ç•¥ï¼Œæ¯”å¦‚åˆ¤æ–­å‡½æ•°çš„çº¯åº¦ï¼Œå¯¹éçº¯å‡½æ•°ä¸¥æ ¼æ±‚å€¼ï¼Œå¯¹çº¯å‡½æ•°æƒ°æ€§æ±‚å€¼.\n","date":"2024-10-20T19:48:00+08:00","permalink":"http://localhost:1313/p/how-to-avoid-redundant-computations--pure-functions-and-their-evaluation-strategies/","title":"How to Avoid Redundant Computations + Pure Functions and Their Evaluation Strategies"},{"content":"æ¥è‡ª Lambda-Calculus and Combinator Â§ 4C Theorem 4.20 çš„ proof éƒ¨åˆ†ï¼Œæ•´ä½“æ„å›¾æ˜¯è¯æ˜ç¬¦åˆ Definition 4.18 çš„å…¨ç§°é€’å½’å‡½æ•°å¯ä»¥ç”¨ç»„åˆå­æ¥è¡¨ç¤º.â€‚è¿™é‡Œå¯¹è¯¥è¯æ˜çš„å…³é”®éƒ¨åˆ†ï¼Œå³è¿­ä»£ç»„åˆå­çš„æ„é€ ï¼Œåšç®€è¦çš„é™ˆè¿°. ä¹Ÿå¯ä»¥ç†è§£ä¸ºï¼šåœ¨ Pure Lambda Calculus ä¸­ç¼–å†™ä¸€ä¸ªå…·æœ‰ç‰¹å®šç»ˆæ­¢æ¡ä»¶çš„è¿­ä»£ç¨‹åº. å¦‚æœä½ å¥½å¥‡ \u0026quot; å¦‚ä½•åœ¨ Lambda Calculus ä¸­ç¼–å†™ä¸€ä¸ªæŒ‡å®šè¿­ä»£ / é€’å½’æ¬¡æ•°çš„è¿­ä»£ / é€’å½’å‡½æ•° \u0026quot; ï¼Œå¯ä»¥å‚è€ƒ Lambda-Calculus and Combinator Â§ 4B Theorem 4.11 çš„ proof ä¸­ $R_{\\text{Bernays}}$ ç»„åˆå­çš„æ„é€ ï¼Œè¿™ä¸ªæ„é€ è¿‡ç¨‹ä¹Ÿååˆ†ç²¾å·§.\né€’å½’ä¸è¿­ä»£ï¼šåœ¨ $R_{\\text{Bernays}}$ é€’å½’ç»„åˆå­çš„æ„é€ ä¸­ï¼Œæ±‚è§£æŸä¸ªé€’å½’å‡½æ•° $\\phi $ çš„å€¼ $ \\phi(n) $ï¼Œç”¨çš„æ–¹æ³•å°±æ˜¯ä» $ \\phi(0) $ å¼€å§‹ï¼Œåš $n$ æ¬¡è¿­ä»£å¾—åˆ°çš„ï¼ˆå¤§è‡´å¦‚ä¸‹ï¼šè®°é€’å½’æ­¥æ›´æ–°å‡½æ•°ä¸º $\\chi$ï¼Œ$\\phi(n) = \\chi^n \\phi(0)$ï¼‰. è¿­ä»£å’Œé€’å½’æ˜¯æ­£å‘ä¸é€†å‘çš„åŒºåˆ«. æœ¬æ–‡ä¸­çš„\u0026quot;é€’å½’\u0026quot;æ„åœ¨æè¿°\u0026quot;è°ƒç”¨è‡ªèº«\u0026quot; çš„ç»“æ„ç‰¹ç‚¹ï¼Œæ¢è®¨çš„ä¸­å¿ƒé—®é¢˜è¿˜æ˜¯å¯¹è¿­ä»£ï¼ˆ$0 \\rightarrow 1 \\rightarrow \u0026hellip; \\rightarrow n$ï¼‰é—®é¢˜çš„æ±‚è§£.\næ„é€ ç›®æ ‡ å‡è®¾æœ‰ä¸€ä¸ªæ£€æŸ¥å‡½æ•° $X$ï¼Œè¿­ä»£çš„ç»ˆæ­¢æ¡ä»¶ä¸º $XY=_{\\beta,w}\\bar{0}$, æˆ‘ä»¬å¸Œæœ›æ„é€ ä¸€ä¸ªç»„åˆå­ $P$,å¾—åˆ°æœ€å°çš„ç¬¦åˆç»ˆæ­¢æ¡ä»¶çš„ $Y$. å³ä» $Y = \\bar{0}$ å¼€å§‹ï¼Œæ£€æŸ¥ $(XY) = _{\\beta,w}? \\bar{0}$ ï¼Œè‹¥æ¡ä»¶æ»¡è¶³ï¼Œåˆ™è¿”å›å€¼ä¸ºæ­¤ $Y$ï¼Œå¦åˆ™ç»§ç»­æ£€æŸ¥ $X(\\bar{\\sigma}Y)$ï¼Œæˆ‘ä»¬å¸Œæœ›æ„é€ ä¸€ä¸ªç»„åˆå­ $P$ è‡ªåŠ¨åŒ–æ­¤æ£€æŸ¥è¿‡ç¨‹ï¼Œå½¢å¼åŒ–åœ°ï¼Œæˆ‘ä»¬é¢„æœŸ $P$ çš„è¡Œä¸ºå¦‚ä¸‹:\n$$ PXY =_{\\beta,w}Y \\quad \\text{, if } XY = _{\\beta,w}\\bar{0};$$\n$$ PXY =_{\\beta,w}PX(\\bar{\\sigma}Y), \\text{ otherwise} $$\nå®Œå…¨å°Šé‡é¢„æœŸï¼Œå†™ä¸€ä¸ª $P$ ç»„åˆå­ï¼š$P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$ï¼Œå…¶ä¸­ $\\textbf{D}=\\lambda xyz.z(\\textbf{K}y)x$, å¯ä»¥ç”¨ $\\textbf{Y}$ å¯¹è¿™ä¸ªé€’å½’çš„ $P$ ç»„åˆå­è¿›è¡Œæ±‚è§£ï¼ˆ$P = \\textbf{Y}(\\lambda uxy.\\textbf{D}y(ux(\\bar{\\sigma}y))(xy))$ï¼‰ï¼Œä½¿ç”¨ $\\textbf{Y} $ ç»„åˆå­æ±‚è§£å‡ºçš„ $P$ æ²¡æœ‰ normal formï¼Œè¿™é‡Œä¸é‡‡ç”¨æ­¤ $P$ï¼Œæˆ‘ä»¬å°è¯•é€å±‚æ„é€ ä¸€ä¸ªå…·å¤‡ normal form çš„ $P$ ç»„åˆå­.\næ„é€ è¿‡ç¨‹ åŸºæœ¬ç»“æ„ ç”¨é«˜çº§è¯­è¨€çš„ä¼ªä»£ç è¡¨ç¤ºç°æœ‰çš„ $P$:\ncombinator p(x,y): // L1: define p if (xy == 0): return const(y) else: return p(x, Ïƒ y) // L5: call p é€’å½’çš„ $\\lambda $ï¼Œå½¢å¦‚ $P \\equiv \\lambda x. MPN $ï¼Œåƒè¿™æ ·çš„ $\\lambda$-termï¼Œç¬¦åˆæˆ‘ä»¬åœ¨é«˜çº§è¯­è¨€ç¨‹åºè®¾è®¡çš„ç»éªŒï¼Œä½†æ˜¯ä¸ç¬¦åˆ Lambda Calculus ä¸­çš„è§„èŒƒï¼Œå› ä¸º Lambda Calculus å¯¹ $\\lambda$-term çš„å½’çº³å®šä¹‰å¹¶ä¸åŒ…å«ä¸º abstraction èµ‹æ ‡è¯†ç¬¦çš„è§„åˆ™ï¼Œæˆ‘ä»¬å†™ $P$ ç­‰æ ‡è¯†ç¬¦çš„ç›®çš„åªåœ¨äºæå‡å¯è¯»æ€§å’Œæ˜ç¡®è¡¨è¾¾å¼ç»“æ„ï¼Œè€Œä¸æ˜¯å€ŸåŠ©æ ‡è¯†ç¬¦çš„å¤ç”¨æ¥åƒé«˜çº§è¯­è¨€ç¼–ç¨‹ä¸€æ ·å®šä¹‰é€’å½’å‡½æ•°. ä¸€ä¸ªç»†èŠ‚æ˜¯ï¼Œæˆ‘ä»¬åœ¨ä¹¦é‡Œçœ‹åˆ°çš„ä¸ºæŸä¸ª $\\lambda$-term è®°æ ‡è¯†ç¬¦ç”¨çš„ç¬¦å·æ˜¯ $\\equiv$ è€Œä¸æ˜¯ $=$.\næˆ‘ä»¬ä¸èƒ½é€šè¿‡æ ‡è¯†ç¬¦çš„å¤ç”¨å®šä¹‰é€’å½’ä¸æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½å®šä¹‰é€’å½’ï¼Œåªæ˜¯æˆ‘ä»¬éœ€è¦ä¾èµ–å¤šä¸€å±‚çš„æŠ½è±¡æ¥æ„é€ å‡º å½¢å¼ä¸Šçš„éé€’å½’ï¼Œäº‹å®æ„ä¹‰ä¸Šçš„é€’å½’.\nä»é«˜çº§è¯­è¨€ç¼–ç¨‹çš„è§’åº¦å‡ºå‘ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ç”¨æŸç§æ–¹å¼å–ä»£ L5 ä¸­å¯¹ p è‡ªèº«çš„è°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥å¦‚ä¸‹ä¿®æ”¹æˆ‘ä»¬çš„ä»£ç . ä¸ºäº†ä¸¤ä¸ªåˆ†æ”¯çš„ç»“æ„ä¸€è‡´ï¼Œæˆ‘ä»¬è®¾è®¡ä¸€ä¸ªå‡½æ•°åˆ—è¡¨ tï¼Œt ä¸­çš„ä¸¤ä¸ªå‡½æ•°å¯¹åº”ä¸¤ä¸ªåˆ†æ”¯ï¼Œå‡½æ•° getCurrentY å°†è¿”å›å½“å‰ y å€¼ï¼Œrecursion_p å°†æ‰¿æ‹…é€’å½’çš„å·¥ä½œï¼šï¼ˆè¿™é‡Œå…ˆä¸è€ƒè™‘å‡½æ•°çš„å…·ä½“ç»“æ„å’Œå‚æ•°è®¾è®¡/å‚æ•°ä¼ é€’çš„é—®é¢˜ï¼Œåé¢æ€»æœ‰åŠæ³•çš„ï¼Œè¿™é‡Œæˆ‘ä»¬åªå…³å¿ƒæ•´ä½“ç»“æ„ï¼‰\nt = [getCurrentY, recursion_p] // list of functions combinator p(x,y): if (xy == 0): return t[0] else: return t[1] å¦‚ä½•åœ¨ Lambda Calculus ä¸­è¡¨è¾¾ä»¥ä¸Šçš„ä»£ç ï¼Ÿä¸ºäº†ä¸“æ³¨äºæˆ‘ä»¬ç›®å‰å¤„ç†çš„æŠ½è±¡å±‚æ¬¡ï¼Œå…ˆå°† $P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$ çš„ç»“æ„ç®€åŒ–ä¸º $P \\equiv \\lambda xy.\\textbf{D}AB(xy)$\næ ¹æ®é¢„æœŸ / ä¸Šé¢çš„ä¼ªä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¤§è‡´çš„ $\\lambda $ æ¡†æ¶å¦‚ä¸‹:\n$$ P \\equiv \\lambda xy. T(xy)[params] $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda [params]. \\dots$$ $$ B \\equiv \\lambda [params]. \u0026hellip;$$\næ­¤æ—¶ $PXY = _{\\beta,w} T(XY) $ï¼Œ$ XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A; XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B $ .\næˆ‘ä»¬é¢„æœŸï¼šå°†åˆ†æ”¯çš„å…·ä½“é€»è¾‘æ”¾åœ¨ $T$ ä¸­ï¼Œå°†åˆ†æ”¯çš„é€‰æ‹©å’Œåˆ†æ”¯å‡½æ•°å‚æ•°ä¼ é€’æ”¾åœ¨ $P$ ä¸­.\nå…·ä½“ç»†èŠ‚ ä¸Šé¢æˆ‘ä»¬å¿½ç•¥äº†è®¸å¤šç»†èŠ‚ï¼Œç°åœ¨æ˜¯è€ƒè™‘ç»†èŠ‚çš„æ—¶å€™äº† :)\né¦–å…ˆæ³¨æ„ä¸€ä¸ªäº‹å®ï¼šæˆ‘ä»¬å°†åˆ†æ”¯å‡½æ•°å‚æ•°ä¼ é€’çš„å·¥ä½œæ”¾åœ¨ $P$ ä¸­ï¼Œæ„å‘³ç€æ— è®ºå½“å‰ $P$ ä¸­çš„ $(xy)$ å°†å¯¼å‘å“ªä¸ªåˆ†æ”¯ï¼Œæˆ‘ä»¬ä¼ é€’çš„å‚æ•°åˆ—è¡¨éƒ½æ˜¯ä¸€è‡´çš„ / éƒ½åªèƒ½æ˜¯ä¸€è‡´çš„. å› ä¸º $(xy) = _{\\beta,w}\\bar{0}$ å¯¹åº”çš„æƒ…å†µæ›´ç®€å•ï¼Œåªéœ€è¿”å›å½“å‰ $y$ï¼Œæ‰€ä»¥æˆ‘ä»¬å»¶åè€ƒè™‘è¿™ä¸€æƒ…å†µï¼Œå…ˆè€ƒè™‘ $(xy) â‰  _{\\beta,w}\\bar{0}$ çš„æƒ…å†µï¼Œè®©å‰è€…è¿å°±åè€…ï¼ˆï¼Œå› ä¸ºä¸¤ä¸ªåˆ†æ”¯éƒ½ä¸ $y$ æœ‰å…³ï¼Œæ‰€ä»¥å‚æ•°åˆ—è¡¨ä¸­å¿…ç„¶æœ‰ $y$ï¼Œåœ¨è¿™ä¸€ç‚¹ä¸Šä¸¤ä¸ªåˆ†æ”¯æ˜¯æœ‰å…±æ€§çš„ï¼›å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥ä¸¤ä¸ªåˆ†æ”¯å‡½æ•°å¯¹åº”çš„å‚æ•°å¹¶åˆ—ä¼ é€’ï¼Œç„¶ååœ¨ $A$,$B$ çš„å…·ä½“å®ç°ä¸­ ä¸å¯¹ä¸æœ¬åˆ†æ”¯æ— å…³çš„å‚æ•°è¿›è¡Œç»‘å®šï¼‰.\né€’å½’ï¼ˆè¿­ä»£ï¼‰åˆ†æ”¯çš„æ„é€  ç›®æ ‡æ˜¯ï¼š$XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B \\xlongequal{\\text{expected}} PX(\\bar{\\sigma}Y) $ï¼Œæˆ‘ä»¬å¸Œæœ›å‡½æ•° $B$ ä¸ $P$ ä¸­ä¼ é€’çš„ $[params]$ åº”ç”¨åå¾—åˆ°çš„ $\\lambda$-term å’Œ $PXY$ å…·å¤‡ä¸€æ ·çš„ç»“æ„ï¼ˆæ³¨æ„ä¸æ˜¯ $B$ å’Œ $P$ ä¸¤ä¸ª abstraction æœ¬èº«ç»“æ„ä¸€è‡´ï¼‰ï¼Œåªæ˜¯ $Y$ ä½ç½®çš„å€¼æ›¿æ¢æˆäº† $(\\bar{\\sigma}Y)$ï¼Œä¸ºäº†å¾—åˆ°å’Œ $P$ ä¸€æ ·çš„ç»“æ„ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯â€”â€”æŠŠ $P$ ç°æœ‰çš„ç»„ä»¶ä½œä¸º $[params]$ ä¼ é€’åˆ° $B$ï¼ˆï¼Œå½“ç„¶ä¹Ÿä¼ é€’åˆ°äº† $A$ï¼‰ï¼Œç„¶ååœ¨ $B$ ä¸­æŠŠè¿™äº›ç»„ä»¶é‡ç»„æˆ $P$ çš„ç»“æ„ï¼š\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(uv) $$\nï¼ˆ$ T \\mapsto t, x \\mapsto u, y \\mapsto v$ï¼‰\nç”±äº $[params]$ çš„ä¼ é€’ï¼Œç°åœ¨ $P$ çš„ç»“æ„å‘ç”Ÿäº†æ”¹å˜ï¼Œæˆ‘ä»¬éœ€è¦è®© $B$ ä¸æ–°çš„ $P$ ç»“æ„åŒæ­¥ï¼›å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ $B$ çš„å†…éƒ¨å°†ä¼ é€’è¿›æ¥çš„ $y$ ï¼ˆç”± $v$ ç»‘å®šï¼‰å˜ä¸º $\\bar{\\sigma}y$ï¼š\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\nåšä¸€ä¸ªæ£€æŸ¥ï¼šå½“ $XY \\neq _{\\beta, w} \\bar{0}$ï¼š\n$ \\quad PXY $ $ = _{\\beta,w} T(XY)TXY $ $ = _{\\beta,w} BTXY $ $ = _{\\beta,w} T(X(\\bar{\\sigma}Y))TX(\\bar{\\sigma}Y) $ $ = _{\\beta,w} PX(\\bar{\\sigma}Y) $ ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸï¼Œè‡³æ­¤ï¼Œè¿­ä»£åˆ†æ”¯çš„æ„é€ å°±å®Œæˆäº†.\nè¿­ä»£ç»ˆæ­¢åˆ†æ”¯çš„æ„é€  ç›®æ ‡æ˜¯ï¼š$XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A \\xlongequal{\\text{expected}} Y $ï¼Œåœ¨ $B$ çš„æ„é€ è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²æœ‰çš„å‚æ•°åˆ—è¡¨æ˜¯ $ t \\mapsto T, u \\mapsto x, v \\mapsto y$ï¼Œåœ¨ $A$ ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠ $y$ æå–å‡ºæ¥å³å¯ï¼Œæ‰€ä»¥ $A = \\lambda tuv.v$ ï¼Œå¦‚æœä½ å¸Œæœ›å’Œ Definition 4.8 çš„è®°æ³•ä¿æŒä¸€è‡´ï¼Œé‚£ä¹ˆ $A = \\Pi^3_3$.\nå®Œæ•´ $\\lambda$ $$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. v (= _{\\beta,w} \\Pi^3_3) $$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\nLCaC Theorem 4.20 ä¸­çš„ $P$ ç®€è¿° LCaC Theorem 4.20 ä¸­ç»™å‡ºçš„ $P$ å®šä¹‰å¦‚ä¸‹ï¼š\n$$ T \\equiv \\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v)) $$ $$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$\nä»¥ä¸å‰æ–‡ä¸€è‡´çš„æ ¼å¼è½¬å†™ï¼š\n$$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$ $$ T \\equiv \\lambda x.\\textbf{D}AB $$ $$ A \\equiv \\bar{0} $$ $$ B \\equiv \\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v) $$\nåœ¨ä¸€äº›æ—¶åˆ»æŠŠ $(Tx)$ ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè®©è¡¨è¾¾å¼æ›´ç®€æ´äº†ä¸€äº›ï¼ŒåŒæ—¶è®© $x$ å’Œ $T$ æœ‰ç»‘å®šå…³ç³»ï¼ˆ$T \\equiv \\lambda x\u0026hellip;.$ï¼‰ï¼Œåœ¨ $T$ çš„å†…éƒ¨ä¾ç„¶å¯ä»¥å•ç‹¬åœ°æ‹¿å‡º $x$ ä½¿ç”¨ï¼›$P$ ä¸­çš„ $(Tx)$ é—­åŒ…ï¼Œä½¿å¾—ä¼ å‚çš„å½¢æ€æ˜¯ $B(Tx)y$ â€”â€” è€Œä¸æ˜¯ $BTxy$ â€”â€”è®© $A$ çš„è®¾è®¡æ›´ç®€æ´äº†ï¼Œ$A \\equiv \\bar{0}$.\nè™½ç„¶åœ¨ç»†èŠ‚ä¸Šç•¥æœ‰å·®åˆ«ï¼Œä½†æ˜¯æ•´ä½“ç»“æ„ä¸æœ¬æ–‡ç»™å‡ºçš„ $P$ æ˜¯ä¸€è‡´çš„ï¼Œæˆ‘è§‰å¾—å¯èƒ½æ˜¯åŒ…å«ä¸€äº›ç›´è§‰ / çµæ„Ÿ / ä¼˜åŒ–ä¸Šçš„å·®å¼‚.\nå…¶ä»– å°è¯•ç€å±•å¼€ä¸Šé¢çš„ $P$:\n$$ \\lambda xy.\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x(xy)(\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x)y$$\nå¦‚æœä½ æ„¿æ„æŠŠä»¥ä¸‹ä¹Ÿå…¨éƒ¨å±•å¼€ï¼š $ \\textbf{D} = _{\\beta, w} \\lambda xyz.z(\\textbf{K}y)x, \\quad \\textbf{K} = _{\\beta, w} \\lambda xy.x $ $ \\bar{0} = _{\\beta, w} \\lambda xy.y $ $ \\bar{\\sigma} = _{\\beta, w} \\lambda nfz. f (n f z)$ $$ \\lambda xy.\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x(xy)(\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x)y$$\nå¯ä»¥è¯´ï¼Œæˆ‘ä»¬ç”¨è¿™ä¸€å †ç¬¦å· + Pure Lambda Culculus çš„æ¼”ç®—è§„åˆ™å®Œæˆäº†ä¸€ä¸ªè¿­ä»£ç¨‹åºçš„æ„é€ â€”â€”Programming in Pure Lambda Calculus.\n","date":"2024-09-17T23:48:00+08:00","permalink":"http://localhost:1313/p/the-construction-of-the-iteration-combinator-lcac-4c-theorem-4.20/","title":"The Construction of the Iteration Combinator - LCaC Â§ 4C, Theorem 4.20"},{"content":"From Types and Programming Languages Â§ 1.2 What Type Systems Are Good For\nA safe language is one that protects its own abstractions. A safe language is completely defined by its programmer\u0026rsquo;s manual.\nComplete abstraction means that users can fully trust the language design, focusing only on the high-level language abstraction layer, without needing to concern themselves with the specific implementation at the hardware level.\nHigh-level languages provide abstractions over physical devices. For example, arrays are abstractions over memory. Programmers expect that arrays can only be modified through explicit update operations (e.g., arr[1] = 1024). \u0026ldquo;Modifying a variable, and some elements in an array are inexplicably changed\u0026rdquo; (e.g., buffer overflow attacks) is a manifestation of broken abstraction. This means that programmers must have a detailed understanding of the layout of variables (abstractions provided by high-level languages) in memory (real physical devices) to write programs that meet expectations.\nThis reminds me of a series of experiments in CSAPP. Since the goal of CSAPP is to examine computer systems from the programmer\u0026rsquo;s perspective, i.e., viewing hardware from a software perspective, if the programming language used is safe, then we can fully trust the abstractions it provides. Consequently, we cannot see the hardware through the software. If C were safe, then the experiments in CSAPP couldn\u0026rsquo;t be done ğŸ§.\n","date":"2024-09-10T14:10:00+08:00","permalink":"http://localhost:1313/p/safety-abstraction/","title":"Safety \u0026 Abstraction"},{"content":"Motivation: Abstraction Level Up! å¯¹ 2 åº”ç”¨ $3$ æ¬¡ square\n1 ]=\u0026gt; (square (square (square 2))) ;Value: 256 2 â†’ x: å¯¹æŸä¸ªæ•° x åº”ç”¨ $3$ æ¬¡ square\n(define square3 (lambda (x) (square (square (square x))))) square â†’ f: å¯¹æŸä¸ªå€¼ x åº”ç”¨ $3$ æ¬¡æŸä¸ªå‡½æ•° f\n(define three_times_f (lambda (f x) (f (f (f x))))) $3 â†’ i$ : å¯¹æŸä¸ªå€¼ x åº”ç”¨ $i$ æ¬¡æŸä¸ªå‡½æ•° f $(i \\in \\mathbb{N})$\n$i=0$\n(define zero_time_f (lambda (f x) (x))) $i=1$\n(define one_time_f (lambda (f x) (f x))) $i=2$\n(define two_times_f (lambda (f x) (f (f x)))) é€’å½’å®šä¹‰ $i$ æ¬¡åº”ç”¨\né€’å½’åŸºï¼š\n(define zero_time_f (lambda (f x) (x))) é€’å½’æ­¥ï¼š\n(define (succ z) (lambda (f x) (f (z f x)))) é€’å½’æ±‚è§£ $i$ å¯¹åº”çš„ $i$ æ¬¡åº”ç”¨ï¼š\n(define (church i) (if (= i 0) zero_time_f (succ (church (- i 1))) ) ) è¿™å°±æ˜¯è‡ªç„¶æ•° $i$ å¯¹åº”çš„ Church Encoding.\nåœ¨ REPL ä¸­ç®€å•åšä¸€ä¸ªæµ‹è¯•ï¼šå¯¹ 3 åº”ç”¨ $2$ æ¬¡ cube $((3^3)^3=19683)$\n1 ]=\u0026gt; (church 2) ;Value: #[compound-procedure 15] 1 ]=\u0026gt; ( #[compound-procedure 15] cube 3) ;Value: 19683 ç†è§£ Church Encoding Church Encoding ä¸æ˜¯ï¼š\nå¯ä»¥è¢«å­˜å‚¨åœ¨ç‰©ç†å­˜å‚¨å™¨ä¸­çš„ï¼Œå¯ä»¥ç”¨ bit è¡¨ç¤ºçš„æ•°å­—\nä¸ºäº†ç®—æ•°è¿ç®—ï¼ˆç±»ä¼¼ $3.14 Ã— 2.17$ ï¼‰è€Œè®¾è®¡\nChurch Encoding æ˜¯ï¼š\nå¯¹ \u0026quot; è®¡æ•° \u0026quot; çš„æŠ½è±¡ Church Encoding æ˜¯å¯¹è®¡æ•°è¿‡ç¨‹çš„ä¸€ç§æŠ½è±¡ï¼Œåœ¨ Lambda Calculus çš„è¯­å¢ƒé‡Œï¼Œå½’çº³å®šä¹‰ $Î»-term$ çš„ä¸‰æ¡è§„åˆ™åˆ†åˆ«æ¶‰åŠäº† $atom$, $abstraction$, $application$ï¼ŒChurch Encoding å¯ä»¥ç†è§£ä¸ºï¼šæœ‰ä¸€ä¸ªèµ·å§‹çš„ $atom$ å’Œä¸€ä¸ª $abstraction$ ï¼Œæˆ‘ä»¬å¸Œæœ›å¯¹è¿™ä¸ª $atom$ è¿›è¡Œè‹¥å¹²æ¬¡ $abstraction$ çš„åº”ç”¨ï¼ˆ$apply$ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨æ›´é«˜ä¸€å±‚çš„ $abstraction$ æ¥æŠ½è±¡å¯¹ \u0026quot; è‹¥å¹²æ¬¡ \u0026quot; è¿›è¡Œè®¡æ•°çš„è¿‡ç¨‹ï¼Œè¿™ä¸€å±‚å¯¹äºè®¡æ•°è¿‡ç¨‹çš„æŠ½è±¡å°±æ˜¯ Church Encoding.\nChurch Encoding in Scheme $zeroï¼šÎ»f.Î»x.x$\nå¯¹æŸä¸ª $term$ è¿›è¡Œ $0$ æ¬¡ä»»æ„ $abstraction$ çš„åº”ç”¨ï¼Œè¿”å›å€¼ä¾ç„¶æ˜¯åŸæ¥çš„ $term$.\n(define zero (lambda (f x) x)) $oneï¼šÎ»f.Î»x.(fâ€‰x)$ $twoï¼šÎ»f.Î»x.(fâ€‰(fâ€‰x))$ $three: Î»f.Î»x.(fâ€‰(fâ€‰(fâ€‰x)))$\n(define one (lambda (f x) (f x))) (define two (lambda (f x) (f (f x)))) (define thr (lambda (f x) (f (f (f x))))) å†™åˆ° thr çš„æ—¶å€™æ³¨æ„åˆ°è¿™é‡Œçš„é€’å½’ç»“æ„ï¼Œé€’å½’åŸºæ¯«æ— ç–‘é—®æ˜¯ zeroï¼Œé€’å½’æ­¥ succ å¦‚ä¸‹ï¼š\n(define (succ z) (lambda (f x) (f (z f x))) ) åº”ç”¨ä¸¾ä¾‹ Church Encoding æ˜¯å¯¹è®¡æ•°çš„æŠ½è±¡ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›å¯¹ 2 è¿›è¡Œ 3 æ¬¡å¹³æ–¹ï¼ˆsquareï¼‰æ“ä½œï¼š $((2^2)^2)^2=256$\n1 ]=\u0026gt; (thr square 2) ;Value: 256 éªŒè¯ succ çš„æ­£ç¡®æ€§ï¼š\n1 ]=\u0026gt; (succ (succ (succ zero))) ;Value: #[compound-procedure 17] 1 ]=\u0026gt; (#[compound-procedure 17] square 2) ;Value: 256 å‚è€ƒèµ„æ–™ Church Encoding wiki\nTypes and Programming Languages, Chapter 5 The Untyped Lambda-Calculus\nä¸€åˆ™çŸ¥ä¹å›ç­”\n","date":"2024-09-08T20:13:00+08:00","permalink":"http://localhost:1313/p/church-encoding-note/","title":"Church Encoding Note"},{"content":"Introduction SICP Â§ 2.4.3 describes a generic system implemented using table lookup (type Ã— operation two-dimensional table), where concrete functions are hidden under abstractions like \u0026ldquo;generic function + Selector\u0026rdquo;. What would it look like if we put concrete functions under \u0026ldquo;data + Selector\u0026rdquo; abstractions? This article presents a Boolean implementation that conforms to this abstraction (called Message Passing in SICP). The importance of data and functions in programming is self-evident. Let\u0026rsquo;s explore three perspectives on the possible relationships between data and functions: Message Passing â†¦ letting data carry its own functions; Using Haskell\u0026rsquo;s $ â†¦ transforming data into functions; Algebraic data types in Haskell â†¦ constructing data using functions.\nGeneric Functions: Intelligent Operations In section 2.4.3, the authors build a generic system. What is generics? It\u0026rsquo;s a form of abstraction. For several types that share certain characteristics, if we can write a function for one type based on this characteristic, we want to extend this function to other types with the same characteristic. For example: for two Int values, I can calculate their maximum (max Int Int) because Int is comparable (Orderable), meaning the Int type provides implementations of comparison functions like \u0026gt; / \u0026lt; / etc. For other comparable types (those that provide comparison function implementations), we want to extend max to these types:\nmax :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a max x y = if x \u0026gt;= y then x else y We abstract the comparable characteristic into the Ord type class, and the max function can work with any member type of this class.\nWhen we apply the max function to any Ord class type, the compiler helps us find the concrete implementation of \u0026gt;= for that type.\nSo how to find it? One answer is: table lookup. When I need to execute max (operation) on Float (type), I can find the function (the non-generic concrete implementation of max for Float) corresponding to (Float, max) in the Cartesian product of type Ã— operation.\nSICP Page 252: Generics breaks down the type Ã— operation table row by row, with each generic function occupying one row. âœ¨\nData and Functions Intelligent Operation? WHAT IF Intelligent Data Objects? In generic functions mentioned in the previous section, data exists as an object to be operated on. Data\u0026rsquo;s job is to be acted upon by functions. Our generics target functions (operations). In our expectation, we want functions to be smart. For example, max :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a is smart - it can \u0026ldquo;automatically\u0026rdquo; transform into the corresponding non-generic concrete implementation max :: Int -\u0026gt; Int -\u0026gt; Int for its specific type. Data just needs to wait to be acted upon.\nğ–ğ¡ğšğ­ ğ¢ğŸ: Instead of letting generic functions find concrete implementations for data â†’ let data find concrete implementations for functions? From the perspective of decomposing the type Ã— operation table, what if we break this table into columns, letting certain data (corresponding to generic operations, let\u0026rsquo;s call it generic? data) represent a column?\nThis was already presented in SICP 2.1.3 when discussing compound data extraction, and was mentioned in my previous blog post. The focus in SICP 2.1.3 was on operations on compound data itself (extracting fields): to ensure consistency before and after list element access, we provide the list as a procedure that accepts parameters and returns corresponding list elements based on those parameters.\nHere we care about how data behaves in programs - how data interacts with functions and other data. We want data to carry its own interaction methods rather than being static entities that can only be acted upon by other functions. Based on this idea, let\u0026rsquo;s try to write a Boolean that follows this behavioral specification.\nBoolean Carrying Functions First, let\u0026rsquo;s present a similar type Ã— operation two-dimensional table. Since we\u0026rsquo;re doing simple modeling, we\u0026rsquo;ll only consider two operations - AND (logic_and) and OR (logic_or):\nSimilar to generic functions representing rows, we write \u0026ldquo;data\u0026rdquo; that can represent columns. The identifiers for TRUE and FALSE columns are tru and fls respectively. How to make data carry functions? One answer is to make the data itself a function that can accept parameters, using parameters to extract the functions carried by the data:\n(define tru ; (define tru (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) tru_logic_and) ((eq? op \u0026#39;or) tru_logic_or) ) ) ) (define fls ; (define fls (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) fls_logic_and) ((eq? op \u0026#39;or) fls_logic_or) ) ) ) The functions corresponding to lambda - cond (curried logical AND and OR) are implemented as follows:\n(define (tru_logic_and x) (if (eq? x tru) tru fls)) ; 1 AND x (define (tru_logic_or x) tru) ; 1 OR _ = 1 (define (fls_logic_and x) fls) ; 0 AND _ = 0 (define (fls_logic_or x) (if (eq? x tru) tru fls)) ; 0 OR x Checking tru fls in REPL: unsurprisingly both are compound procedures\n1 ]=\u0026gt; tru ;Value: #[compound-procedure 13 tru] 1 ]=\u0026gt; fls ;Value: #[compound-procedure 12 fls] Let\u0026rsquo;s do a simple test:\n1 ]=\u0026gt; ((tru \u0026#39;and) fls) ;Value: #[compound-procedure 12 fls] What did we do here? First, tru is a lambda expression that accepts symbol parameters. (tru 'and) returns tru_logic_and - a curried logical AND (that is, logical AND with TRUE already passed in), then we apply tru_logic_and to fls, and the final return value is the compound procedure fls.\nHere\u0026rsquo;s an illustration:\nFor longer expressions: if we ignore some parentheses, it looks like infix logical expressions\n1 ]=\u0026gt; ((((fls \u0026#39;or) tru) \u0026#39;and) fls) ; ((0 or 1) and 0) ;Value: #[compound-procedure 12 fls] If you prefer prefix calls, we can add a small wrapper:\n(define (logic op x y) ((x op) y)) Testing logic:\n1 ]=\u0026gt; (logic \u0026#39;and tru fls) ;Value: #[compound-procedure 12 fls] 1 ]=\u0026gt; (logic \u0026#39;or (logic \u0026#39;and fls fls) tru) ; (or (and 0 0) 1) ;Value: #[compound-procedure 13 tru] â†’ Message Passing: Another Perspective on Data This style of building Boolean is called Message Passing: data is an entity that receives operation names (messages). For example: tru can receive messages like 'and / 'or and return corresponding curried functions for our subsequent use. From this perspective, the data itself is as important as the methods carried by the data, which is also a manifestation of \u0026ldquo;data as program\u0026rdquo;. You might notice a hint of object-oriented flavor here - objects are essentially \u0026ldquo;state + methods\u0026rdquo;, and here data contains \u0026ldquo;state + functions\u0026rdquo;, though the state here is immutable.\nHaskell\u0026rsquo;s $ $ is an infix function with the following type signature and precedence. Its purpose is to change expression evaluation order, and one objective result is that using $ reduces the number of parentheses in code:\nghci\u0026gt; :i ($) ($) :: (a -\u0026gt; b) -\u0026gt; a -\u0026gt; b -- Defined in \u0026#39;GHC.Base\u0026#39; infixr 0 $ Applying $ (curried) to a value returns a function:\nghci\u0026gt; x = 5 :: Int ghci\u0026gt; :t ($ x) ($ x) :: (Int -\u0026gt; b) -\u0026gt; b One way to understand this is: ($ x) transforms x from static data into data waiting to be acted upon by function Int -\u0026gt; b (which is a function from the type signature). Based on this understanding, we can write code like this:\nghci\u0026gt; map ($ 5) [(* 2), (+ 10), (^ 3)] [10,15,125] Algebraic Data Types in Haskell Here\u0026rsquo;s the classic recursive definition of binary trees using algebraic data types:\ndata Tree a = Empty | Node a (Tree a) (Tree a) Empty and Node are value constructors for Tree a. Value constructors are functions that return values of some type. Empty is a nullary constructor, while Node takes three value parameters: a, Tree a, and Tree a.\nTree a is a type constructor. Type constructors are functions that return specific types. Tree a takes one type parameter a and returns the corresponding concrete Tree type. For example, Tree Int and Tree Char are Tree types with node data types of Int and Char respectively.\nThis shows Haskell\u0026rsquo;s beautiful consistency in language design - there\u0026rsquo;s no special generic syntax, just functions throughout.\n","date":"2024-09-07T23:18:00+08:00","permalink":"http://localhost:1313/p/message-passing-perspective-on-bool-sicp-2.4.3-generic-data-and-functions/","title":"Message Passing Perspective on Bool - SICP Â§ 2.4.3 | Generic | Data and Functions"},{"content":"Code Here: Huffman Tree in Haskell\nHaskell Implementation of Huffman Trees Data Abstraction type Weight = Int data Symbol = A | B | C | D | E | F | G | H deriving Show data HuffmanTree a = Empty | Leaf a Weight | Node (HuffmanTree a) (HuffmanTree a) [a] Weight deriving Show Symbol + Weight â†’ Leaf We encode symbols (Symbol / generic a) based on their frequency/weight (Weight), combining these two pieces of information into a Leaf abstraction, corresponding to SICP\u0026rsquo;s (define (make-leaf symbol weight) (list 'leaf symbol weight)).\nGeneric types and constraints: There are no type constraints on symbols. The weight constraint is that Weight belongs to the Ord typeclass because weights need to be comparable. Here we directly use Int as the weight type instead of making it generic.\nRecursive Definition of HuffmanTree Contains three constructors: Empty, Leaf, and Node:\nEmpty: Empty tree Leaf: Leaf node containing symbol a and weight Weight Node: Branch node containing left and right subtrees (HuffmanTree a), union of subtree symbols [a], and total subtree weight Weight. Building the Huffman Tree Getting Weight Get the weight of Leafï¼ŒNode through pattern matching.\ngetWeight :: HuffmanTree a -\u0026gt; Weight getWeight (Leaf _ w) = w getWeight (Node _ _ _ w) = w For simplicity, we haven't considered the `Empty` tree case. For better safety, we should write `getWeight :: HuffmanTree a -\u003e Maybe Weight`, returning `Nothing` when matching `Empty`.\nList Organization The starting point for building a Huffman tree is an ordered list of leaves. During construction, the [HuffmanTree a] list needs to maintain order. The functions in this section aim to organize an unordered list into an ordered one.\nÂ» adjoinLeaf: Insert a HuffmanTree a into an existing ordered [HuffmanTree a] based on weight (ascending order).\nÂ» initLeafs: Organize an existing unordered leaf list into an ordered leaf list.\nÂ» moveFirstNode: During Huffman Tree construction, the Merge operation combines the two HuffmanTree (Leaf / Node) with smallest weightsâ€”the first two elements in the listâ€”into a new Node. This function helps reposition the newly generated Node after merging.\nadjoinTree :: HuffmanTree a -\u0026gt; [HuffmanTree a] -\u0026gt; [HuffmanTree a] adjoinTree t [] = [t] adjoinTree t (t\u0026#39;:ts) | w \u0026lt; w\u0026#39; = t: t\u0026#39;: ts | otherwise = t\u0026#39;: (adjoinTree t ts) where w = getWeight t w\u0026#39; = getWeight t\u0026#39; initLeafs :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] -- I know pl(leaf) = leaves, btw. ^^ initLeafs [] = [] initLeafs (p:ps) = adjoinLeaf p (initLeafs ps) moveFirstNode :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] moveFirstNode (t:ts) = adjoinLeaf t ts Tree Construction Â» makeNode: Combines two HuffmanTrees into a Node. Â» constructHuffTree: Bottom-up tree construction, building the Huffman Tree using tail recursion.\nRecursive step: Merge the first two elements in the current list into a parent Node using makeNode, move the parent node to get a new ordered list, and recursively process the new list.\nBase case: List contains only one element, which is the root node.\nÂ» initAndConstructHuffTree: Final encapsulation, using Point-less composition to combine leaf list initialization initLeafs and tree construction constructHuffTree.\nmakeNode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; HuffmanTree a makeNode (Leaf s1 w1) (Leaf s2 w2) = Node (Leaf s1 w1) (Leaf s2 w2) [s1, s2] (w1 + w2) makeNode (Leaf s w) (Node l r ss w\u0026#39;) = Node (Leaf s w) (Node l r ss w\u0026#39;) (s:ss) (w + w\u0026#39;) makeNode (Node l r ss w\u0026#39;) (Leaf s w) = Node (Node l r ss w\u0026#39;) (Leaf s w) (ss ++ [s]) (w + w\u0026#39;) makeNode (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) = Node (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) (ss1 ++ ss2) (w1 + w2) constructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = Empty constructHuffTree [t] = t constructHuffTree (x:y:ts) = constructHuffTree $ moveFirstNode $ (makeNode x y): ts initAndConstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a initAndConstructHuffTree = constructHuffTree . initLeafs Huffman Tree Encoding and Decoding Getting Symbol Encoding The process of building a Huffman tree is the encoding process itself. A node\u0026rsquo;s position in the tree represents its encoding. Here we present the encoding in binary form.\nEncoding representation:\ndata Bit = L | R deriving Show type Bits = [Bit] L corresponds to binary 0, R corresponds to binary 1.\nGetting the encoding involves traversing and recording the Huffman tree:\ngetCode\u0026#39; :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [(a, Bits)] getCode\u0026#39; (Node (Leaf s1 _) (Leaf s2 _) _ _) rec = [(s1, rec ++ [L]), (s2, rec ++ [R])] getCode\u0026#39; (Node (Leaf s\u0026#39; _) node _ _) rec = [(s\u0026#39;, rec ++ [L])] ++ getCode\u0026#39; node (rec++[R]) getCode\u0026#39; (Node node (Leaf s\u0026#39; _) _ _) rec = getCode\u0026#39; node (rec++[L]) ++ [(s\u0026#39;, rec ++ [R])] getCode\u0026#39; (Node nodel noder _ _) rec = getCode\u0026#39; nodel (rec++[L]) ++ getCode\u0026#39; noder (rec++[R]) getCode :: HuffmanTree a -\u0026gt; [(a, Bits)] getCode t = getCode\u0026#39; t [] Â» getCode': Traverse the Huffman tree Recursively\nRecursive step: For a node, match left and right subtrees, continue recursive traversal for non-leaf nodes (node), recording branch directions in rec.\nBase case: When matching a Leaf in left/right subtree, it indicates reaching a Symbol. At this point, rec ++ [L] / rec ++ [R] is the encoding for that Symbol.\nPattern matching explanation: Reviewing the Huffman tree construction process, we always merge two nodes into their parent node, so there\u0026rsquo;s no case where a subtree is Empty. Therefore, every branch node\u0026rsquo;s pattern is Node lhs rhs _ _. Also, we use Leaf as the base case without recursing on it, which is why we only pattern match different forms of the Node constructor and put the Leaf recursive base cases first.\nÂ» getCodeï¼šWraps getCode', giving rec an initial value of [], meaning no path record at the Huffman tree\u0026rsquo;s root node.\nDecoding Basic approach: Move through the tree based on Bit, L - move to left subtree, R - move to right subtree. When reaching a Leaf subtree, one character is decoded. Then return to the root node to continue decoding the next character until the Bit list is empty.\n-- decode one symbol decodeOne :: HuffmanTree a -\u0026gt; Bits -\u0026gt; (a, Bits) decodeOne (Node (Leaf s _) _ _ _) (L:bs) = (s, bs) decodeOne (Node _ (Leaf s _) _ _) (R:bs) = (s, bs) decodeOne (Node node _ _ _) (L:bs) = decodeOne node bs decodeOne (Node _ node _ _) (R:bs) = decodeOne node bs -- decode from scratch decode :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode _ [] = [] decode t bs = let (s, remainBits) = decodeOne t bs in s: decode t remainBits Â» decodeOne:\nBase case: When the current Bit\u0026rsquo;s corresponding subtree is a Leaf, one character is decoded. Return that character and the remaining Bits.\nRecursive step: When the current Bit\u0026rsquo;s corresponding subtree is a Node, continue recursive decoding on that Node until reaching the base case.\nÂ» decode:\nBase case: Empty Bit list means decoding is complete.\nRecursive step: For non-empty Bit list, pass the root node and current Bit list to decodeOne for single character decoding. After one character is decoded, continue decoding remaining Bits from the root node until the Bit list is empty.\nÂ» How to return to root node:\nInitially, the function signature I wrote was decode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a], with two HuffmanTree parameters representing the original root node and current node. Implementation was roughly:\ndecode\u0026#39; :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode\u0026#39; originT (Node (Leaf s _) _ _ _) (L:bs) = s: (decode\u0026#39; originT originT bs) --snip-- This didn\u0026rsquo;t feel quite right since the originT parameter never changed during recursion, so I slightly modified the recursive structure to write the above decode and decodeOne. SICP uses closures to remember the initial root node.\nStructure and Destructure of Compound Data SICP: Data, but Functions? Consistency We want to use structured dataâ€”rather than scattered variablesâ€”as program components, thus we have compound data like struct / class. The question then becomes how to extract the fields used to construct compound data. One thing extraction needs to ensure is consistency of fields before and after extraction. This is mainly the compiler\u0026rsquo;s work, but if we want to demonstrate this at the source code level, how can we do it? SICP 2.1.3 (Page 124) does it this way:\n(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \u0026#34;Argument not 0 or 1: CONS\u0026#34; m)))) dispatch) (define (car z) (z 0)) (define (cdr z) (z 1)) Exercise 2.4 (Page 125) has an elegant implementation using lambda:\n(define (cons x y) (lambda (m) (m x y))) (define (car z) (z (lambda (p q) p))) ï¼ˆFor Pure Lambda Calculus implementation of this example, see the last section of this article.ï¼‰\nA key point this chapter of SICP emphasizes is: The boundary between data and procedures isn\u0026rsquo;t so clear-cut. The above two programs demonstrate this precisely: the list constructor returns a procedure that provides an interface to access the elements composing the list, which enables the definition of car / cdr.\nData Combination and Extraction â†’ Program Construction: Abstraction Layer Combination in LISP (LISt Programming) can be simple - data is combined by constructing lists, like (list 1 2 3) / (list 3 4 (list 9 7) 5), you can implement pair, tree, etc. with lists.\nHowever, data within programs can\u0026rsquo;t directly flow between functions in this form, so we have abstraction layers:\nConstructor (make-rat) and selector (denom, numer) represent one level of abstraction from primitive data types to compound data, giving programs (functions above this abstraction layer, like add-rat / sub-rat) a higher perspective to view data. Data is no longer just scattered integers/floats, but rat that can be constructed/extracted/analyzed. Functions above add-rat / sub-rat don\u0026rsquo;t need to care about rat\u0026rsquo;s implementation details, they just need to use operations like add-rat to solve problems. The process of program construction is a process of raising abstraction levels.\nHaskell: Pattern Match In Haskell, how do we handle the issue of data construction and extraction?\nConstruction:\nThe syntax for declaring compound data is:\ndata Point = Point Int Int This defines the Point type with a constructor Point Int Int, which can then be used to construct compound data of type Point, like p = Point 1 2.\nExtraction:\nPattern Match\nA simple example:\ngetX :: Point -\u0026gt; Int getX (Point x _) = x Notably: How you construct the compound data (Point Int Int) is how you match it (Point x _). That isâ€”how you structure is how you destructure.\nOne advantage of this syntax is that you can parse function parameters through Pattern Matching. For example:\nconstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = ... -- empty leaf list â†’ return empty tree constructHuffTree [t] = ... -- only one leaf â†’ return tree with just root node constructHuffTree (x:y:ts) = ... -- two or more leaves â†’ recursively build Huffman tree This demonstrates that: The way function parameters are destructured determines the function\u0026rsquo;s behavior.\nFor example, consider this problem: counting the number of nodes in a binary tree\ndata Tree a = Empty | Node a (Tree a) (Tree a) treeSize :: Tree a -\u0026gt; Int treeSize Empty = 0 treeSize (Node _ left right) = 1 + treeSize left + treeSize right Empty tree constructed with Empty constructor â†’ directly return 0 (base case)\nNon-empty tree constructed with Node constructor â†’ solve recursively (recursive step)\nHow we construct data determines how we process it, and in Haskell, the form of constructing data matches the form of pattern matching on data, so we can do pattern matching in function parameter positions, with each pattern corresponding to a function behavior.\nLambda Calculus - pair abstraction pair abstraction in Pure Lambda Calculus ä¸ŠThe example mentioned in the Consistencysection can be implemented in pure Lambda Calculus:1ï¼š\npair = Î»m Î»n Î»b. b m n pair v w = Î»b. b v w This abstraction provides this perspective: through two applications of pair, we instantiate m and n, determining the elements contained in the pair, leaving b as an interface for subsequent operations on the pair elements. To extract elements from the pair in order, we can define fst and snd:\nfst = Î»a Î»b. a snd = Î»a Î»b. b (pair v w) fst â†’ v // parentheses here can be omitted , according to left associativity convention (pair v w) snd â†’ w If you prefer programming style like fst (pair v w), that\u0026rsquo;s also possible:\ntru = Î»t Î»f. t // Î±-equivalent to `fst` defined in previous code block, we can understand the same abstraction differently fls = Î»t Î»f. f // ... `snd` ... fst = Î»p. p tru snd = Î»p. p fls fst (pair v w) â†’ v snd (pair v w) â†’ w Let\u0026rsquo;s examine this abstraction again: pair = Î»m Î»n Î»b. b m n. In Lambda Calculus, what we commonly call functions are termed abstractions, and this pair abstraction provides an abstraction over the construction and operation of pairs. We first determine the contained elements through outer parameters m and n to build the pair, then use inner parameter b to execute operations on the existing elements. From this perspective, pair naturally possesses the ability to interact with other functions (abstractions) within the Lambda Calculus system, because after instantiating the pair elements, it provides the interaction interface b, waiting for other abstractions to interact with the pair\u0026rsquo;s existing elements through application.\nTypes and Programming Languages - Chapter 5 The Untyped Lambda-Calculus\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-02T01:53:00+08:00","permalink":"http://localhost:1313/p/huffman-trees-in-haskell-structure-and-destructure-of-compound-data/","title":"Huffman Trees in Haskell | Structure and Destructure of Compound Data"},{"content":"Problem Description Problem: Given a positive integer $n$, find all ordered pairs of distinct positive integers $i$ and $j$, where $ 1 \\leq i \\leq j \\leq n $, such that $ i + j $ is prime.\nImplementation in Haskell isDivisible :: Int -\u0026gt; Int -\u0026gt; Bool isDivisible x y | mod x y == 0 = True | otherwise = False isPrime :: Int -\u0026gt; Bool isPrime x | x \u0026lt;= 2 = True | otherwise = not (foldr (||) False (map (isDivisible x) [2..((floor . sqrt . fromIntegral) x)])) genPairs :: Int -\u0026gt; [((Int, Int), Int)] genPairs n = do x \u0026lt;- [1..n] y \u0026lt;- [1..(x-1)] return ((y, x), (x + y)) sumPrimePairs :: Int -\u0026gt; [((Int, Int), Int)] sumPrimePairs = (filter (\\(_, s) -\u0026gt; (isPrime s))) . genPairs About List Monad: Context, Nested lambda and do-notation Context of List Monad : nondeterministic result.\nThe title of this section is Nested Mappings, represented in code with nested lambdas. In Haskell, do notation is syntactic sugar for nested lambdas.\nAnd flatMap defined in this chapter is actually Haskell \u0026gt;\u0026gt;= (bind) in Haskell.\nFor further details, consult Learn You a Haskell for Great Good: A Fistful of Monads - the List Monad\nAnother Example: The List Monad for Permutation An intuitive way to understand this is that nondeterministic results are well-suited for solving permutations.\npermutations :: Eq a =\u0026gt; [a] -\u0026gt; [[a]] permutations [] = [[]] permutations xs = do x \u0026lt;- xs perm \u0026lt;- permutations $ removeByElem x xs return (x: perm) removeByElem :: Eq a =\u0026gt; a -\u0026gt; [a] -\u0026gt; [a] removeByElem x = filter (/= x) ","date":"2024-08-29T00:00:00+08:00","permalink":"http://localhost:1313/p/nested-mapping-examples-implemented-in-haskell-sicp-2.2.3-list-monad/","title":"Nested Mapping Examples Implemented in Haskell - SICP Â§ 2.2.3  | List Monad "},{"content":" Semantics of let Key point: A let scope is evaluated immediately (including both bindings and expressions after bindings, i.e., everything within the outer parentheses of the let), even if the let is nested inside an inner function that hasn\u0026rsquo;t been called yet.\nExample:\n(define (comp x) (if (\u0026gt; 3 x) (display \u0026#34;then-clause\u0026#34;) (display \u0026#34;else-clause\u0026#34;) ) #| (define foo1 (let ((bar1 (/ 2 0))) ; * evaluted immediately (display \u0026#34;should not be printed\u0026#34;) ) ) |# (define foo2 (let ((bar2 (/ 5 2))) ; * evaluted immediately (newline) (display \u0026#34;let in `foo2`, bar2: \u0026#34;) (display bar2) ) ) ) Running examples:\nfoo1: We can see that the let binding is evaluated, otherwise we wouldn\u0026rsquo;t get a division by zero exception.\nprompt\u0026gt; (comp 4) else-clause ;Division by zero signalled by /. ;To continue, call RESTART with an option number: ;snip foo2: We can see that the expressions after the let binding are evaluated, otherwise we wouldn\u0026rsquo;t see the display output.\nprompt\u0026gt; (comp 2) then-clause let in `foo2`, bar2: 5/2 ;Unspecified return value Semantics of if The semantics of if: It evaluates the condition first, then decides whether to evaluate the then-clause or else-clause based on the result.\nA good reference for this is SICP (2nd Edition) Exercise 1.6, where an abstraction is used to define new-if using cond:\n(define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause) ) ) The semantics of function application (applicative order evaluation) requires evaluating arguments first (like then-clause and else-clause here) before applying the function. This is why you can\u0026rsquo;t write recursive expressions in then-clause or else-clause - they would be evaluated regardless of the predicate\u0026rsquo;s value, leading to infinite recursion. if/cond/\u0026hellip; are special forms with different semantics compared to abstractions defined through define. I like the new-if example because it elegantly demonstrates Lisp\u0026rsquo;s metaprogramming features. Following the substitution model, predicate, then-clause, and else-clause can be replaced with any expressions you need, where expressions are enclosed in parentheses - the parentheses mark expression boundaries, and you can put parenthesized expressions in any parameter position (as long as they satisfy the implicit type constraints of the abstraction).\nAn Error Caused by Immediate let Evaluation Consider this prime number checking code:\n(define (prime? x) (if (or (= x 1) (= x 2)) #t test_prime ) (define (divisible? y) (= 0 (remainder x y)) ) (define (iter_biggest_divisor y) (cond ((= y 1) 1) ((divisible? y) y) (else (iter_biggest_divisor (- y 1))) ) ) (define test_prime (let ((biggest_divisor (iter_biggest_divisor (quotient x 2)) )) ; Notice (display biggest_divisor) (if (= biggest_divisor 1) #t #f ) ) ) ) The results when running:\nprompt\u0026gt; (prime? 1) ;The object 0, passed as the second argument to integer-remainder, is not in the correct range. prompt\u0026gt; (prime? 2) 1 ;Value: #t According to programmers\u0026rsquo; expectations, both (prime? 1) and (prime? 2) should directly return #t, rather than the former throwing an error and the latter showing the behavior of (display biggest_divisor). As stated earlier, this occurs because the entire let scope is evaluated immediately.\n","date":"2024-08-29T00:00:00+08:00","permalink":"http://localhost:1313/p/semantics-of-let-in-schemefeat.-semantics-of-if/","title":"Semantics of `let` in Scheme(feat. Semantics of `if`)"},{"content":"Code, easierâœ¨\nYour VSCode Assistant Ctrl + Shift + P\nIf you need to do something in VSCode, you can press Ctrl + Shift + P to search for it. For example, if you want to change settings but manually opening settings.json is too tedious, you can:\nAfter pressing Enter, settings.json will be right in front of you. If you need to frequently perform this action, you can bind a shortcut for it in Keyboard Shortcuts (open with Ctrl-k Ctrl-s):\nLayout Hide Activity Bar and Status Bar Iâ€™ve configured shortcuts in the image below to toggle the Activity Bar and Status Bar. Hiding these can make the interface cleaner.\nPlace Terminal Tab and Code Tab Together Press Ctrl+Shift+P â†’ Search for Terminal: Move Terminal to Editor Area in the command palette to move the terminal into the Editor Area. Other similar actions include Move Terminal to Panel, Create New Terminal in Editor Area, etc. Of course, you can bind a shortcut for frequently used actions.\nAn applicable scenario is: if you are learning a programming language that has a REPL (like Haskell, Lisp, Python\u0026hellip;), you can split the Editor Area into two parts, one for the code and one for the Terminal REPL. If needed, you can edit files and import them in the REPL (like :l foo.hs in GHCi). This way, itâ€™s more convenient, and you can switch focus between the code tab and terminal tab with Ctrl+1 / Ctrl+2.\nAnother similar solution: Open the Secondary Side Bar with Ctrl+Shift+B, then drag the terminal to the Secondary Side Bar.\nEditor Area Rainbow Guidelines In Settings (GUI), type @id:editor.bracketPairColorization.enabled @id:editor.guides.bracketPairs and select the options you need. editor.bracketPairColorization.enabled is enabled by default, while editor.guides.bracketPairs is off by default. You can set it to true or active to enable. The true effect colors all parentheses, and the active effect only colors the outer parentheses closest to the cursor. I think active is enough, and hereâ€™s the result:\nUse Ctrl+Shift+\\ to jump between the closest paired parentheses to the cursor, useful for checking nested expressions, corresponding to % in Vim Normal Mode. If your focus is in the Terminal, you can use Ctrl+Shift+\\ to jump between terminal tabs.\nShortcuts Tip\nHover your cursor over a button in the GUI, and if the button has a corresponding shortcut, a tooltip will show the shortcut key (many programs follow this design philosophy). So, if you find yourself frequently clicking a button, stop and check its hotkey.\nCtrl-bï¼štoggle side bar.\nHere\u0026rsquo;s a related story: someone submitted an issue requesting a toggleExplorerVisibility configuration in VSCode. A user replied \u0026ldquo;Ctrl-B to toggle side bar\u0026rdquo; and closed the issue. Why do I know this? Because I also thought my need was toggleExplorerVisibility, and the lesson learned is: knowing the correct names of components is important ğŸ˜£.\nAlt-â†/â†’ï¼šGo back to the previous cursor position / move forward to the next cursor position.\nThis is particularly useful when navigating through function calls, in combination with F12.\nCtrl-[ / Ctrl-]ï¼šIndent the current line left/right.\nSimilar to Vimâ€™s \u0026gt; / \u0026lt; in Visual Mode. I donâ€™t find Vimâ€™s version very smooth because you can only perform the operation once after selecting, and to make further indentations, you need to select again.\nAlt-â†‘/â†“ï¼šMove the current line up/down.\nShift-Alt-f: Format code, provided a formatter is configured.\nCtrl-(Shift-)Enter: Create a new line below (or above) the current cursor position, with the cursor jumping to the start of the new line.\nCorresponds to o(O) in Vim Normal Mode.\nFrom the 2025-02-19 update: After the VSCode update, Copilot Suggestions (GitHub Copilot: Open Completion Panel) now occupy Ctrl-Enter, which can be changed in Keyboard Shortcuts. Ctrl-k Ctrl-w\nClose all tabs in the Editor Area.\nConflict Avoidance\nDirect conflicts are shown when performing keybinding actions, but in cases like this, where the leading key = other shortcut keys, no conflict is shown. However, in this case, Copy is essentially broken because Ctrl-c will act as the leading key, and after pressing it, VSCode will wait for the chord key. You can observe this in the status bar.\nExtensions Bluloco Light Theme (Author: Umut TopuzoÄŸlu)\nA very beautiful theme.\nRemove empty lines (Author: Alexander)\nDeletes all empty lines in the selected area. You can call it via Ctrl + Shift + P or bind a shortcut for it.\nMiscellaneous Some small settings in User Settings (JSON) include:\nChange the background color of hover widgets (e.g., function descriptions provided by the Language Server);\nChange the zoom level;\nRainbow bracket guide line.\n{ \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editorHoverWidget.background\u0026#34;: \u0026#34;#edeeee\u0026#34;, // Set the hover widget background color }, \u0026#34;window.zoomLevel\u0026#34;: 1, \u0026#34;editor.guides.bracketPairs\u0026#34;: \u0026#34;active\u0026#34; } Some Useful Windows Shortcuts ï¼ˆğŸªŸ epresents the Windows key.ï¼‰\nğŸªŸ\nPress the Windows key and type text to search for apps, settings, files, etc. After finding the match, press Enter to open it.\nğŸªŸ + Arrow keys\nWin + â†‘ï¼šMaximize the current window Win + â†/â†’ï¼šSnap the window to the left/right\nWin + â†“ï¼šExit fullscreen / Minimize\nğŸªŸ + v\nShow clipboard history (the maximum capacity is unknown, but records are lost when shutting down). You can also select and enter emojis, symbols, and emoticons here.\nAlt-Tab\nSwitch between windows on the current desktop.\nCtrl-(Shift-)Tab\nSwitch between tabs in the current application (browser, VSCode). Different applications may sort the tabs differentlyâ€”some by access order (VSCode), others by creation order (Edge).\nAlt-F4\nClose the current window.\nCtrl-w\nClose the current tab in Edge.\n","date":"2024-08-26T00:00:00+08:00","permalink":"http://localhost:1313/p/my-common-vscode-shortcuts/","title":"My Common VSCode Shortcuts"},{"content":" Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. \u0026ndash; Antoine de Saint-ExupÃ©ry\nInstalling MIT-Scheme via Package Manager MacOS:\nbrew install mit-scheme Ubuntu:\nsudo apt-get update sudo apt-get install mit-scheme Basic REPL Usage ï¼ˆREPL: Read-Evaluate-Print Loopï¼‰\nStart the REPL with a single command mit-scheme.\nLoad Scheme code into the REPL:\n1 ] =\u0026gt; (load \u0026#34;path/to/file.scm\u0026#34;) (The .scm extension can be omitted.)\nView the manual:\nUse the man mit-scheme command in the terminal to view the brief mit-scheme CLI manual.\nWhen in REPL, press Ctrl-C and then type H to see the interrupt manual:\nCtrl-C: Waits for the next keyboard input to decide the interrupt behavior.\nCtrl-G: Returns to the top-level REPL.\nCtrl-Z: Suspends the current mit-scheme process.\nPress Ctrl-C and then type ? to see the manual for the next key input (option) and how it corresponds to REPL behavior (clear screen, suspend, exit, ignore interrupts, etc.).\nIf the REPL doesn\u0026rsquo;t respond:\nCheck if parentheses are properly matched; ( ( ) ( ( ) )\nAfter interrupting with Ctrl-C, the prompt (1 ] =\u0026gt; / 2 error\u0026gt;) may not reappear, which results in the \u0026ldquo;frozen\u0026rdquo; REPL.\nWorried about deep recursion? If the recursion depth exceeds the limit, the REPL will show Recursion depth limit exceeded. Aborting!. (According to mit-scheme manual, which you can get by man mit-scheme, stack size can be specified with CLI parameters, meaning MIT-Scheme has limited stack resources.)\nScHeMe Scheme is case-insensitive.\nSo (LoAd \u0026quot;path/to/file.scm\u0026quot;)/(DEFINE x 1)/(define x 1)/(defiNE x 1), etc. won\u0026rsquo;t cause errors.\nHistory variable (procedure): Reuse procedures returned after evaluating expressions in the REPL:\n1 ]=\u0026gt; (average-dump square) ;Value: #[compound-procedure 12] ; Can be reused in subsequent expressions, similar to GDB\u0026#39;s history variable `$1` 1 ]=\u0026gt; (#[compound-procedure 12] 10) ; Not very convenient to use directly, but it works ;Value: 55 1 ]=\u0026gt; (define newfunc #[compound-procedure 12]) ; Can be bound to a new identifier for reuse ;Value: newfunc 1 ]=\u0026gt; (newfunc 10) ;Value: 55 Afterword This Scheme REPL is quite basic. It doesnâ€™t support history backtracking or cursor movement, however, since I don\u0026rsquo;t need it for anything too complex, it\u0026rsquo;s good enough for me.\n","date":"2024-08-24T00:00:00+08:00","permalink":"http://localhost:1313/p/mit-scheme-basic-usage/","title":"mit-scheme Basic Usage"},{"content":"â€ƒHow to debug a Rust program? $ gdb excutable Simple example:\nViewing a variable\u0026rsquo;s address:\nFormatted output of p s:\n$17 = alloc::string::String { vec: alloc::vec::Vec\u0026lt;u8, alloc::alloc::Global\u0026gt; { buf: alloc::raw_vec::RawVec\u0026lt;u8, alloc::alloc::Global\u0026gt; { ptr: core::ptr::unique::Unique\u0026lt;u8\u0026gt; { pointer: core::ptr::non_null::NonNull\u0026lt;u8\u0026gt; { pointer: 0x5555555abb80 }, _marker: core::marker::PhantomData\u0026lt;u8\u0026gt; }, cap: alloc::raw_vec::Cap (16), alloc: alloc::alloc::Global }, len: 16 } } Key points: p \u0026lt;variable\u0026gt; p \u0026amp;\u0026lt;variable\u0026gt; ptype \u0026lt;variable\u0026gt;\nOwnership issues with dbg! when outputting debug information Incorrect:\ndbg!(var); // move dbg!(var); // invalid reference dbg! will take ownership of var (Move), so var can\u0026rsquo;t be used again.\nCorrect:\ndbg!(\u0026amp;var); // or let new_var = dbg!(var); dbg!(\u0026amp;new_var); // if you want to Explore with gdb For things you want to explore, use gdb, for example: [How is enum represented at a low level?] -\u0026gt; Write a simple program, compile it to an executable, then use gdb, using print var print \u0026amp;var x/x \u0026lt;addr\u0026gt; to explore.\nå…³äºå¯¹ vector çš„å¼•ç”¨ An excerpt from ch08-01\n/* CANNOT COMPILE */ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\nA question: How to make a Vector appear to store multiple types of data? Answer: Have the Vector store enums. An enum can have variants of different types, so in a sense, the Vector can store multiple types of data.\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Text(String::from(\u0026#34;word\u0026#34;)), CellType::Float(3.14), ]; let v1 = \u0026amp;v[0]; } enum CellType { Int(i32), Float(f64), Text(String), } Debugging enums with gdb and using history variables in gdb (and other REPLs) Source code:\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Float(3.14), ]; let v1: \u0026amp;CellType = \u0026amp;v[0]; let v2: \u0026amp;CellType = \u0026amp;v[1]; println!(\u0026#34;END\u0026#34;); } enum CellType { Int(i32), Float(f64), } Debugging session:\np v1ï¼šPrints the value of v1: \u0026amp;CellType, which is a pointer value, meaning the address where the associated data is stored on the heap. Note that the data corresponding to v1, v2 each occupies 16 bytes. x/4x $1ï¼šExamines the 16 bytes pointed to by v1. p *v1ï¼šDereferences v1 to view the actual value stored at that memory location. Analysis of how enum is actually stored in memory:\nThe first byte is likely the variant identifier, with the mapping: 0-Int 1-Float\nInt: Associated data is stored in the second byte, 0x0000000c represents Int(12) from the code\nFloat: Associated data is stored in the third and fourth bytes 0x40091eb8_51eb851f which is the IEEE 754 64-bit representation of 3.14\nRemaining question: Why are the associated data stored in different positions for these two variants, and what is 0x00005555 in Float?\nRediscovering gdb features (history variable)ï¼š\nThe $x in p var output is a history variable for later reuse. Similar REPL behaviors include bash\u0026rsquo;s echo $(ls) and mit-scheme, which also provides referenceable history variables for returned procedures (though those variables are long and contain special characters like #[], so to truly reuse them you still need to copy the identifier and bind it to another identifier for reuse).\nRUST_BACKTRACE and command line tips $ RUST_BACKTRACE=1 cargo run $ A=12 B=23 echo \u0026#34;$A $B\u0026#34; You can write temporary environment variables at the leftmost part of the command.\nFancy technique: color escape sequences in Rust\u0026rsquo;s println println!(\u0026#34;\\x1b[34mMESSAGE\\x1b[0m\u0026#34;); Using \\x1b[34m for escape sequences\nWhat is \\x1b?\n\\x indicates hexadecimal, 1b is the ASCII hex code for ESC.\nDifference between unwrap and expect in Result\u0026lt;T, E\u0026gt;: Looking at library function implementations can give you a better understanding of pre-packaged functions. For example, with Result\u0026lt;T, E\u0026gt;\u0026rsquo;s unwrap and expect, looking at the source code reveals that the difference is in the msg parameter of unwrap_failed (and unwrap_failed is just a wrapper around panic!):\nimpl\u0026lt;T, E\u0026gt; Result\u0026lt;Result\u0026lt;T, E\u0026gt;, E\u0026gt; { ... pub fn expect(self, msg: \u0026amp;str) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(msg, \u0026amp;e), } } pub fn unwrap(self) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(\u0026#34;called `Result::unwrap()` on an `Err` value\u0026#34;, \u0026amp;e), } } ... } fn unwrap_failed(msg: \u0026amp;str, error: \u0026amp;dyn fmt::Debug) -\u0026gt; ! { panic!(\u0026#34;{msg}: {error:?}\u0026#34;) } ","date":"2024-08-05T00:00:00Z","permalink":"http://localhost:1313/p/explore-rust-basic-revisiting-gdb/","title":"Explore Rust (Basic) \u0026 Revisiting gdb"},{"content":"Simple Introduction Based on materials I prepared for Computer System course\nI\u0026rsquo;ve seen many people claim that Bash syntax is uncomfortable, but I had already gotten used to Bash syntax before encountering such opinions - \u0026ldquo;I met you before the rumors did\u0026rdquo;?? ğŸ˜¶â€ğŸŒ«ï¸\nThe topic of the related discussion session was: how does the compiler handle switch-case statements in C? Specifically, under what distribution of case statements (continuous/discontinuous, size of intervals) will the compiler generate a jump table? Since we needed to explore different case scenarios, we first needed to generate C source files with different case patterns. This seemed rather mechanical, so we considered using an automated script. Our expectation for this script was that generator -b 10 -s 2 -d dest_dir -f file_name would produce a file with 10 branches (-b), branch intervals (-s) of 2, in the directory (-d) dest_dir, with the filename (-f) file_name.c. With a single file generator in hand, we could then write another generator to call this one and create a batch of C source files with varying numbers of branches and intervals.\nCommand Line Argument Capture The most obvious benefit of command line interfaces is that you can control a command\u0026rsquo;s specific behavior through options. For example, cat displays file contents, while cat -n adds line numbers. To capture command line arguments, we use getopts:\nwhile getopts \u0026#34;:b:d:f:s:\u0026#34; opt; do case $opt in b) branch=$OPTARG # number of switch branches ;; :) echo \u0026#34;Option -$OPTARG requires an argument.\u0026#34; ;; ?) echo \u0026#34;Invalid option: -$OPTARG\u0026#34; ;; esac done The Simplest Metaprogramming The metaprogramming here refers to using code to generate code. This can be complex, but here we take the simplest approach - code is just a text file, right? So we can simply echo code text and append it to the target file:\ntargetpath=\u0026#34;./${dir}/${filename}\u0026#34; echo -e \u0026#34;/* Created by switch_generator */\\n\u0026#34;\\ \u0026gt; ${targetpath} # sleep 0.1 echo -e \\ \u0026#34;int main(){\\n\\n\\ int i = 0, j = 0;\\n\\ switch (i) {\\ \u0026#34; \u0026gt;\u0026gt; ${targetpath}; # sleep 0.1 for (( i = 1;i \u0026lt;= $branch; i++ )); do record=$i i=$(( i*seperate )) echo -e \\ \u0026#34; case $i:\\n\\ j += $i;\\n\\ break;\\n\\ \u0026#34; \u0026gt;\u0026gt; ${targetpath}; # sleep 0.1 i=$record done echo -e \\ \u0026#34; default:\\n\\ j += 1000;\\n\\ break;\\n\\ }\\n\\ return 0;\\n\\ }\u0026#34; \u0026gt;\u0026gt; ${targetpath} Source File Pipeline Raising the level of abstraction, we use another script to call the above script, implementing batch production of source files. The core code is:\nfor (( branch_num = 1; branch_num \u0026lt;= $size; branch_num++ ));do filename=\u0026#34;${compiler}_branch_${branch_num}\u0026#34; bash ./switch_generator.sh -b $branch_num -d $dir -f ${filename}.c # $compiler -S ./${dir}/${filename}.c -o ./${dir}/${filename}.s # ... done By batch compiling these files to assembly, then using grep to check for and report jump tables, our task was complete. The principles are similar, so I won\u0026rsquo;t go into further detail. If you\u0026rsquo;re curious about the answers to the discussion questions:\nCompilers use jump tables when the number of consecutive branches is â‰¥ 4 (clang) / 5 (gcc); otherwise, they use subl, je conditional jump instructions; When branch constant intervals are â‰¥ 12 (clang) / 10 (gcc), compilers no longer use jump tables, but directly use subl, je for conditional testing and jumping; When branch variables form two consecutive segments with a large gap between them, such as 1,2,\u0026hellip;,6, 101,102,\u0026hellip;106, gcc generates two jump tables (this conclusion comes from my teammate LYT) ","date":"2024-04-03T00:00:00Z","permalink":"http://localhost:1313/p/simple-bash-cli-programs-simple-metaprogramming/","title":"Simple Bash CLI Programs \u0026 Simple Metaprogramming"},{"content":"Simple Introduction Although the date here is March 20, 2024, I\u0026rsquo;m actually writing this blog on February 18, 2025, based on materials from my Computer System discussion course. If you want to know a file\u0026rsquo;s type, you might use the file command. But how does file determine file types, or more specifically, how do files in the system tell file (or any program wanting to know its type) what type they are? Where do files store their type information?\nManuals Are Always Your Friend The first second third method to understand a command is usually through whatis / man / tldr.\nman whatis will tell you that whatis actually comes from man:\nEach manual page has a short description available within it. whatis searches the manual page names and displays the manual page descriptions of any name matched.\nman file will tell that file checks file types like thisï¼š\nfile tests each argument in an attempt to classify it. There are three sets of tests, performed in this order: filesystem tests, magic tests, and language tests. The first test that succeeds causes the file type to be printed.\nfilesystem tests System call stat, using its return value to determine the file type; stat can identify empty files / file types defined in \u0026lt;sys/stat.h\u0026gt;. magic tests Check if the file header contains specific magic bytes. For example, if the first five bytes of the file correspond to the ASCII characters \u0026ldquo;%PDF-\u0026rdquo;, it\u0026rsquo;s identified as a PDF file. If no magic bytes exist, it\u0026rsquo;s determined to be a text file, and file will continue to determine its encoding as ASCII/UTF-8/\u0026hellip; language tests Determine the file\u0026rsquo;s language through keywords, such as inferring a text file is a C source file from main, struct, printf. A closer way to observe this command\u0026rsquo;s execution process is strace file foo.bar; you can also redirect the output to a file and use Vim to view it for keyword searching / readability, like strace file foo.bar \u0026amp;\u0026gt; strace.out; vim strace.out.\nFooling file? Exploiting the magic test Exploiting the language test Simple Conclusion To answer the initial questionâ€”file determines file types through filesystem tests, magic tests, and language tests. Files \u0026ldquo;express\u0026rdquo; their types through magic bytes in the file header, text encoding, or programming language keywords.\n","date":"2024-03-20T20:50:00+08:00","permalink":"http://localhost:1313/p/a-quick-look-at-the-file-command/","title":"A Quick Look at the `file` Command"}]