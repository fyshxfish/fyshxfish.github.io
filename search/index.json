[{"content":" å¼•è¨€ æ ‡é¢˜çš„è¿™ä¸ªé—®é¢˜ï¼Œå…¶å®æ˜¯ä¸€ä¸ªä¸å¤ªæ­£ç¡®çš„é—®é¢˜ï¼Œå› ä¸ºå¯¹äºè¯­è¨€è€Œè¨€ï¼Œè®¾è®¡å…ˆäºå®ç°â€”â€”å…ˆè®¾è®¡è¯­è¨€çš„è¯­æ³•å’Œè¯­ä¹‰ï¼Œç„¶åå†™ç¼–è¯‘å™¨å»æ£€æŸ¥ä¸€ä¸ªç¨‹åºè¯­æ³•æ˜¯å¦æ­£ç¡®ï¼Œç„¶åæ ¹æ®è®¾å®šå¥½çš„è¯­ä¹‰å°†å®ƒè½¬å†™æˆç›®æ ‡æœºå™¨ä»£ç ã€‚ä»â€œä¸Šä¸‹æ–‡â€è¿™ä¸ªè§†è§’å»æ€è€ƒï¼Œå¸¸è§æƒ…å†µä¸‹ï¼Œè¯­æ³•æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„ï¼Œè€Œè¯­ä¹‰æ­£æ˜¯ç”¨æ¥å¤„ç†ä¸Šä¸‹æ–‡ç›¸å…³çš„é—®é¢˜çš„ï¼Œx = 1; print(x); å’Œ x = 2; print(x);ï¼ŒåŒæ ·æ˜¯ print(x)ï¼Œå®ƒçš„ä¸Šæ–‡æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‰€ä»¥å®ƒå¯¼è‡´çš„ç»“æœä¹Ÿä¸ä¸€æ ·.\nä¸¾ä¾‹ 1 æ¯”å¦‚ï¼š\nfoo = 3 foo = 4 å‡è®¾å¯¹è¿™ä¸ªç¨‹åºåªåšè¯­æ³•åˆ†æï¼Œé‚£ä¹ˆå®ƒç¬¦åˆ Python è¯­æ³•ï¼Œä¹Ÿç¬¦åˆ Haskell è¯­æ³•ï¼Œä½†æ˜¯å¯¹å®ƒåšè¯­ä¹‰åˆ†æï¼Œä½œä¸ºä¸€ä¸ª Python ç¨‹åºï¼Œå®ƒçš„æ„æ€æ˜¯ï¼Œâ€œå…ˆå°† 3 èµ‹å€¼ç»™ fooï¼Œç„¶åå°† 4 èµ‹å€¼ç»™ fooâ€ï¼›ä½œä¸ºä¸€ä¸ª Haskell ç¨‹åºï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªåˆæ ¼çš„ Haskell ç¨‹åºï¼Œå› ä¸º Haskell è¯­ä¹‰ä¸å…è®¸åšé‡å¤çš„ç»‘å®šï¼Œæ‰€ä»¥æ ¸å¿ƒåŸå› æ˜¯ï¼ŒPython çš„ = çš„è¯­ä¹‰æ˜¯èµ‹å€¼ï¼ˆassignï¼‰ï¼Œå†…å­˜è¦†å†™ï¼ŒHaskell çš„ = çš„è¯­ä¹‰æ˜¯ç»‘å®šï¼ˆname bindingï¼‰ï¼Œä¸ºäº†ä¿è¯æ— å‰¯ä½œç”¨ã€æ‰§è¡Œé¡ºåºæ— å…³ç­‰ç‰¹æ€§ï¼Œåªå…è®¸å•æ¬¡ç»‘å®š.\nä¸¾ä¾‹2 - polyglot ä¸‹é¢è¿™ä¸ªç¨‹åºæ”¹å†™è‡ª polyglot(computing) wikipedia\n#define a /* echo -e \u0026#34;\\033[34mHello, World! from echo\\033[0m\u0026#34;;// \u0026amp;\u0026gt; /dev/null; x=5; if (($x)) // 2\u0026gt; /dev/null; then return 0; // 2\u0026gt; /dev/null; fi #define e ?\u0026gt; #define b */ #include \u0026lt;stdio.h\u0026gt; #define main() int main(void) #define printf printf( #define true ) #define function function main() { printf \u0026#34;\\033[31mHello, World! from main\\033[0m\\n\u0026#34;true/* 2\u0026gt; /dev/null | grep -v true*/; return 0; } #define c /* main #*/ å®ƒæ—¢ç¬¦åˆ C è¯­æ³•ï¼Œåˆç¬¦åˆ Bash è¯­æ³•ï¼Œç„¶è€Œç¼–è¯‘/è§£é‡Šæ‰§è¡Œå®ƒå¾—åˆ°çš„ç»“æœä¸åŒï¼Œå› ä¸ºä¸¤ä¸ªç¨‹åºçš„è¯­ä¹‰ä¸åŒï¼ˆå½“ç„¶ C å’Œ Bash çš„è¯­æ³•ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ï¼Œpolyglot ç¼–å†™çš„æ ¸å¿ƒå°±æ˜¯åˆ©ç”¨å„è¯­è¨€ä¹‹é—´çš„æ³¨é‡Š/å®/\u0026hellip;ä½¿ç”¨çš„ç¬¦å·ä¸åŒï¼Œç¬¦å·ï¼ˆå¹¿ä¹‰ï¼‰çš„ä½¿ç”¨å’Œå¸ƒå±€æ­£æ˜¯è¯­æ³•ä¾§å…³å¿ƒçš„äº‹æƒ…ï¼‰ï¼š\n","date":"2025-02-17T16:32:00+08:00","permalink":"http://fyshxfish.github.io/p/context-syntax-/-semantic-analysis/","title":"Context \u0026 Syntax / Semantic Analysis"},{"content":"Preface Inspiration came from a lecture by Yanyan Jiangï¼š[ç®—æ³•ç«èµ›å…¥é—¨] ä¸ºä»€ä¹ˆè¦é€¼å¤§å®¶ç”¨ NOILinuxï¼Ÿï¼Œæœ‰å‚è€ƒï¼Œä½†ä¸å®Œå…¨ä¸€æ ·.\nMastering this skill will allow you toâ€”display \u0026ldquo;slides\u0026rdquo; in the terminal. Its practicality is limited, but itâ€™s fun to play with Â·^v^Â·.\nDemo Implementation Overall Framework Directory .sh files are bash scripts for displaying a single slide, .md files are the Markdown content to be rendered, and .png files are the images to be displayed.\nLauncher First, print the cover (essentially outputting a page of rendered text in the terminal), then use read to take input and control slide behaviors such as page flipping, image display, exiting, etc.\n0_flow.shï¼š\n#!/bin/bash bash ./1_banner.sh ## print the cover pc=1\t# page counter while true do read -p \u0026#34;:\u0026#34; choice ## take input and control slide behaviors if [ \u0026#34;$choice\u0026#34; == \u0026#34;p\u0026#34; ]; then # previous page ((pc--)) bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then # display an image xdg-open ./load_init.png elif [[ $choice =~ ^[1-7]$ ]]; then # go to the specific page pc=$choice bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;E\u0026#34; ]; then # exit the script break else # default: next page ((pc++)) bash ./${pc}* fi done Single Page Display Displaying a single page essentially means showing a page of text. The basic steps are:\nClear the previous page\u0026rsquo;s content using clear; Calculate the total number of lines of the rendered text; To center the content vertically, calculate the padding for the top and bottom; Print the top padding, render and print the content text, then print the bottom padding. For example: (2_question.sh)\nclear length=`python3 renderer.py question.md | wc -l` total=`tput lines` sus=$((($total-$length)/2)) for ((i=1; i\u0026lt;=$sus; i++)) do echo done python3 renderer.py question.md for ((i=1; i\u0026lt;$sus; i++)) do echo done Image Display and External Program Calls Use read to take input. When the input is a specific character, use xdg-open to open a specific image. Close it with the ESC key after displaying.\nread -p \u0026#34;:\u0026#34; choice if [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then xdg-open ./picture.png fi Similarly, replacing xdg-open ... with other commands can play audio/video or execute various programs.\nText Rendering ASCII Art for Cover Pages Use figlet to display the theme word and lolcat to color it. Besides the font styles that come with figlet, you can find and download more font styles from figlet-fonts. The \u0026ldquo;Boot\u0026rdquo; shown above corresponds to the command figlet \u0026quot; Boot\u0026quot; -f roman | lolcat -S 30. (Another optional command-line tool is toilet.)\nESC Escape Sequences The printf command can output fancier text in the terminal using \\033 escape sequences. It can achieve simple effects like color, bold, italics, etc., and multiple effects can be combined. For example, the last line in the image corresponds to printf \u0026quot;\\033[2;34;01;21;09myour text\\033[0m\\n\u0026quot;. (This also applies to output in other programming languages. 033 is the octal ASCII code for ESC. The specific colors depend on the terminal\u0026rsquo;s color scheme.)\nMarkdown Rendering glow: glow is a command-line tool, used as glow foo.md. rich: rich is a Python library that can render Markdown. Other Interesting Command-Line Tools asciiquarium\nASCII Art aquarium, very beautiful. You can find the ASCII fish in my avatar here, above the third seaweed from the left in the image below:\noneko\nSummon a little cat, VERY cute:\ncowsay\ndialog\nInteractive TUI dialog boxes, which are also very suitable for single-page slide presentations, for example:\n#!/bin/bash choice=$(dialog --clear --title \u0026#34;Menu\u0026#34; --menu \u0026#34;Make Your Choice\u0026#34; 10 40 3 \\ 1 \u0026#34;Show Greeting\u0026#34; 2 \u0026#34;Enter Something\u0026#34; 3 \u0026#34;Show Figure\u0026#34; 2\u0026gt;\u0026amp;1 \u0026gt;/dev/tty) case $choice in 3) xdg-open ./figure_1.png ;; # SNIP # esac ","date":"2025-02-07T22:52:00+08:00","permalink":"http://fyshxfish.github.io/p/slides-but-in-terminal/","title":"Slides, But in Terminal"},{"content":"Following exercise is from functional and is available on Steam for 29 CNY.\nBasic anything å†™å‡ºä»»æ„ä¸€ä¸ªç¬¦åˆ Lambda Calculus è¯­æ³• (1. variable 2. abstraction 3. application) çš„ term å³å¯.\nidentity x: x two arguments x:y: y x squaring f:x: f (f x) indirection f:x:y: f y x Boolean å®šä¹‰ï¼š\nTRUE = t:f: t FALSE = t:f: f IF p:t:f: p t f Simple LC æ²¡æœ‰ç±»å‹ç³»ç»Ÿï¼Œæ‰€ä»¥ç¼–ç¨‹è€…éœ€è¦è‡ªå·±ç¡®ä¿ p ä¸€å®šèƒ½æ±‚å€¼åˆ° TRUE / FALSEï¼Œç„¶å p t f è¿›ä¸€æ­¥æ±‚å€¼åˆ° t/ fï¼Œå¦‚æœ p ä¸èƒ½è¢«æ±‚å€¼åˆ° TRUE / FALSEï¼Œé‚£ä¹ˆ p t f ä¼šè¢«ä¿ç•™ä¸‹æ¥æˆ–è€…äº§ç”Ÿé¢„æœŸå¤–çš„æ±‚å€¼è¡Œä¸º.\nä½ å¯ä»¥è½»æ¾æ³¨æ„åˆ°çš„ä¸€ç‚¹æ˜¯ï¼šIF P A B â‰¡ P A Bï¼Œä½ å®Œå…¨å¯ä»¥åœ¨æ‰€æœ‰ä½¿ç”¨ IF çš„åœºåˆçœç•¥æ‰ IFï¼Œè¿™ä¸æ”¹å˜è¯­ä¹‰ï¼ŒåŒæ—¶å¯ä»¥å‡å°‘ä¸€æ¬¡ reductionï¼Œä¸è¿‡ä¸ºäº†ä¿è¯å¯è¯»æ€§ï¼Œè¿˜æ˜¯æœ‰ç†ç”±åœ¨æœ‰ç‚¹å¤æ‚çš„ç¨‹åºé‡Œä¿ç•™ IF.\nNOT b: b FALSE TRUE è¿™ä¸ªçœ‹ç€æœ‰ç‚¹éšéšçº¦çº¦çš„å·§å¦™. å¯ä»¥ç›´ç™½åœ°é€šè¿‡ b: IF b FALSE TRUE â†’ b FALSE TRUE å¾—åˆ°ï¼Œæˆ–è€…åˆ©ç”¨ TRUE / FALSE çš„æ„ä¹‰â€”â€”é€‰ç¬¬ä¸€ä¸ª / ç¬¬äºŒä¸ªâ€”â€”ç›´æ¥å¾—åˆ°.\nAND p:q: p q p å¦‚æœ p = TRUEï¼Œé‚£ä¹ˆ AND p q â‰¡ qï¼›å¦‚æœ p = FALSEï¼Œé‚£ä¹ˆ AND p q â‰¡ FALSE â‰¡ p.\nOR p:q: p p q å¦‚æœ p = TRUEï¼Œé‚£ä¹ˆ OR p q â‰¡ p â‰¡ TRUEï¼›å¦‚æœ p = FALSEï¼Œé‚£ä¹ˆ OR p q â‰¡ q.\nXOR p:q: p (NOT q) q ç±»ä¼¼ AND, ORï¼Œå¯ä»¥ç”»ä¸ªçœŸå€¼è¡¨æ•´ç†æ€ç»ª.\nPair and List PAIR x:y:f: f x y PAIR A B â†’ (x:y:f: f x y) A B â†’ (f: f A B) æ˜¯ä¸€ä¸ªè¿™æ ·çš„æŠ½è±¡ï¼šæœ‰åºåœ°å†…æ¶µ A, Bï¼Œç­‰å¾…ä¸€ä¸ªå‡½æ•° f ä½œç”¨äºå†…æ¶µçš„ A, Bï¼Œæ¯”å¦‚å½“ A, B æ˜¯ Booleanï¼Œé‚£ä¹ˆï¼Œf å¯ä»¥æ˜¯ AND / OR / \u0026hellip;ï¼ˆå½“ç„¶è¯­æ³•å¹¶ä¸çº¦æŸ f,A,B çš„å½¢çŠ¶ï¼Œå¦‚æœä½ æƒ³å†™ PAIR TRUE 0 PAIR è§£é‡Šå™¨ä¸ä¼šæ‹¦ä½ ï¼‰\nFST p: p TRUE å½“ p = PAIR A B æ—¶, p TRUE â†’ (PAIR A B) TRUE â†’ (f: f A B) TRUE â†’ TRUE A B â†’ Aï¼Œæ³¨æ„ p æ˜¯ä¸€ä¸ªå¯ä»¥æ¥æ”¶ä¸€ä¸ªå‚æ•° f çš„å‡½æ•°ï¼Œè¿™é‡Œæˆ‘ä»¬è®©å®ƒæ¥æ”¶ TRUE å‡½æ•°æ¥é€‰å–ç¬¬ä¸€ä¸ªå…ƒç´ . åœ¨ LC é‡Œï¼ŒTRUE / FALSE æ›´æ°å½“çš„è§£é‡Šæ˜¯é€‰å–å…¶åè·Ÿéšçš„ç¬¬ä¸€ / äºŒä¸ªé¡¹ï¼Œè€Œä¸æ˜¯è¡¨è¾¾æŸä¸ªå‘½é¢˜çš„çœŸ / å‡ï¼Œè¿™æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºæˆ‘ä»¬å†™å…¶ä»–é«˜çº§è¯­è¨€ç¨‹åºçš„æ—¶å€™ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ª Boolean å€¼ X ï¼ŒX æœ€ç»ˆçš„æ•ˆç”¨å¾€å¾€è¿˜æ˜¯å‘æŒ¥åœ¨ then-clause / else-clause çš„é€‰æ‹©ä¸Š.\nSND p: p FALSE ç±»ä¼¼ FST.\nsimple list å–å‡ºåˆ—è¡¨çš„ç¬¬ 3 é¡¹ (1-indexed)ï¼š\nl: FST ( SND ( SND l ) ) åˆ—è¡¨æ˜¯ä¸€ç§ç®€å•çš„é€’å½’ç»“æ„ï¼Œé€’å½’åŸºæ˜¯ç©ºåˆ—è¡¨ï¼Œè¿™é‡Œç”¨ FALSE è¡¨ç¤ºï¼Œé€’å½’æ­¥æ˜¯å‘æŸä¸ªåˆ—è¡¨æ·»åŠ å…ƒç´ ï¼Œè¿™é‡Œç”¨ PAIR å®ç°ï¼Œe.g. [] â†¦ FALSE, 1 â†¦ (PAIR 1 FALSE), [1,3] â†¦ (PAIR 1 (PAIR 3 FALSE))ï¼Œæ³¨æ„ [1,3]çš„ä¾‹å­ï¼Œå¦‚æœä»å‘åˆ—è¡¨æ·»åŠ å…ƒç´ çš„è§†è§’çœ‹ï¼Œè¡¨å¤´æ˜¯æœ€æ¥è¿‘ FALSE çš„é¡¹ï¼Œè¶Šæ¥è¿‘ FALSE çš„å…ƒç´ ç´¢å¼•è¶Šå°ï¼Œå› ä¸ºå®ƒæ¯”è¾ƒæ—©åœ°è¢«æ·»åŠ è¿›æ¥ï¼Œåœ¨è¿™ç§è§£é‡Šä¸‹ï¼Œ[1,3] â†¦ (PAIR 3 (PAIR 1 FALSE))ï¼Œç„¶è€Œæ¸¸æˆé‡Œä¸é‡‡å–è¿™ä¸ªè§£é‡Šï¼Œè€Œæ˜¯å’Œæˆ‘ä»¬ç†Ÿæ‚‰çš„ [a,b,..] ä¿æŒè§†è§‰ä¸Šçš„å¯¹é½ï¼Œå°†æœ€æ™šè¢«æ·»åŠ çš„é¡¹â€”â€”æœ€å·¦çš„é¡¹â€”â€”ä½œä¸ºè¡¨å¤´ï¼Œåœ¨åç»­æ¶‰åŠå‡é™åºçš„é—®é¢˜çš„æ—¶å€™è®°å¾—ç•™æ„è¿™ä¸€ç‚¹.\nANY å¯¹ä¸€ä¸ªå« 3 ä¸ª Boolean çš„åˆ—è¡¨ï¼Œè‹¥ä»»ä¸€é¡¹ä¸º TRUEï¼Œè¿”å› TRUEï¼Œå¦åˆ™è¿”å› FALSEï¼š\n(l: IF (OR (FST (SND (SND l))) (OR (FST l) (FST (SND l)) ) ) TRUE FALSE ) ç›´ç™½åœ°æŒ‰é€»è¾‘å†™å³å¯. è¿™é‡Œçš„åˆ—è¡¨æ˜¯å®šé•¿çš„ï¼Œæ¯”è¾ƒæ–¹ä¾¿ï¼Œéå®šé•¿åˆ—è¡¨å°±éœ€è¦é€’å½’ï¼Œè§å.\nPUSH (m:l: PAIR m l) ç”¨ PUSH å‘åˆ—è¡¨ l æ·»åŠ æ–°é¡¹ mï¼Œæ ¹æ® $\\eta$-reductionï¼ŒPUSH â‰¡ PAIRï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥å†™ PAIR ä¹Ÿè¶³å¤Ÿäº†.\nPOP SND å¼¹å‡ºæœ€å¤–å±‚çš„é¡¹.\nEMPTY l: l (t:x:y: FALSE) TRUE é¦–å…ˆ EMPTY è¦æ¥æ”¶ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥å®ƒçš„åŸºæœ¬å½¢çŠ¶æ˜¯ EMPTY = l: ...ï¼Œè€ƒè™‘ l' = FALSE çš„æƒ…å½¢ï¼ŒEMPTY l' ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ TRUEï¼Œæ ¹æ® FALSE çš„é€‰æ‹©èƒ½åŠ›ï¼Œæˆ‘ä»¬ä½¿ EMPTY = l: l ğ• TRUEï¼›è€ƒè™‘ l* = PAIR a (PAIR b (...)) = (f: f a (PAIR b (...))) â‰ˆ (f: f a _tail)ï¼ŒæŠŠ l* è§†ä½œæ¥æ”¶ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼ŒEMPTY l* = (f: f a _tail) ğ• TRUE â†’ ğ• a _tail TRUE ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ FALSE, é‚£ä¹ˆ ğ• çš„å·¥ä½œå°±æ˜¯æ¥æ”¶åé¢çš„ 3 é¡¹ï¼Œç„¶åè¿”å› FALSEï¼Œæ‰€ä»¥ ğ• = (t:x:y: FALSE)ï¼Œç»¼åˆä»¥ä¸Šå¾—åˆ°æœ€ç»ˆçš„è§£ EMPTY = l: l (t:x:y: FALSE) TRUE\nRecursion create recursion - Y combinator åŠ¨æœºï¼šLC ä¸­çš„é€’å½’ å°è¯•ç€åœ¨ LC ä¸­å®šä¹‰é€’å½’çš„é˜¶ä¹˜å‡½æ•°ï¼š\nf = a: IF (EQ a 1) 1 (a * f (a - 1)) ä¸Šè¿°çš„å®šä¹‰æ˜¯ä¸ç¬¦åˆ LC çš„è¯­æ³•çš„ï¼Œå› ä¸º LC çš„å‡½æ•°éƒ½æ˜¯åŒ¿åå‡½æ•°ï¼Œä¸æ”¯æŒé€šè¿‡åç§°æ¥è°ƒç”¨å‡½æ•°ï¼ˆå¦‚ä¸Šé¢çš„ fï¼‰ï¼Œè€Œé€’å½’å‡½æ•°ä¸å¯é¿å…çš„éœ€è¦è‡ªæŒ‡ï¼Œå¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ\nå°†å‡½æ•° $F$ åº”ç”¨äºå‚æ•° $A$ï¼Œå¯ä»¥è¿™æ ·è¡¨è¾¾ $F A$ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨é«˜é˜¶å‡½æ•°è¿™æ ·è¡¨è¾¾ï¼š$(\\lambda fa.\\ f\\ a) F A$ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ·»åŠ ä¸€äº›é€»è¾‘ï¼Œæ¯”å¦‚è¡¨è¾¾\u0026quot;å‚æ•°ä¸º $a$ å’Œ $p$ï¼Œå‡½æ•°ä¸º $f$ï¼Œè‹¥ $p\\ a$ ä¸ºçœŸï¼Œé‚£ä¹ˆè¿”å› $f\\ a$ï¼Œå¦åˆ™ç›´æ¥è¿”å› $a$ æœ¬èº«\u0026quot;ï¼š$(\\lambda fap.\\ IF\\ (p\\ a)\\ (f\\ a)\\ a)$. æ ¹æ®è¿™ä¸ªæƒ³æ³•ï¼Œå‡è®¾æˆ‘ä»¬çš„ç›®æ ‡é˜¶ä¹˜å‡½æ•°ä¸º Fï¼Œé‚£ä¹ˆ F æ»¡è¶³è¿™ä¸ªç­‰å¼ï¼Œå°† (f:a: ..) è®°ä½œ F'ï¼š\nF = (f:a: IF (EQ a 1) 1 (a * f (a - 1)) ) F â‰¡ F\u0026#39; F çœ‹ç­‰å¼çš„å³ä¾§ï¼ŒF' çš„æ¶µä¹‰æ˜¯ï¼Œæ¥æ”¶å‡½æ•° f å’Œå‚æ•° aï¼Œè‹¥ EQ a 1 é‚£ä¹ˆè¿”å› 1ï¼Œå¦åˆ™è¿”å›è¿”å› a * f (a - 1). å‘ F' ä¼ é€’é€’å½’å‡½æ•° Fï¼Œç”±æ­¤å¾—åˆ°çš„å‡½æ•° F' F çš„è¡Œä¸ºå’Œæˆ‘ä»¬ç›®æ ‡çš„é˜¶ä¹˜å‡½æ•° F æ˜¯ä¸€è‡´çš„ï¼Œä»è¯­ä¹‰ä¸Šæ¥è®²ï¼Œå·¦å³ä¾§ç›¸ç­‰.\nç›®å‰æˆ‘ä»¬æœ‰çš„ç­‰å¼æ˜¯ F = F' F â‘ ï¼Œå…¶ä¸­ F' æ˜¯å·²çŸ¥çš„ closed termï¼Œå› ä¸º F æ¶‰åŠè‡ªå¼•ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ normal formï¼Œäºæ˜¯è€ƒè™‘æ˜¯å¦å­˜åœ¨æŸä¸ª Y s.t. Y F' = Fâ‘¡ï¼Œå°† â‘¡ ä»£å…¥ â‘ ï¼ŒY F' = F' (Y F')ï¼Œæ¥ä¸‹æ¥çš„ç›®æ ‡å°±æ˜¯è§£å‡º Y çš„ normal formï¼Œå¾—åˆ° Y ä¹‹åï¼Œç›®æ ‡é€’å½’å‡½æ•° F = Y F' ä¹Ÿéšä¹‹å¾—åˆ°äº†.\nä¸ºä»€ä¹ˆè¦è¯•å›¾å°† F åˆ†è§£æˆ Y F'ï¼Ÿ\nä¸ä¸¥è°¨åœ°è¯´ï¼Œä»æ–¹ç¨‹çš„è§’åº¦çœ‹ F = F' F åªæœ‰ä¸€ä¸ªæœªçŸ¥é‡ Fï¼Œå°† F è½¬åŒ–æˆ Y F'ï¼ŒåŒæ ·åªå«ä¸€ä¸ªæœªçŸ¥é‡ Yï¼Œè€Œ F'å·²çŸ¥ä¸”å’Œæˆ‘ä»¬çš„æ±‚è§£ç›®æ ‡ï¼ˆé€’å½’å‡½æ•° Fï¼‰ç´§å¯†ç›¸å…³.\nY combinator è®¾è®¡ Y æ˜¯ä¸€ä¸ªè¿™æ ·çš„ termï¼šY F = F (Y F) = F (F (Y F)) = ....\nä¸ºè®¾è®¡æ»¡è¶³ä»¥ä¸Šç›®æ ‡çš„ Y ï¼Œåšå‡ºå¦‚ä¸‹çš„åˆæ­¥åˆ†æï¼š\næ ¹æ® inversion lemmaï¼ŒY çš„å½¢çŠ¶æ¯«æ— ç–‘é—®æ˜¯ (f: ...).\nY çš„è‡ªæŒ‡ï¼Ÿâ€”â€” æˆ‘ä»¬éœ€è¦é‡å¤ Yï¼Œæˆ–è€…è¯´æ„å»ºå³ä¾§çš„ Y.\nFunction / Abstraction is All You Need â€”â€” å› ä¸º LC æ²¡æœ‰å­˜å‚¨ï¼Œæ‰€ä»¥ Y F = F (Y F)ï¼Œç­‰å·å·¦å³çš„ Y å¹¶ä¸æ˜¯åŒä¸€ä¸ª Yï¼Œä¸æ˜¯å€¼æ‹·è´æˆ–è€…åœ°å€æ‹·è´ï¼ˆå› ä¸º LC ä¸æä¾›å­˜å‚¨çš„æ¦‚å¿µï¼Œæ— å¤„å®‰æ”¾å€¼æˆ–è€…åœ°å€ï¼Œè¿™é‡Œåªæœ‰å‡½æ•°ï¼‰ï¼Œå³ä¾§çš„ Y éœ€è¦é€šè¿‡æ„å»ºå¾—åˆ°ï¼Œä¸å·¦ä¾§çš„ Y åœ¨ alpha-conversion çš„æ„ä¹‰ä¸‹ç›¸ç­‰.\nå¦‚ä½•é‡å¤ Fï¼Ÿè¿™å¾ˆç®€å•ï¼ŒY = (f: ...) æ¥æ”¶å‚æ•° Fï¼Œåœ¨ Y çš„å‡½æ•°ä½“å†…ï¼Œæƒ³æ€ä¹ˆé‡å¤å°±æ€ä¹ˆé‡å¤.\nè®¾è®¡ä¸€ä¸ª abstraction M åšæ„å»ºï¼ŒM å°†æ¥æ”¶ä¸€äº›å¿…è¦çš„å‚æ•°ï¼Œåœ¨å‡½æ•°ä½“å†…ç»„ç»‡è¿™äº›å‚æ•°ï¼Œå½¢æˆå’Œ Y ä¸€æ ·çš„ç»“æ„.\nY = f: M f ... ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ M = f: f (Wai f)ï¼šæ¯«æ— ç–‘é—®ï¼ŒM éœ€è¦æ‹¿åˆ° Y çš„å‚æ•° fï¼ŒM å†…éƒ¨éœ€è¦å»ºç«‹èµ·å’Œ Y F ä¸€è‡´çš„ç»“æ„ï¼› Y = f: M f M ... ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ M = f:m: f (m f m)ï¼šå› ä¸ºæˆ‘ä»¬å¸Œæœ› M å¯ä»¥å»ºç«‹èµ·å’Œ Y F ä¸€è‡´çš„ç»“æ„ï¼Œè€Œ Y åŒ…å«äº† Mï¼Œé‚£ä¹ˆ M ä¹Ÿéœ€è¦åŒ…å« Mï¼Œæ‰€ä»¥é€šè¿‡å‚æ•° m å°† M åŸå°ä¸åŠ¨åœ°ä¼ è¿› M. M çš„å‡½æ•°ä½“ä¸­ï¼Œæœ€å·¦çš„ f å®ç° f çš„å†æ¬¡åº”ç”¨ï¼Œ(m f m) æ„å»ºäº†å’Œå·¦ä¾§çš„ Y F alpha ç­‰ä»·çš„ç»“æ„. Y = f: M f M, å…¶ä¸­ M = f:m: f (m f m)ï¼Œå¯ä»¥éªŒè¯è¿™å·²ç»æ˜¯ä¸€ä¸ªå¯è¡Œçš„ Y ç»„åˆå­äº†ï¼ŒY F = M F M = (f:m: f (m f m)) F M = F (M F M) = F (M F M) = F (Y F). Y ç»„åˆå­å¯ä»¥æœ‰æ— æ•°ç§ï¼Œæ¯”å¦‚ (a) Y = f: M M f, M = m:f: f (m m f) è¿™å’Œä¸Šæ–‡æ‰€å‘ˆç°çš„ Y ç»„åˆå­æ˜¯å‡ ä¹ä¸€æ ·çš„ï¼Œåªæ˜¯æ”¹å˜äº† M, f å‚æ•°çš„é¡ºåºï¼Œåˆ©ç”¨ä¸€æ­¥ $\\eta$ è§„çº¦ï¼Œä½¿ä¹‹æ›´ç®€æ´â€”â€”Y = M M, M = ...ï¼Œè¿™ä¹Ÿæ˜¯å›¾çµç»™å‡ºçš„ Y ç»„åˆå­ï¼›(b) Y = f: E (E f) E f, E = r:s:f: f (s r s f) ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œçœ‹èµ·æ¥ä¸å¤Ÿç®€æ´ï¼Œä½†æ˜¯ç†å¿µå’Œä¸Šé¢çš„é™ˆè¿°æ˜¯ä¸€è‡´çš„ï¼Œç”¨ E æ¥æ”¶éœ€è¦çŸ¥é“çš„å‚æ•°ï¼Œç„¶ååšæ„å»ºï¼Œä½ ä¼šå‘ç° E æ¥æ”¶äº† E å’Œ fï¼Œåˆå¤šä½™åœ°æ¥æ”¶äº† (E f)ï¼ŒæŠŠ (E f) æ‹¿æ‰å¹¶åšç›¸åº”çš„ä¿®æ”¹ï¼Œå°±å¾—åˆ°äº†æœ¬æ®µè½é™ˆè¿°çš„ç¬¬ä¸€ç§ Y ç»„åˆå­ï¼›(c) æœ€ç®€æ´çš„ Y = f: (x: f (x x)) (x: f (x x))ï¼Œå®ƒå’Œå‰é¢æåˆ°çš„ Y ç»„åˆå­çš„åŒºåˆ«åœ¨äºï¼Œå‰é¢çš„ Y ç»„åˆå­æ˜¯ç”¨ç»„åˆå­ç»„æˆçš„ï¼Œæ¯”å¦‚ 4 ä¸­çš„ Y = f: M f M ä¸­çš„ M æœ¬èº«ä¹Ÿæ˜¯ç»„åˆå­ï¼Œè€Œè¿™ä¸ª Y ç»„åˆå­ä¸åŒ…å«ç»„åˆå­å­é¡¹.\nå°ç»ƒä¹ ï¼šå¦‚ä½•å®ç°æ»¡è¶³åŒè¾¹å»¶å±•çš„ D F D = D (D F D) D = ... çš„ç»„åˆå­ Dï¼Ÿ\nä¸€ç§è§£æ³•å¯ä»¥æ˜¯ D = f:d: d (d f d) dï¼Œé“ç†å’Œä¹‹å‰æ‰€è¯´çš„æ˜¯ä¸€è‡´çš„.\nY ä¸€å®šè¦æ˜¯ç»„åˆå­å—ï¼Œå¯ä»¥å¼•å…¥è‡ªç”±å˜é‡å—ï¼Ÿ\nå‡è®¾ Y åŒ…å«è‡ªç”±å˜é‡ zï¼Œå› ä¸º Y åŒ…å« zï¼Œé‚£ä¹ˆç”¨ M æ„å»º Y æ—¶ä¹Ÿè¦è€ƒè™‘åˆ° zï¼š\nclosed Mï¼šå°† z ä½œä¸ºå‚æ•°ä¼ ç»™ Mï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ä¹‹å‰çš„ Y ç»„åˆå­çš„åŸºç¡€ä¸Šä¿®æ”¹ï¼Œå¾—åˆ° Y = f: M f c M, M = f:c:m: f (m f c m)ï¼Œå¯ä»¥éªŒè¯ï¼Œè¿™å¯ä»¥è¾¾æˆ Y F = F (Y F) = ... çš„ç›®æ ‡ï¼ŒåŒæ—¶ä½ å¯ä»¥æ³¨æ„åˆ°å¼•å…¥ z å¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œåªæ˜¯å¹³æ·»è´Ÿæ‹…; open Mï¼šå³ M æœ¬èº«åŒ…å«äº†è‡ªç”± zï¼Œå¯ä»¥å°è¯• Y = f: K f K z, K = f:k: f (k f k z)è¿™ä¸ªä¾‹å­ï¼Œä½ ä¼šå‘ç°è¿™æ˜¯è¡Œä¸é€šçš„ï¼š Y F = F (K F K z) z = F (Y F) z = F (F (Y F) z) zï¼Œè¿™ä¸ª Y çš„æ•ˆæœæ˜¯åœ¨å·¦ä¾§ä¸æ–­åš F çš„åº”ç”¨ï¼Œå³ä¾§ä¸æ–­äº§ç”Ÿæ–°çš„ z. æ ¹æ®ä»¥ä¸Šçš„è®¨è®ºï¼Œè¿™ä¸ªé—®é¢˜çš„ç­”æ¡ˆæ˜¯ï¼šå¯ä»¥ï¼Œä½†æ²¡å¿…è¦. ä¸”ä»ç›´è§‰ä¸Šå»ç†è§£ï¼Œéšæ„åœ°å¼•å…¥è‡ªç”±å˜é‡ä¹Ÿæ²¡æœ‰æ„ä¹‰. æˆ‘æå‡ºè¿™ä¸ªé—®é¢˜çš„åŸå› æ˜¯ï¼Œæœ‰ä¸€ç¬é—´çªç„¶è§‰å¾— Y ç»„åˆå­å¤ªç†Ÿæ‚‰äº†ï¼Œç¬¬ä¸€æ¬¡åœ¨ LC é‡Œè§åˆ° Y è¿™ä¸ªå¤§å†™å­—æ¯åé¢æ¥çš„å°±æ˜¯\u0026quot;ç»„åˆå­\u0026quot;ä¸‰ä¸ªå­—ï¼Œæ‰€ä»¥å¼€å§‹è€ƒè™‘ï¼Œå¦‚æœä¸æ˜¯ç»„åˆå­æ˜¯å¦å¯ä»¥.\nY combinator ä½¿ç”¨ æ‰¿æ¥åŠ¨æœºéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç”¨ F' = f:a: ... è¡¨è¾¾é€’å½’å‡½æ•° f ä¸å…¶å‚æ•° a ä¹‹é—´çš„åº”ç”¨é€»è¾‘ï¼Œå°†ç›®æ ‡é€’å½’å‡½æ•°ä¸º Fï¼Œé‚£ä¹ˆ F = F' Fï¼Œå› ä¸ºè‡ªå¼•çš„ä¸åˆæ³•ï¼Œè€ƒè™‘ç”¨ Y F' æ¥è¡¨ç¤º Fï¼Œåœ¨ä¸Šä¸€èŠ‚ä¸­æˆ‘ä»¬æ¶‰åŠå‡ºäº†å¯è¡Œçš„ Yï¼Œäºæ˜¯ F = Y F' å°±æ˜¯æˆ‘ä»¬å¸Œæœ›å¾—åˆ°çš„ç›®æ ‡å‡½æ•°.\næƒ³æ˜ç™½ Y ç»„åˆå­çš„ä½¿ç”¨ï¼Œæœ¬ section çš„å…³å¡éƒ½å¾ˆç®€å•äº†ï¼Œå”¯ä¸€å€¼å¾—æç¤ºçš„æ˜¯ 1. ä½¿ç”¨ä»¥å¾€å…³å¡å·²å®šä¹‰è¿‡çš„å‡½æ•°æ—¶ï¼Œæ³¨æ„å‡½æ•°çš„å‚æ•°é¡ºåºï¼Œä¾‹å¦‚ FILTER å…ˆä¼ åˆ—è¡¨ï¼Œå†ä¼ è¿‡æ»¤ä¾èµ–çš„å‡½æ•°ï¼Œå› ä¸º Simple LC è¯­æ³•å±‚é¢çš„çº¦æŸå¾ˆå°‘ï¼Œæ‰€ä»¥ç¼–ç¨‹è€…è‡ªå·±è¦å¤šå½“å¿ƒä¸€äº› 2. æœ‰è‹¥å¹²ä¸ªå…³å¡å¯èƒ½æ¶‰åŠåˆ—è¡¨åè½¬ï¼Œæ‰€ä»¥ REVERSE å¯ä»¥å…ˆå†™ï¼Œç„¶åç›´æ¥æ‹¿æ¥ç”¨ 3. æ³¨æ„æ‹¬å·é…å¯¹ï¼Œå¯ä»¥ç°åœ¨å…ˆè¿›çš„ç¼–è¾‘å™¨é‡Œå…ˆå†™ï¼Œç¡®ä¿ä¸çŠ¯ä½çº§é”™è¯¯ï¼Œå†å¤åˆ¶è¿›æ¥è¯„æµ‹. ä¸‹é¢ç»™å‡ºçš„ç­”æ¡ˆä»…ä¾›å‚è€ƒï¼Œå¯ä»¥è¿‡è¯„æµ‹ï¼Œä½†æœªå¿…æœ€ç®€.\nstrip prefix å»é™¤ä¸å®šé•¿åˆ—è¡¨å‰ç¼€çš„ FALSEï¼š\nY (f:l: IF (FST l) l (f (SND l)) ) ACC Y (a:l:f:i: IF (EMPTY l) i (a (SND l) f (f i (FST l))) ) ALL l: ACC l AND TRUE REVERSE Y (i:c:l: IF (EMPTY l) c (i (PAIR (FST l) c) (SND l)) ) FALSE MAP Y (m:c:l:f: IF (EMPTY l) (REVERSE c) (m (PAIR (f (FST l)) c) (SND l) f) ) FALSE NONE (l: ALL (MAP l NOT)) FILTER Y (m:c:l:f: IF (EMPTY l) (REVERSE c) ( IF (f (FST l)) (m (PAIR (FST l) c) (SND l) f) (m c (SND l) f) ) ) FALSE ZIP Y (z:c:m:n: IF (EMPTY m) (REVERSE c) (z (PAIR (PAIR (FST m) (FST n)) c) (SND m) (SND n)) ) FALSE EQBLIST (m:n: ALL (MAP (MAP (ZIP m n) (p: XOR (FST p) (SND p)) ) NOT ) ) CONCAT (m:n: (Y (g:c:r: IF (EMPTY r) c (g (PAIR (FST r) c) (SND r)) ) ) n (REVERSE m) ) Numerals Church Numeral ç”¨å‡½æ•°è¡¨è¾¾è‡ªç„¶æ•°ï¼Œä¸¤ä¸ªå…³é”®ç‚¹æ˜¯ 1. åŸº (0 := f:x: x) 2. åç»§ (SUC)ï¼Œåœ¨åŸºä¹‹ä¸Šä¸æ–­åšåç»§ï¼Œå°±å¯ä»¥å¾—åˆ°æ‰€æœ‰ Church Numeral.\nSUC ç»™å®š Church Numeral nï¼Œn æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå‚æ•°ä¸º f, xï¼Œn f x è¡¨ç¤ºå°† f åº”ç”¨äº x $n$ æ¬¡ï¼ŒSUC n æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„èƒ½åŠ›æ˜¯æ¥æ”¶ f, xï¼Œå°† f åº”ç”¨äº x $(n+1)$ æ¬¡.\n(n: (f:x: f (n f x) ) ) ZERO åˆ©ç”¨é€»è¾‘è¿ç®—æ¥åˆ¤æ–­ç»™å®šçš„ n æ˜¯ä¸æ˜¯ f:x: x.\n(n: n (x: AND FALSE x) TRUE) PRE ä¸€ä¸ªåŸºæœ¬çš„è§‚å¯Ÿæ˜¯ n = n SUC 0ï¼Œè¿™é‡Œçš„ç­‰å·è¡¨ç¤ºå†…æ¶µç­‰ä»·ï¼ˆintensional equalityï¼‰ï¼Œé‚£ä¹ˆåœ¨ PAIR 0 0 ä¸Šåš $n$ æ¬¡è¿­ä»£ï¼Œä¸€è½®è¿­ä»£çš„å·¥ä½œæ˜¯ï¼š1. å³ä¾§æ•°å¯¹é½å·¦ä¾§æ•° 2. å·¦ä¾§æ•°åšä¸€æ¬¡åç»§ï¼Œé‚£ä¹ˆå³ä¾§æ•°å§‹ç»ˆæ…¢å·¦ä¾§æ•°ä¸€æ­¥ï¼Œå³ $n$ è½®è¿­ä»£åï¼Œå·¦ä¾§æ•°æ˜¯ nï¼Œå³ä¾§æ•°æ˜¯å·¦ä¾§æ•°çš„åç»§.\n(n: SND (n (p: PAIR (SUC (FST p)) (FST p)) (PAIR 0 0) ) ) ADD ç»™å®š x, yï¼Œç›®æ ‡æ˜¯ç»™å‡º x+yï¼Œx+y çš„å«ä¹‰æ˜¯ï¼šé¢„å¤‡æ¥æ”¶ f, zï¼Œå°† f åº”ç”¨äº z $(x+y)$ æ¬¡. å…ˆå°† f åº”ç”¨äº z $x$ æ¬¡ï¼Œå¾—åˆ°ç»“æœ x f zï¼Œå†å°† f åº”ç”¨äº (x f z) $y$ æ¬¡.\n(x:y: (f:z: y f (x f z)) ) SUB (x:y: (f:z: (y PRE x) f z)) MUL (x:y:f:z: y (x f) z ) DIV (Y (d:c:x:y: IF (ZERO x) 0 ( IF (ZERO (y PRE x)) (SUC c) (d (SUC c) (y PRE x) y) ) ) ) 0 EQ (x:y: AND (ZERO (x PRE y)) (ZERO (y PRE x)) ) MIN (x:y: IF (ZERO (x PRE y)) y x ) MAX (x:y: IF (ZERO (x PRE y)) x y ) More Numerals is odd (n: (n NOT FALSE)) é¡ºä¾¿æƒ³èµ·äº†åˆ¤æ–­å¥‡å¶çš„é€’å½’æ–¹æ³•ï¼šï¼ˆçœ‹èµ·æ¥è¿˜æŒºæœ‰æ„æ€çš„ï¼Œæ¯”ç†Ÿæ‚‰çš„ mod 2 æ–°é²œä¸€äº›ï¼‰\nisEven :: Int -\u0026gt; Bool isEven 0 = True isEven x = isOdd (x-1) isOdd :: Int -\u0026gt; Bool isOdd 0 = False isOdd x = isEven (x-1) increasing list å°¾é€’å½’ï¼š\n(Y (f:c:n: IF (ZERO n) (PAIR 0 c) (f (PAIR n c) (PRE n)) ) ) FALSE éå°¾é€’å½’ï¼š\n(n: REVERSE ( (Y (f:x: IF (ZERO x) (PAIR 0 FALSE) (PAIR x (f (PRE x)))) ) n ) ) decomposition å°†ç»™å®šæ•°åˆ†è§£æˆ 2 çš„å¹‚ä¹‹å’Œï¼š\n(Y (f:c:k:n: IF (ZERO n) c (IF (AND (EQ n (MIN k n)) (NOT (EQ k n))) (f c (DIV k 2) n) (f (PAIR k c) (DIV k 2) (SUB n k) ) ) ) ) FALSE 8 * primes å’Œ sort éƒ½éœ€è¦å¤§æŠŠæ—¶é—´è¿è¡Œï¼ˆæœ¬æœºæµ‹è¯•ä¸¤å…³å„è‡ªè€—æ—¶éƒ½åœ¨ 30min å·¦å³ï¼‰\nprimes Y (f:l:p:n: IF (EQ n (FST p)) (PAIR n l) (IF (EQ (FST p) (MAX n (FST p))) (f l (SND p) n) ( IF ( (Y (f:n:p: IF (EQ n (MIN n p) ) (IF (EQ n p) TRUE FALSE ) (f (SUB n p) p) ) ) n (FST p) ) (f (PAIR (FST p) l) p (DIV n (FST p))) (f l (SND p) n) ) ) ) FALSE (PAIR 47 (PAIR 43 (PAIR 41 (PAIR 37 (PAIR 31 (PAIR 29 (PAIR 23 (PAIR 19 (PAIR 17 (PAIR 13 (PAIR 11 (PAIR 7 (PAIR 3 (PAIR 2 FALSE)))))))))))))) sort é€‰æ‹©æ’åºï¼š\nY (f:c:l: IF (EMPTY l) c ( (m: (f (PAIR m c) (FILTER l (x: NOT (EQ x m)) )) ) (ACC l MAX 0) ) ) FALSE trees NODE l:v:r:f: f l v r LEF t: t (l:v:r: l) RIG t: t (l:v:r: r) VAL t: t (l:v:r: v) BEMPTY ç±»ä¼¼äºåˆ—è¡¨åˆ¤ç©ºï¼ŒNODE l v r = f: f l v rï¼Œç©ºæ ‘ç”¨ FALSE := a:b: bï¼Œå°†ä¸€ä¸ªæ ‘ t ä½œä¸ºå‡½æ•°ä½¿ç”¨ï¼Œè‹¥æ˜¯ç©ºæ ‘ï¼Œt A B = FALSE A B = B ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ TRUEï¼Œè‹¥ä¸æ˜¯ç©ºæ ‘ t A B = (f: f l v r) A B = A l v r B ~á´‡xá´˜á´‡á´„á´›á´‡á´…â†’ FALSEï¼Œæ ¹æ®ä»¥ä¸Šï¼ŒB = TRUE, A = l:v:r:x FALSEï¼Œæ‰€ä»¥ï¼š\n(t: t (l:v:r:x: FALSE) TRUE ) FIND åˆ¤æ–­æ ‘ t ä¸­æ˜¯å¦å­˜åœ¨å€¼ä¸º v çš„ç»“ç‚¹ï¼š\nY (f:t:v: IF (BEMPTY t) FALSE (IF (EQ (VAL t) v) TRUE (OR (f (LEF t) v) (f (RIG t) v)) ) ) BSIZE è®¡ç®—æ ‘çš„è§„æ¨¡ï¼š\nY (f:t: IF (BEMPTY t) 0 (SUC (ADD (f (LEF t)) (f (RIG t)))) ) BUILD äºŒå‰æœç´¢æ ‘çš„æ„é€ ï¼š\nY (f:c:l: IF (EMPTY l) c ( f ( ( Y (f:v:t: IF (BEMPTY t) (NODE FALSE v FALSE) ( IF (EQ v (MIN v (VAL t))) (NODE (f v (LEF t)) (VAL t) (RIG t)) (NODE (LEF t) (VAL t) (f v (RIG t))) ) ) ) (FST l) c) (SND l) ) ) FALSE [ æ¸¸æˆé‡Œçš„ PREORDER å’Œ INORDER ä¸¤ä¸ªå‡½æ•°ä¼¼ä¹åäº†ï¼Ÿ ]\nPREORDER äºŒå‰æ ‘çš„ä¸­åºéå†ï¼š\nY (f:t: IF (BEMPTY t) FALSE (CONCAT (f (LEF t)) (PUSH (VAL t) (f (RIG t)) ) ) ) INORDER äºŒå‰æ ‘çš„å‰åºéå†ï¼š\nY (f:t: IF (BEMPTY t) FALSE (PUSH (VAL t) (CONCAT (f (LEF t)) (f (RIG t)) ) ) ) SPLIT æ ‘ t ä»¥ v ä¸ºç•Œè¿›è¡Œåˆ†å‰²ï¼š\nY (f:t:v: IF (BEMPTY t) (PAIR FALSE FALSE) ( IF (EQ v (MAX v (VAL t))) ( (p: PAIR (NODE (LEF t) (VAL t) (FST p)) (SND p)) (f (RIG t) v) ) ( (p: (PAIR (FST p) (NODE (SND p) (VAL t) (RIG t) ))) (f (LEF t) v) ) ) ) KTH å¯¹ç»™å®šçš„äºŒå‰æœç´¢æ ‘ï¼Œç»™å‡ºå…¶ä¸­ç¬¬ k å¤§çš„å…ƒç´ ï¼Œå–å‡ºæ ‘çš„ä¸­åºéå†åˆ—è¡¨ä¸­çš„ç¬¬ k é¡¹å³å¯ï¼š\n(t:k: Y (f:c:l: IF (EQ c 0) (FST l) (f (PRE c) (SND l) ) ) k (PREORDER t) ) inverse 6 å¯¹ç»™å®šçš„äºŒå‰æœç´¢æ ‘ tï¼Œæ‰¾å‡º [1..6] ä¸­çš„è‹¥å¹²ä¸ªç¼ºå¸­è€…ï¼Œå‡åºæ’åˆ—ï¼š\nt: IF (BEMPTY t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ( Y (f:c:m:n: IF (EMPTY n) (REVERSE c) ( IF (EQ (FST m) (FST n)) (f c (SND m) (SND n)) (f (PAIR (FST n) c) m (SND n)) ) ) FALSE (PREORDER t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ) ","date":"2025-02-02T21:29:00+08:00","permalink":"http://fyshxfish.github.io/p/programming-in-lambda-calculus-basic/","title":"Programming in Lambda Calculus, Basic"},{"content":"-Inspired by Algorithm Design and Analysis course, 2024 Fall-\nIntroduction In this semester\u0026rsquo;s algorithms course, we focused on two major categories of search algorithms: backtracking and branch-and-bound. Previously, I always treated various search algorithms like DFS and BFS separately, comparing their differences. In this article, I aim to abstract search algorithms, expecting to derive familiar search strategies from a concise abstract model.\nAbstracting the Search Model and Process Here\u0026rsquo;s the model I\u0026rsquo;ve summarized, demonstrated in Haskell:\nclass (Ord node) =\u0026gt; Search env node where initN :: env -\u0026gt; node check :: env -\u0026gt; node -\u0026gt; Bool child :: env -\u0026gt; node -\u0026gt; [node] search :: env -\u0026gt; node Search env node: A search requires two elements: the search environment env and the search node node. Since we need to determine the expansion order based on the priority of node, we want node to be orderable, hence the Ord constraint. initN :: env -\u0026gt; node: A search needs initialization. The search tree requires a root node, so we want to generate a simple root node from the search environment env. check :: env -\u0026gt; node -\u0026gt; Bool: A search needs a stopping condition. We need a function to determine if the current node is a solution based on the properties of env. child :: env -\u0026gt; node -\u0026gt; [node]: A search needs to continue. The live nodes of the search tree are expandable, so we need a function child to generate a list of child nodes [node] based on env and the current node. search :: env -\u0026gt; node: The main search function. Its goal is to search within the environment env and eventually return the terminal node node, which is the optimal solution we seek. To implement a search algorithm for a specific problem, we need to define the abstraction of the search environment env, design the node node, and implement the above functions: initN, check, child, and search.\nThe search model can be abstracted, and so can the search process. Therefore, I provide a default implementation of the search function (since initN, check, and child are often strongly tied to the specific problem and need to be provided during instantiation, they cannot rely on default implementations). This function abstracts the basic search processâ€”starting from the root node (initN), checking (check) if the highest-priority node is a solution, returning it if true, otherwise expanding (child) its child nodes, reordering the live node list based on priority, and repeating this process:\nsearch e = let step :: [node] -\u0026gt; node step (n:ns) | check e n = n | otherwise = step $ sort (ns ++ child e n) in step [initN e] Example: Instantiating the TSP Search from the Model Search Environment: The directed weighted graph Graph is abstracted as follows:\ntype Vertex = Int type Distance = Int type Edge = (Vertex, Vertex, Distance) data Graph = Graph { vertices :: [Vertex], edges :: [Edge] } Additionally, the search process relies on graph functions like minOut and distance:\nminOut :: Graph -\u0026gt; [(Vertex, Distance)] minOut (Graph vs es) = [ (v, minimum ds) | v \u0026lt;- vs, let es\u0026#39; = filter (\\(v1, _, _) -\u0026gt; v1 == v) es, let ds = [ d | (_, _, d) \u0026lt;- es\u0026#39;]] distance :: Graph -\u0026gt; (Int, Int) -\u0026gt; Maybe Distance distance (Graph _ []) _ = Nothing distance (Graph vs ((v1, v2, d):es)) (s, t) | s == v1 \u0026amp;\u0026amp; t == v2 = Just d | otherwise = distance (Graph vs es) (s, t) Node Design (TspNode):\nA node needs to store the current cost, the list of visited vertices, and the heuristic value (upper bound of the total cost):\ndata TspNode = TspNode { cost :: Int, visited :: [Vertex], -- reverse heuristic :: Int -- heuristic / priority } deriving (Show) The lower the heuristic value of a node, the higher its expansion priority.\ninstance Ord TspNode where compare :: TspNode -\u0026gt; TspNode -\u0026gt; Ordering compare n1 n2 | heuristic n1 \u0026gt; heuristic n2 = GT | heuristic n1 \u0026lt; heuristic n2 = LT | otherwise = EQ Search Function Instantiation:\nTo make Graph TspNode an instance of the Search type class, we can use the default search implementation. However, we still need to implement the initN, check, and child functions:\ninitN:\nThe root node\u0026rsquo;s cost is 0, the visited list is empty, and the heuristic value is irrelevant since the root node will always be the first to be checked and removed from the live node list, never participating in sorting. Thus, heuristic can be set to 0:\ninitN :: Graph -\u0026gt; TspNode initN _ = TspNode 0 [] 0 If the current node has visited all vertices (starting from the origin, traversing a loop, and returning to the origin), then it is considered a solution:\ncheck :: Graph -\u0026gt; TspNode -\u0026gt; Bool check g (TspNode _ vs _) | length vs == length (vertices g) = True | otherwise = False child:\nBased on the visited list, calculate unvisited adjacent nodes. If all other vertices have been visited, attempt to return to the origin:\nchild :: Graph -\u0026gt; TspNode -\u0026gt; [TspNode] child g n = let upBound :: [Vertex] -\u0026gt; Int upBound vs = sum [ d | (s,d) \u0026lt;- minOut g , s `notElem` vs ] at = if null (visited n) then 0 else head (visited n) -- then-clause only for initNode nodes = [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39; | v \u0026lt;- filter (\\v\u0026#39; -\u0026gt; v\u0026#39; `notElem` visited n \u0026amp;\u0026amp; isJust (distance g (at, v\u0026#39;))) -- or abstract this function to `checkChildValid` ((tail . vertices) g), -- `tail` for drop the origin vertex (0 here) let way = fromJust $ distance g (at, v), let cost\u0026#39; = cost n + way, let visited\u0026#39; = v: visited n, let heuristic\u0026#39; = upBound visited\u0026#39; + cost\u0026#39;] back = case distance g (at, 0) of Just wayback -\u0026gt; let cost\u0026#39; = cost n + wayback visited\u0026#39; = 0: visited n heuristic\u0026#39; = cost\u0026#39; in [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39;] Nothing -\u0026gt; [] in if length (visited n) == length (vertices g) - 1 then back else nodes Overall Program Framework:\nBrief Description of Other Instances We can also represent DFS and BFS using this model. In data structure courses, we often use recursion for DFS and queues + iteration for BFS. In this model, changing the priority criteria of nodes changes the strategy for selecting nodes to expand, thereby altering the search behavior.\nAssume we have a node like this:\ndata Node a = Node { info :: a, -- Problem-specific node information level :: Int, -- The level of the node in the search tree order :: Int -- The order in which the node was generated } DFS always expands the deepest live node in the current search tree. To perform depth-first search in any search environment using this node, the priority should be set to level:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | level n1 \u0026gt; level n2 = LT -- DEPTH first | level n1 \u0026lt; level n2 = LT | otherwise = EQ BFS always expands the earliest generated live node in the current search tree. To perform breadth-first search in any search environment using this node, the priority should be set to order:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | order n1 \u0026gt; order n2 = LT -- BREADTH first | order n1 \u0026lt; order n2 = LT | otherwise = EQ Limitations Lack of Application to More Specific Problems:\nI initially planned to implement classic textbook cases using this model, butâ€”time ran out. The deadline is approaching, so I only provided the instantiation of the TSP problem under this model.\nNumber of Solutions:\nHere, I limited the number of solutions to 1, defaulting to the first solution as the problem\u0026rsquo;s solution. This is effective in some cases, such as the TSP problem implemented here, where the heuristic calculation ensures the first solution is the optimal one. However, there may be other scenarios: (a) the first solution is only an approximation of the optimal solution, which may be found later, or (b) multiple solutions need to be retained. These cases are not handled by the current model.\n","date":"2024-11-24T12:09:00+08:00","permalink":"http://fyshxfish.github.io/p/abstractions-for-search-algorithms/","title":"Abstractions for Search Algorithms"},{"content":"å‰è¨€ è¿™ä¸ªå­¦æœŸåŒ…å«ç¼–è¯‘ç³»ç»Ÿå’Œç®—æ³•è®¾è®¡ä¸åˆ†æä¸¤é—¨ä¸“ä¸šè¯¾ï¼Œé‡åˆ°ä¸€äº›é—®é¢˜æ€»ä¼šæƒ³ç€æ”¾åœ¨ Haskell é‡Œå®ç°ä¸€ä¸‹ï¼Œå¯¹äºç¨‹åºæ„é€ å¤šå°‘æœ‰ç‚¹æ–°çš„ä½“ä¼šï¼Œä¹Ÿåº¦è¿‡äº†å¯¹äº Haskell ä¸å¹³é™çš„ç‹‚çƒ­æœŸï¼Œç°åœ¨çš„æˆ‘å·²ç»ä¸ä¼šæƒ³ç€åˆ°å¤„ä¼ æ•™äº†ï¼ˆâ˜ºï¸ï¼‰. æœ¬æ¥åªæ˜¯å‡†å¤‡éšä¾¿å†™å†™åš 0-1 èƒŒåŒ…çš„ Haskell å®ç°ä¸­çš„ä¸€äº›å°æ€è€ƒï¼Œä¸è¿‡çœŸå¼€å§‹åŠ¨ç¬”äº†å°±è¶Šå†™è¶Šæ­£å¼äº†ï¼Œä¹Ÿç®—æ˜¯æ¥è§¦ FP / Haskell ä»¥æ¥çš„ä¸€ç‚¹ç‚¹å°æ€»ç»“. Haskell å®˜ç½‘ å¯¹ Haskell çš„æè¿°æ˜¯ \u0026ldquo;An advanced, purely functional programming language\u0026rdquo;ï¼Œæœ¬æ–‡è¯•å›¾å›´ç»• \u0026ldquo;purely\u0026rdquo; åšä¸€äº›è®¨è®ºï¼šä»€ä¹ˆæ˜¯çº¯ï¼Œæ€ä¹ˆæ ·ç®—ä¸çº¯ï¼Œè¿½æ±‚çº¯åº¦çš„ç†ç”±æ˜¯ä»€ä¹ˆï¼Œçº¯åº¦å¸¦æ¥çš„æ•ˆç›Šæ˜¯ä»€ä¹ˆ.\né¦–å…ˆä» 0-1 èƒŒåŒ…çš„è¿‡ç¨‹å¼å®ç°å‡ºå‘ï¼Œæˆ‘æŠŠè¿‡ç¨‹å¼å®ç° 1:1 æŠ•å°„åˆ° Haskell é‡Œï¼Œæ„Ÿè§‰è¿™æ®µä»£ç ä¸æ˜¯å¾ˆç¬¦åˆ Haskell çš„æ°”è´¨ï¼ˆğŸ˜¯ï¼‰ï¼Œäºæ˜¯å›åˆ°äº†é€’æ¨å¼ï¼Œå›åˆ°äº†ç®—æ³•è¯¾ä¸Šä¸€ç¬”å¸¦è¿‡çš„é€’å½’å®ç°ï¼Œå¯¹è¿‡ç¨‹å¼è¯­è¨€çš„é€’æ¨å®ç°å’Œå‡½æ•°å¼è¯­è¨€çš„é€’å½’å®ç°åšäº†ä¸€äº›æ¯”è¾ƒï¼Œçœ‹çœ‹ä¸¤è€…å¯¹äºâ€œå¦‚ä½•é¿å…é‡å¤è®¡ç®—çš„å¼€é”€â€è¿™ä¸ªé—®é¢˜ï¼ˆä¸å±€é™äº 0-1 èƒŒåŒ…é—®é¢˜ï¼‰ç»™å‡ºçš„ä¸åŒç­”æ¡ˆï¼Œå‰è€…åˆ©ç”¨æºä»£ç ä¸Šçš„è®°å¿†æ•°ç»„ï¼Œåè€…åˆ™å¯ä»¥åˆ©ç”¨çº¯å‡½æ•°çš„ç‰¹æ€§ï¼Œé€šè¿‡æ±‚å€¼ç­–ç•¥å®ç°å‡å°‘é‡å¤è®¡ç®—.\nä¸€æ®µç®—æ³•è®¾è®¡ä¸è®¡ç®—æ¨¡å‹çš„è®¨è®ºï¼šä» 0-1 èƒŒåŒ…é—®é¢˜è¿™ä¸ªä¾‹å­é‡Œä¹Ÿå¯ä»¥çœ‹å‡º\u0026quot;ç®—æ³•è®¾è®¡\u0026quot;å…¶å®æ˜¯ä¸å®Œå…¨ç‹¬ç«‹äºç¼–ç¨‹èŒƒå¼çš„ï¼Œä¹Ÿè®¸æ›´åˆé€‚çš„è¯´æ³•æ˜¯ï¼Œç®—æ³•è®¾è®¡å¼ºç›¸å…³äºç‰©ç†è®¡ç®—æœºçš„å®é™…è¿è¡Œæ–¹å¼ï¼Œæ¯•ç«Ÿç®—æ³•è®¾è®¡é™¤äº†è§£å†³é—®é¢˜ï¼Œè¿˜æœ‰ä¸€ä¸ªè¿½æ±‚æ˜¯é™ä½åœ¨ç‰©ç†æœºä¸Šè¿è¡Œæ—¶çš„æ—¶ç©ºè®¡ç®—èµ„æºæ¶ˆè€—ï¼Œè¿™å’Œå‘½ä»¤å¼è¯­è¨€çš„ç‰¹æ€§æ˜¯ç›¸å¥‘åˆçš„ï¼Œè€Œå‡½æ•°å¼è¯­è¨€æœ‰ç‚¹ Lambda Calculus è™šæ‹Ÿæœºçš„æ„æ€ï¼›æ¯”å¦‚å¤æ‚åº¦çš„è®¡ç®—ï¼Œç›´æ¥æŠŠå‘½ä»¤å¼ç¨‹åºçš„æ—¶é—´å¤æ‚åº¦è®¡ç®—æ–¹å¼ç…§æ¬ç»™å‡½æ•°å¼ç¨‹åºæ˜¯æœ‰é—®é¢˜çš„ï¼Œå‰è€…çš„ç†è®ºåŸºç¡€æ˜¯å›¾çµæœº - çŠ¶æ€è½¬ç§»æ¬¡æ•°ï¼Œåè€…çš„ç†è®ºåŸºç¡€æ˜¯ $Î»$ æ¼”ç®— - è§„çº¦æ¬¡æ•°ï¼Œè®¡ç®—æ¨¡å‹çš„ä¸åŒåŠ¿å¿…å¸¦æ¥ä¸€äº›å·®å¼‚. å› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„è®¡ç®—æœºé‡‡å–å†¯è¯ºä¾æ›¼ä½“ç³»ç»“æ„ï¼Œå³ å›¾çµæœºçš„ç‰©ç†å®ç°ï¼Œæ‰€ä»¥ç®—æ³•è¯¾ä¹Ÿé‡‡ç”¨æ›´æ¥è¿‘ç¡¬ä»¶çš„å‘½ä»¤å¼çš„ç¼–ç¨‹èŒƒå¼ï¼Œè¿˜æ˜¯å¾ˆåˆç†çš„. ä¸ç”±å¾—æƒ³èµ·å¤§ä¸€ä¸Š CPP ç¨‹åºè®¾è®¡æ—¶è€å¸ˆè¯´ â€œåªè¦å†¯è¯ºä¾æ›¼ä½“ç³»ç»“æ„è¿˜å­˜åœ¨ï¼Œæˆ‘ä»¬å°±\u0026hellip;(ååŠå¥å¿˜äº†)â€ï¼Œä¸çŸ¥ä¸è§‰æˆ‘å·²ç»å°è¯•èµ°äº†èµ°å¦ä¸€æ¡è·¯. è¯´èµ·å‡½æ•°å¼è¯­è¨€çš„æœºå™¨è¿™ä»¶äº‹æƒ…ï¼Œå…¶å® 1970s,1980s æœ‰å­¦è€…ä¸ºå‡½æ•°å¼çš„è¯­è¨€è®¾è®¡è¿‡ä¸“é—¨çš„éå†¯è¯ºä¾æ›¼æœºå™¨ï¼ˆcombinator machine, dataflow machine, etc.ï¼‰ï¼Œåæ¥å¤§å®¶å‘ç°åœ¨æ•ˆç‡çš„æ–¹é¢ï¼Œç°æœ‰æœºå™¨ + å¥½çš„ç¼–è¯‘å™¨ \u0026gt; ä¸“ç”¨æœºå™¨ï¼Œå¯å‚è€ƒ A History of Haskell: Being Lazy With Class, Part I - 2.1\nå‘½ä»¤å¼ç¨‹åºå¦‚ä½•é¿å…é‡å¤è®¡ç®— å…³äºè¿‡ç¨‹å¼çš„ 0-1 èƒŒåŒ…ï¼Œä½ ç†Ÿæ‚‰åˆ°å‡ ä¹å¯ä»¥é»˜å†™çš„ä¸€æ®µç¨‹åºï¼š\nå›å¿†ï¼šä½¿ç”¨ dp æ•°ç»„ï¼Œè€Œä¸æ˜¯é€’å½’çš„åŸå› æ˜¯ â€”â€” å°†é€’å½’è½¬ä¸ºè¿­ä»£ï¼Œé¿å…é‡å¤è®¡ç®—ï¼›å¦ä¸€ç§é™ˆè¿°æ˜¯å°†å‡½æ•°è°ƒç”¨ dp(i, j) çš„ç»“æœå­˜å‚¨åˆ°å†…å­˜ä¸­çš„æ•°ç»„ dp[i][j] é‡Œï¼Œå®ç°è®°å¿†åŒ–. int knapsack(int n, int* weight, int* value, int capacity) { int dp[n+1][capacity+1]; // INIT: BASE CASE// for (int j = 0; j \u0026lt;= capacity; j++) dp[0][j] = 0; for (int i = 0;i \u0026lt;= n;i++) dp[i][0] = 0; // DP // for (int i = 1; i \u0026lt;= n;i++) { int w = weight[i], v = value[i]; for (int j = 1; j \u0026lt;= capacity; j++) { if (j \u0026lt; w) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v); } } return dp[n][capacity]; } å°†ä¸Šè¿°ä»£ç  1:1 ç¿»è¯‘æˆ Haskell ç¨‹åºï¼Œä½ å°†å¾—åˆ°ï¼š\nimport Data.Array type Value = Int type Weight = Int type Item = (Value, Weight) knapsack01 :: Weight -\u0026gt; [Item] -\u0026gt; Value knapsack01 capacity items = dp ! (n, capacity) where n = length items dp = array((0,0), (n,capacity)) [((i, w), step i w) | i \u0026lt;- [0..n], w \u0026lt;- [0..capacity]] step 0 _ = 0 step _ 0 = 0 step i w | curWgt \u0026gt; w = dp ! (i - 1, w) | otherwise = max (dp ! (i - 1, w)) (curVal + dp ! (i - 1, w - curWgt)) where curVal = fst $ items !! (i - 1) curWgt = snd $ items !! (i - 1) å†™çš„æ—¶å€™æ„Ÿè§‰ä¸å¤ªå¯¹åŠ²ï¼Œç¬¬ä¸€æ„Ÿè§‰æ˜¯ï¼šè¿™ä¸¤æ®µä»£ç æ²¡æœ‰åŒºåˆ«. è¿™å°±æ˜¯åœ¨å‡½æ•°å¼çš„è¯­è¨€é‡Œå†™å‘½ä»¤å¼ç¨‹åº. å‘¨äº”æ™šä¸Šæˆ‘ä»ç‚¸é¸¡åº—èµ°å‡ºæ¥çš„æ—¶å€™ï¼Œæœ‰äº†ä¸€äº›æ–°çš„æƒ³æ³•ï¼š\nå‡½æ•°å¼ç¨‹åºå¦‚ä½•é¿å…é‡å¤è®¡ç®— å½“æˆ‘ä»¬ä¸èƒ½åƒè¿‡ç¨‹å¼è¯­è¨€é‚£æ ·åœ¨å†…å­˜æ¡é‡Œéšæœºå­˜å–çš„æ—¶å€™ï¼Œå½“æˆ‘ä»¬å»ºç«‹èµ·ä¸€å±‚å±‚æŠ½è±¡çš„æ—¶å€™ï¼Œå¦‚ä½•è¿½æ±‚æ€§èƒ½å‘¢ï¼Ÿé™¤äº†åœ¨ CSAPP ç¬¬äº”ç« é‡Œå­¦ä¹ åˆ©ç”¨å±€éƒ¨æ€§ã€å¾ªç¯å±•å¼€ã€æé«˜å¹¶è¡Œæ€§ç­‰æ–¹æ³•ï¼Œè¿˜æœ‰ä»€ä¹ˆæ–¹å¼å¯ä»¥æé«˜ç¨‹åºçš„æ€§èƒ½ï¼Ÿé™¤äº†ç¨‹åºå‘˜æœ¬èº«ä»æºä»£ç å±‚é¢æé«˜æ€§èƒ½ï¼Œè¿˜å¯ä»¥åœ¨å“ªé‡Œä¼˜åŒ–æ€§èƒ½ï¼Ÿç¼–è¯‘å™¨ä»ç¨‹åºå‘˜æ‰‹ä¸Šæ¥ç®¡ä»£ç ï¼Œç¼–è¯‘å™¨å¯ä»¥åšä»€ä¹ˆï¼Ÿ\n0-1 èƒŒåŒ…ï¼šå›åˆ°èµ·ç‚¹ æ‰€æœ‰ç‰©å“ä¸º $items$ï¼Œè§„æ¨¡ä¸º $N$, ç‰©å“å±æ€§ä¸ºä»·å€¼ $v_i, w_i$ï¼ŒèƒŒåŒ…æ€»å®¹é‡ä¸º $W$ï¼Œå®šä¹‰ $z(i, j)$ ä¸ºå¯é€‰ç‰©å“ä¸º $items[1..i]$ï¼ŒèƒŒåŒ…å®¹é‡ä¸º $j$ æ—¶ï¼Œå¯è·å¾—çš„æœ€å¤§ä»·å€¼ï¼Œé‚£ä¹ˆ\né€’æ¨åŸºï¼š$\\forall i, j,\\quad z(i, 0) = 0, z(0,j) = 0;$\né€’æ¨æ­¥ï¼š$z(i,j) = max(z(i-1, j), v_i + z(i-1, j-w_i));$\nç›®æ ‡å€¼ï¼š$z(N, W)$ æ¯«æ— ç–‘é—®è¿™æ˜¯é€’å½’çš„ç»“æ„ï¼Œåœ¨ Haskell é‡Œå†™é€’å½’å®ç°ï¼Œå¦‚åŒå‘¼å¸èˆ¬è‡ªç„¶ï¼š\nï¼ˆNOTEï¼š1. çœ‹åˆ°è¿™é‡Œä¹Ÿè®¸ä½ å·²ç»å¼€å§‹æ‹…å¿§é‡å¤è®¡ç®—ã€å†…å­˜å ç”¨çš„äº‹æƒ…äº† ï¼›2. å€¼å¾—ç¨ç¨æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œè¿™ä¸€æ®µä»£ç å®Œå…¨ä¸æ¶‰åŠåŸºäºç´¢å¼•çš„æ•°æ®å­˜å–ï¼‰\ntype Item = (Value, Weight) knapsack :: [Item] -\u0026gt; Int -\u0026gt; Int -- items + capacity -\u0026gt; maximal value knapsack _ 0 = 0 knapsack [] _ = 0 knapsack ((v,w):items) c = let choose = v + knapsack items (c-w) -- choose current item chxxse = knapsack items c -- not choose current item in if w \u0026gt; c then chxxse else max choose chxxse ä¸¥æ ¼æ±‚å€¼ - ä¸é€’å½’çš„ç†ç”± åœ¨èƒŒåŒ…é—®é¢˜çš„ C++ ï¼ˆä¸¥æ ¼æ±‚å€¼è¯­è¨€ï¼‰å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¸ç”¨é€’å½’çš„ç†ç”±æ˜¯å¯¹äºæ€§èƒ½çš„è¿½æ±‚ï¼Œå› è€Œä½¿ç”¨ dp[i][j] ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œå°†é€’å½’ä¸­çš„é‡å¤è®¡ç®—è½¬æ¢ä¸ºæ•°ç»„çš„ç´¢å¼•è®¿é—®. è¿™ä¸ªè®°å¿†åŒ–çš„å·¥ä½œï¼Œé™¤äº†æˆ‘ä»¬è‡ªå·±åšï¼ˆä¹Ÿå°±æ˜¯ä½¿ç”¨ dp æ•°ç»„ï¼‰ï¼Œè¿˜å¯ä»¥ â€”â€” äº¤ç»™ç¼–è¯‘å™¨. å½“ç„¶è¿™ç§å½¢å¼çš„è®°å¿†åŒ–å°±ä¸æ˜¯åœ¨æºä»£ç å±‚é¢ä¸Šå‘ˆç°ä¸€ä¸ªè®°å¿†æ•°ç»„äº†ï¼Œè€Œæ˜¯é€šè¿‡æ±‚å€¼ç­–ç•¥æ¥å®ç°. åœ¨è®¨è®ºæ±‚å€¼ç­–ç•¥å‰ï¼Œå…ˆçœ‹çœ‹ä»€ä¹ˆæ˜¯çº¯å‡½æ•°.\nå¯¹äº \u0026quot; çº¯ \u0026quot; å‡½æ•°çš„è®¨è®º å‡½æ•°æ˜¯ä»€ä¹ˆï¼Ÿ/ å‡½æ•°çš„è¡¨ç¤ºæ³• / LUT çš„ç±»æ¯” / ç¼–è¯‘å™¨è¡Œä¸º / çº¯å‡½æ•°çš„æ±‚å€¼ç­–ç•¥\nâ€”â€” å¤šå¹´ä»¥åï¼Œé¢å¯¹ \u0026ldquo;å‡½æ•°å¼ç¨‹åºè®¾è®¡\u0026rdquo;ï¼ŒğŸŸå°†ä¼šå›æƒ³èµ·æ•°å­¦è€å¸ˆå¸¦å¥¹å»è§è¯†å‡½æ•°çš„é‚£èŠ‚é¥è¿œçš„æ•°å­¦è¯¾.\nå‡½æ•°æ˜¯ä¸€ç§æ˜ å°„å…³ç³». ä½“ç°è¿™ç§å…³ç³»çš„æ–¹å¼ï¼Œå³ å‡½æ•°çš„è¡¨ç¤ºæ³•ï¼Œé™¤äº†å‡½æ•°è¡¨è¾¾å¼ã€å‡½æ•°å›¾åƒï¼Œè¿˜æœ‰è¡¨æ ¼.\nå¦‚æœæˆ‘ä»¬éœ€è¦ä¸€å°æœºå™¨æ¥æ‰§è¡Œå®šä¹‰åŸŸä¸ºæŸæœ‰ç©·é›†çš„å®Œå…¨å¹³æ–¹å‡½æ•° f(x, y) = x*x + y*yï¼Œé™¤äº†ä¾èµ–åŠ æ³•å™¨ã€ä¹˜æ³•å™¨æ„æˆçš„ç»„åˆé€»è¾‘ç”µè·¯ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨ LUTï¼ˆLookUp Tableï¼‰ï¼Œè™½ç„¶å¬èµ·æ¥æœ‰ç‚¹ç¦»è°±ï¼Œä½†æ˜¯å®ƒçš„å¯è¡Œæ€§æ˜¯ä¸å¯å¦è®¤çš„.\nNOTE: å¯èƒ½äº§ç”Ÿçš„ç–‘æƒ‘ - å¦‚ä½•ç¡®å®š / å¦‚ä½•æè¿°ç”µè·¯å®ç°çš„å‡½æ•°ä¸æˆ‘ä»¬é¢„æœŸçš„å‡½æ•°ä¹‹é—´çš„ç­‰ä»·æ€§ï¼Ÿæˆ–è€…è¯´ï¼Œæˆ‘ä»¬é¢„æœŸçš„æ˜¯å‡½æ•° $f$ï¼Œç”µè·¯å®ç°çš„æ˜¯å‡½æ•° $f\u0026rsquo;$ï¼Œå¦‚ä½•ç¡®å®š $f\u0026rsquo; \\equiv f$ï¼Ÿå¦‚æœä½ å¯¹ $Î»$ æ¼”ç®—ï¼ˆé€»è¾‘å­¦ï¼‰ä¸­å‡½æ•°ç­‰ä»·çš„å½¢å¼åŒ–ç†è®ºæ„Ÿå…´è¶£ï¼Œå¯ä»¥å‚çœ‹ Lambda Calculus and Combinators, an introduction - Chapter 5~8. è¿™é‡Œ LUT å®ç°çš„å‡½æ•° $f_1\u0026rsquo;$ ä¸é¢„æœŸå‡½æ•° $f$ å¤–å»¶ç­‰ä»·ï¼ˆextensional equivalenceï¼‰ï¼Œç»„åˆé€»è¾‘å®ç°çš„å‡½æ•° $f_2\u0026rsquo;$ ä¸é¢„æœŸå‡½æ•° $f$ å†…æ¶µç­‰ä»·ï¼ˆintensional equivalenceï¼‰.\næˆ‘ä»¬ä¹ æƒ¯çš„ç¼–è¯‘å™¨çš„è¡Œä¸ºå¤§è‡´æ˜¯ï¼šçœ‹åˆ°å‡½æ•°+å‚æ•° â†’ æ”¾å…¥ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—ï¼›å¦‚æœåªä¾èµ–æ˜ å°„è¡¨ï¼ˆLUTï¼‰ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨çš„è¡Œä¸ºå¤§è‡´æ˜¯ï¼šçœ‹åˆ°å‡½æ•°+å‚æ•° â†’ åœ¨ LUT ä¸­æŸ¥æ‰¾å¯¹åº”è¾“å‡ºï¼Œè¿™éœ€è¦ LUT å­˜å‚¨å¥½æ‰€æœ‰å‡½æ•°è¾“å…¥å¯¹åº”çš„è¾“å‡ºï¼Œäºæ˜¯å‹åŠ›ç»™åˆ° LUTï¼›æŠ˜ä¸­çš„ç­–ç•¥æ˜¯ï¼Œç¬¬ä¸€æ¬¡è§åˆ°å‡½æ•°+å‚æ•°æ—¶ï¼Œåˆ©ç”¨ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—ï¼Œå¹¶ç¼“å­˜åˆ° LUTï¼Œå†æ¬¡è§åˆ°è¿™ç»„å‡½æ•°+å‚æ•°ï¼Œç›´æ¥åœ¨ LUT ä¸­æŸ¥æ‰¾.ï¼ˆå‡½æ•°å¼æœ‰è‡ªå·±çš„é«˜é€Ÿç¼“å­˜:ï¼‰\nå­è¿‡ç¨‹ä¸å‡½æ•° / å‰¯ä½œç”¨ä¸çº¯åº¦\nè¿™é‡Œæˆ‘ä»¬ç”¨å‡½æ•°æŒ‡ä»£â€œçº¯â€å‡½æ•°ï¼ˆå®šä¹‰è§ä¸‹ï¼‰ï¼Œå°†éçº¯çš„è¿‡ç¨‹ç§°ä¸ºå­è¿‡ç¨‹.\nä½¿ç”¨ LUT å®ç°å‡½æ•°çš„å‰ææ˜¯ï¼šå‡½æ•°æ˜¯çº¯çš„ï¼Œå³å¯¹ç›¸åŒçš„è¾“å…¥æ€»æ˜¯è¿”å›ç›¸åŒçš„è¾“å‡ºï¼Œå¹¶ä¸”ä¸äº§ç”Ÿå‰¯ä½œç”¨. å½¢è±¡åœ°è¯´ï¼Œæˆ‘ä»¬å¸Œæœ› LUT æ˜¯ä¸¥æ ¼çš„ï¼ŒIN / OUT å¼•è„šä¿æŒå¹²å‡€ï¼ŒIN æ¥æ”¶å‡½æ•°å‚æ•°ï¼ŒOUT ç»™å‡ºå‡½æ•°è¾“å‡ºï¼Œä¸å¸Œæœ›åœ¨ IN ä¹‹å¤–ï¼Œå†ä»æŸä¸ªå¯„å­˜å™¨æ¥è¿›æ¥ä¸€ä¸ªè¾“å…¥ï¼Œä¹Ÿä¸å¸Œæœ›åœ¨ OUT çš„æ—è¾¹ï¼Œå¤šè¿æ¥ä¸€ä¸ªå¯„å­˜å™¨ï¼ŒæŠŠå¯„å­˜å™¨å­˜å‚¨å€¼çš„æ”¹å˜ä½œä¸ºå‡½æ•°æ‰§è¡Œçš„ç»“æœï¼›å³ å‡½æ•°æœ¬èº«æ€»æ˜¯ç‹¬ç«‹äºç¨‹åºçš„å…¶ä»–éƒ¨åˆ† - LUT æ€»æ˜¯ç‹¬ç«‹äºç”µè·¯çš„å…¶ä»–éƒ¨åˆ†ï¼Œä¸å—å…¶ä»–éƒ¨åˆ†å½±å“.\nè¾“å…¥è¾“å‡ºçš„çº¯åº¦ï¼š\naddx æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºè¿™ä¸ªå‡½æ•°æ— æ³•ä¿è¯å¯¹äºåŒæ ·çš„ a æ€»æ˜¯ç»™å‡ºç›¸åŒçš„è¾“å‡ºï¼Œå› ä¸ºå…¨å±€å˜é‡ x å¯èƒ½éšæ—¶è¢«ä¿®æ”¹ï¼Œå¯¼è‡´ä¿®æ”¹å‰å a + x çš„å€¼ä¸åŒï¼›readOneWord æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºæ— æ³•ä¿è¯å¯¹äºåŒä¸€ä¸ªè·¯å¾„ pï¼Œå§‹ç»ˆè¿”å›åŒæ ·çš„ firstWordï¼Œå› ä¸º p å¯¹åº”çš„æ–‡ä»¶å¯èƒ½è¢«å…¶ä»–ç¨‹åºéšæ—¶ä¿®æ”¹.\nint x; // global int addx(int a){ return a + x; } string readOneWord(path p) { // IO return head(getFile(p)); } å‰¯ä½œç”¨ï¼š\ngreeting æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºå®ƒäº§ç”Ÿäº† print çš„å‰¯ä½œç”¨ï¼› write æ˜¯ä¸çº¯çš„ï¼Œå› ä¸ºå®ƒé€ æˆäº†å†™æ–‡ä»¶çš„å‰¯ä½œç”¨.\nvoid greeting(string name){ print(f\u0026#34;Hello, {name}\u0026#34;); } void writeLine(path p) { getFile(p).append(\u0026#34;Append this line\u0026#34;); } \u0026ldquo;æçº¯\u0026rdquo;ï¼Ÿ\nå¯¹äºä¸Šè¿°çš„éçº¯å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‰¯ä½œç”¨åˆ†ç¦»ï¼Œå¾—åˆ°å¯¹åº”çš„çº¯å‡½æ•°å¦‚ä¸‹ï¼š\nint addx(int a, int x) { return a + x; } string readOneWord(file f) { string firstWord = head(f); return firstWord; } string greeting(string name){ return f\u0026#34;Hello, {name}\u0026#34;; } file writeLine(file f){ return f.append(\u0026#34;Append this line\u0026#34;); } åˆ†ç¦»å‰¯ä½œç”¨çš„ç¤ºä¾‹ / Imperative Shell, Functional Core\næé—®ï¼šå‡è®¾æœ‰ä¸¤ä¸ªç±» Camera, FaceRecognizerï¼ŒCamera ç±»æœ‰ä¸€ä¸ªæ–¹æ³• getFrame ç”¨äºä»ç‰©ç†æ‘„åƒå¤´æ•è·ä¸€å¸§å›¾åƒï¼ŒFaceRecognizer ç±»æœ‰ä¸€ä¸ªæ–¹æ³• recognizePerson ç”¨äºè¯†åˆ«ä¸€å¸§å›¾åƒä¸­çš„äººè„¸å¹¶è¿”å›å¯¹åº”ç”¨æˆ·å. è‹¥éœ€è¦å®ç°å‡½æ•° getFrameAndRecognize ç”¨äºæ•è·å½“å‰å¸§ã€è¯†åˆ«å¹¶è¿”å›ç”¨æˆ·åï¼Œå¦‚ä½•ç»„ç»‡ç¨‹åºç»“æ„ï¼Ÿ\nä¸€ç§ç­”æ¡ˆï¼šå°† FaceRecognizer çš„å®ä¾‹ä½œä¸º Camera çš„æˆå‘˜ï¼Œä¿è¯ FaceRecognizer çš„çº¯åº¦ï¼Œå³ FaceRecognizer çš„æ–¹æ³•æ€»æ˜¯å¯¹å¸§åšè®¡ç®—ï¼Œå°† getFrame è¿™æ ·çš„å‰¯ä½œç”¨åˆ†ç¦»ã€æ­¢æ­¥äº Camera ç±».\nclass Camera: self.face_recognizer = FaceRecognizer() def getFrame(): # snip # return frame def getFrameAndRecognize(): frame = getFrame() name = face_recognizer.recognizePerson(frame) return name class FaceRecognizer: def recognizePerson(frame: image): # snip # return name å³ï¼šä¿è¯åŠŸèƒ½å‡½æ•°çš„çº¯åº¦ï¼Œå¹¶å°†å…¶ä½œä¸ºç¨‹åºçš„æ ¸å¿ƒï¼Œå°† IO ç­‰éçº¯æ“ä½œåˆ†ç¦»åˆ°å¤–å±‚ â€”â€” Imperative Shell, Functional Core. ï¼ˆæ­¤å¤„åº”æœ‰ä¸€åœº Simon Peyton Jones çš„è®²åº§é“¾æ¥ï¼Œä½†æˆ‘ä¸€æ—¶æ‰¾ä¸åˆ°äº†.ï¼‰\nè¿½æ±‚çº¯åº¦çš„ç†ç”±\næ–¹ä¾¿å•å…ƒæµ‹è¯•ä¸ç»´æŠ¤ï¼›\næ˜“äºå¹¶è¡Œï¼›\nå¯ä»¥ç”¨æŸ¥è¡¨ä½œä¸ºä¸€ç§æ±‚å€¼ç­–ç•¥ï¼Œæˆ–è€…ä½œä¸ºæ±‚å€¼ç­–ç•¥çš„ä¸€éƒ¨åˆ†ï¼Œé¿å…äº†é‡å¤è®¡ç®—å¸¦æ¥çš„å¼€é”€.\nè¯­æ³•æ ‘ä¸è¯­æ³•å›¾ / é‡å¤è®¡ç®— / æ±‚å€¼ç­–ç•¥\nä¸€äº›å‚è€ƒèµ„æ–™\nHaskell Wiki - Graph Reduction\nä» Lambda Calculus è§’åº¦è§£é‡Šæ“ä½œè¯­ä¹‰ call-by-value / call-by-name / call-by-needï¼Œå¯ä»¥å‚è€ƒ Types and Programming Language, Section 5.1\n[TODO]\nè¿™ä¸€èŠ‚è¿˜æ²¡å†™çš„åŸå› æ˜¯ï¼šæˆ‘ ä¹Ÿ ä¸ æ˜¯ å¾ˆ æ‡‚.\ngraph reduction çš„å›¾ç¤º\nè¯­æ³•æ ‘ä¸è¯­æ³•å›¾æ¯”è¾ƒ\nlet å¯¹åº”çš„è¯­æ³•å›¾ï¼ˆåŠå…¶ Core è§£é‡Šï¼Ÿï¼‰\n\u0026hellip;\næƒ°æ€§æ±‚å€¼ - é€’å½’çš„ç†ç”± ç…§åº”æœ¬æ–‡ 3.2 ä¸é€’å½’çš„ç†ç”± é¿å…é‡å¤è®¡ç®—çš„æ–¹å¼é™¤äº†é€šè¿‡æ˜¾å¼ç¼“å­˜ï¼ˆè®°å¿†æ•°ç»„ï¼‰ï¼Œè¿˜å¯ä»¥ä¾èµ–ç¼–è¯‘å™¨é‡‡å–çš„æ±‚å€¼ç­–ç•¥ï¼ˆæƒ°æ€§æ±‚å€¼ Lazy Evaluationï¼‰ï¼Œå°†è¯­æ³•æ ‘ä¸­çš„æ‰€æœ‰ç›¸åŒçš„è¡¨è¾¾å¼ç»“ç‚¹æŒ‡å‘åŒä¸€ä¸ªç»“ç‚¹ï¼Œå®ç°è®¡ç®—ç»“æœçš„å¤ç”¨.\nå…¶ä»– å‰æ–‡è¯•å›¾åœ¨ å‘½ä»¤å¼è¯­è¨€ / å‡½æ•°å¼è¯­è¨€ï¼Œé€’å½’ / éé€’å½’ ä¹‹é—´åšæ¯”è¾ƒæ˜ç¡®çš„åŒºåˆ†ï¼Œå…¶å®ï¼Œå½“ç„¶é€’å½’ä¸æ˜¯ FP çš„ä¸“åˆ©ï¼Œè®°å¿†åŒ–æ•°ç»„ä¹Ÿä¸åªæ˜¯åœ¨å‘½ä»¤å¼ç¨‹åºé‡Œå¥½ç”¨ï¼Œåªæ˜¯ä¸åŒè¯­è¨€ / ç¼–ç¨‹èŒƒå¼æœ¬èº«çš„ç‰¹æ€§ï¼ˆä¾‹å¦‚ C++ çš„ä¸¥æ ¼æ±‚å€¼ / Haskell çš„æƒ°æ€§æ±‚å€¼ï¼‰ï¼Œä½¿å¾—æˆ‘ä»¬å¯¹äºç¨‹åºäº§ç”Ÿäº†ä¸ä¸€æ ·çš„æ€è€ƒå’Œä¸ä¸€æ ·çš„æƒ¯æ€§. å¯¹äºçº¯åº¦ä¸æƒ°æ€§æ±‚å€¼ï¼Œå‘½ä»¤å¼è¯­è¨€ä¹Ÿå¯ä»¥æœ‰çµæ´»çš„æ±‚å€¼ç­–ç•¥ï¼Œæ¯”å¦‚åˆ¤æ–­å‡½æ•°çš„çº¯åº¦ï¼Œå¯¹éçº¯å‡½æ•°ä¸¥æ ¼æ±‚å€¼ï¼Œå¯¹çº¯å‡½æ•°æƒ°æ€§æ±‚å€¼.\n","date":"2024-10-20T19:48:00+08:00","permalink":"http://fyshxfish.github.io/p/how-to-avoid-redundant-computations--pure-functions-and-their-evaluation-strategies/","title":"How to Avoid Redundant Computations + Pure Functions and Their Evaluation Strategies"},{"content":"æ¥è‡ª Lambda-Calculus and Combinator Â§ 4C Theorem 4.20 çš„ proof éƒ¨åˆ†ï¼Œæ•´ä½“æ„å›¾æ˜¯è¯æ˜ç¬¦åˆ Definition 4.18 çš„å…¨ç§°é€’å½’å‡½æ•°å¯ä»¥ç”¨ç»„åˆå­æ¥è¡¨ç¤º.â€‚è¿™é‡Œå¯¹è¯¥è¯æ˜çš„å…³é”®éƒ¨åˆ†ï¼Œå³è¿­ä»£ç»„åˆå­çš„æ„é€ ï¼Œåšç®€è¦çš„é™ˆè¿°. ä¹Ÿå¯ä»¥ç†è§£ä¸ºï¼šåœ¨ Pure Lambda Calculus ä¸­ç¼–å†™ä¸€ä¸ªå…·æœ‰ç‰¹å®šç»ˆæ­¢æ¡ä»¶çš„è¿­ä»£ç¨‹åº. å¦‚æœä½ å¥½å¥‡ \u0026quot; å¦‚ä½•åœ¨ Lambda Calculus ä¸­ç¼–å†™ä¸€ä¸ªæŒ‡å®šè¿­ä»£ / é€’å½’æ¬¡æ•°çš„è¿­ä»£ / é€’å½’å‡½æ•° \u0026quot; ï¼Œå¯ä»¥å‚è€ƒ Lambda-Calculus and Combinator Â§ 4B Theorem 4.11 çš„ proof ä¸­ $R_{\\text{Bernays}}$ ç»„åˆå­çš„æ„é€ ï¼Œè¿™ä¸ªæ„é€ è¿‡ç¨‹ä¹Ÿååˆ†ç²¾å·§.\né€’å½’ä¸è¿­ä»£ï¼šåœ¨ $R_{\\text{Bernays}}$ é€’å½’ç»„åˆå­çš„æ„é€ ä¸­ï¼Œæ±‚è§£æŸä¸ªé€’å½’å‡½æ•° $\\phi $ çš„å€¼ $ \\phi(n) $ï¼Œç”¨çš„æ–¹æ³•å°±æ˜¯ä» $ \\phi(0) $ å¼€å§‹ï¼Œåš $n$ æ¬¡è¿­ä»£å¾—åˆ°çš„ï¼ˆå¤§è‡´å¦‚ä¸‹ï¼šè®°é€’å½’æ­¥æ›´æ–°å‡½æ•°ä¸º $\\chi$ï¼Œ$\\phi(n) = \\chi^n \\phi(0)$ï¼‰. è¿­ä»£å’Œé€’å½’æ˜¯æ­£å‘ä¸é€†å‘çš„åŒºåˆ«. æœ¬æ–‡ä¸­çš„\u0026quot;é€’å½’\u0026quot;æ„åœ¨æè¿°\u0026quot;è°ƒç”¨è‡ªèº«\u0026quot; çš„ç»“æ„ç‰¹ç‚¹ï¼Œæ¢è®¨çš„ä¸­å¿ƒé—®é¢˜è¿˜æ˜¯å¯¹è¿­ä»£ï¼ˆ$0 \\rightarrow 1 \\rightarrow \u0026hellip; \\rightarrow n$ï¼‰é—®é¢˜çš„æ±‚è§£.\næ„é€ ç›®æ ‡ å‡è®¾æœ‰ä¸€ä¸ªæ£€æŸ¥å‡½æ•° $X$ï¼Œè¿­ä»£çš„ç»ˆæ­¢æ¡ä»¶ä¸º $XY=_{\\beta,w}\\bar{0}$, æˆ‘ä»¬å¸Œæœ›æ„é€ ä¸€ä¸ªç»„åˆå­ $P$,å¾—åˆ°æœ€å°çš„ç¬¦åˆç»ˆæ­¢æ¡ä»¶çš„ $Y$. å³ä» $Y = \\bar{0}$ å¼€å§‹ï¼Œæ£€æŸ¥ $(XY) = _{\\beta,w}? \\bar{0}$ ï¼Œè‹¥æ¡ä»¶æ»¡è¶³ï¼Œåˆ™è¿”å›å€¼ä¸ºæ­¤ $Y$ï¼Œå¦åˆ™ç»§ç»­æ£€æŸ¥ $X(\\bar{\\sigma}Y)$ï¼Œæˆ‘ä»¬å¸Œæœ›æ„é€ ä¸€ä¸ªç»„åˆå­ $P$ è‡ªåŠ¨åŒ–æ­¤æ£€æŸ¥è¿‡ç¨‹ï¼Œå½¢å¼åŒ–åœ°ï¼Œæˆ‘ä»¬é¢„æœŸ $P$ çš„è¡Œä¸ºå¦‚ä¸‹:\n$$ PXY =_{\\beta,w}Y \\quad \\text{, if } XY = _{\\beta,w}\\bar{0};$$\n$$ PXY =_{\\beta,w}PX(\\bar{\\sigma}Y), \\text{ otherwise} $$\nå®Œå…¨å°Šé‡é¢„æœŸï¼Œå†™ä¸€ä¸ª $P$ ç»„åˆå­ï¼š$P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$ï¼Œå…¶ä¸­ $\\textbf{D}=\\lambda xyz.z(\\textbf{K}y)x$, å¯ä»¥ç”¨ $\\textbf{Y}$ å¯¹è¿™ä¸ªé€’å½’çš„ $P$ ç»„åˆå­è¿›è¡Œæ±‚è§£ï¼ˆ$P = \\textbf{Y}(\\lambda uxy.\\textbf{D}y(ux(\\bar{\\sigma}y))(xy))$ï¼‰ï¼Œä½¿ç”¨ $\\textbf{Y} $ ç»„åˆå­æ±‚è§£å‡ºçš„ $P$ æ²¡æœ‰ normal formï¼Œè¿™é‡Œä¸é‡‡ç”¨æ­¤ $P$ï¼Œæˆ‘ä»¬å°è¯•é€å±‚æ„é€ ä¸€ä¸ªå…·å¤‡ normal form çš„ $P$ ç»„åˆå­.\næ„é€ è¿‡ç¨‹ åŸºæœ¬ç»“æ„ ç”¨é«˜çº§è¯­è¨€çš„ä¼ªä»£ç è¡¨ç¤ºç°æœ‰çš„ $P$:\ncombinator p(x,y): // L1: define p if (xy == 0): return const(y) else: return p(x, Ïƒ y) // L5: call p é€’å½’çš„ $\\lambda $ï¼Œå½¢å¦‚ $P \\equiv \\lambda x. MPN $ï¼Œåƒè¿™æ ·çš„ $\\lambda$-termï¼Œç¬¦åˆæˆ‘ä»¬åœ¨é«˜çº§è¯­è¨€ç¨‹åºè®¾è®¡çš„ç»éªŒï¼Œä½†æ˜¯ä¸ç¬¦åˆ Lambda Calculus ä¸­çš„è§„èŒƒï¼Œå› ä¸º Lambda Calculus å¯¹ $\\lambda$-term çš„å½’çº³å®šä¹‰å¹¶ä¸åŒ…å«ä¸º abstraction èµ‹æ ‡è¯†ç¬¦çš„è§„åˆ™ï¼Œæˆ‘ä»¬å†™ $P$ ç­‰æ ‡è¯†ç¬¦çš„ç›®çš„åªåœ¨äºæå‡å¯è¯»æ€§å’Œæ˜ç¡®è¡¨è¾¾å¼ç»“æ„ï¼Œè€Œä¸æ˜¯å€ŸåŠ©æ ‡è¯†ç¬¦çš„å¤ç”¨æ¥åƒé«˜çº§è¯­è¨€ç¼–ç¨‹ä¸€æ ·å®šä¹‰é€’å½’å‡½æ•°. ä¸€ä¸ªç»†èŠ‚æ˜¯ï¼Œæˆ‘ä»¬åœ¨ä¹¦é‡Œçœ‹åˆ°çš„ä¸ºæŸä¸ª $\\lambda$-term è®°æ ‡è¯†ç¬¦ç”¨çš„ç¬¦å·æ˜¯ $\\equiv$ è€Œä¸æ˜¯ $=$.\næˆ‘ä»¬ä¸èƒ½é€šè¿‡æ ‡è¯†ç¬¦çš„å¤ç”¨å®šä¹‰é€’å½’ä¸æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½å®šä¹‰é€’å½’ï¼Œåªæ˜¯æˆ‘ä»¬éœ€è¦ä¾èµ–å¤šä¸€å±‚çš„æŠ½è±¡æ¥æ„é€ å‡º å½¢å¼ä¸Šçš„éé€’å½’ï¼Œäº‹å®æ„ä¹‰ä¸Šçš„é€’å½’.\nä»é«˜çº§è¯­è¨€ç¼–ç¨‹çš„è§’åº¦å‡ºå‘ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ç”¨æŸç§æ–¹å¼å–ä»£ L5 ä¸­å¯¹ p è‡ªèº«çš„è°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥å¦‚ä¸‹ä¿®æ”¹æˆ‘ä»¬çš„ä»£ç . ä¸ºäº†ä¸¤ä¸ªåˆ†æ”¯çš„ç»“æ„ä¸€è‡´ï¼Œæˆ‘ä»¬è®¾è®¡ä¸€ä¸ªå‡½æ•°åˆ—è¡¨ tï¼Œt ä¸­çš„ä¸¤ä¸ªå‡½æ•°å¯¹åº”ä¸¤ä¸ªåˆ†æ”¯ï¼Œå‡½æ•° getCurrentY å°†è¿”å›å½“å‰ y å€¼ï¼Œrecursion_p å°†æ‰¿æ‹…é€’å½’çš„å·¥ä½œï¼šï¼ˆè¿™é‡Œå…ˆä¸è€ƒè™‘å‡½æ•°çš„å…·ä½“ç»“æ„å’Œå‚æ•°è®¾è®¡/å‚æ•°ä¼ é€’çš„é—®é¢˜ï¼Œåé¢æ€»æœ‰åŠæ³•çš„ï¼Œè¿™é‡Œæˆ‘ä»¬åªå…³å¿ƒæ•´ä½“ç»“æ„ï¼‰\nt = [getCurrentY, recursion_p] // list of functions combinator p(x,y): if (xy == 0): return t[0] else: return t[1] å¦‚ä½•åœ¨ Lambda Calculus ä¸­è¡¨è¾¾ä»¥ä¸Šçš„ä»£ç ï¼Ÿä¸ºäº†ä¸“æ³¨äºæˆ‘ä»¬ç›®å‰å¤„ç†çš„æŠ½è±¡å±‚æ¬¡ï¼Œå…ˆå°† $P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$ çš„ç»“æ„ç®€åŒ–ä¸º $P \\equiv \\lambda xy.\\textbf{D}AB(xy)$\næ ¹æ®é¢„æœŸ / ä¸Šé¢çš„ä¼ªä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¤§è‡´çš„ $\\lambda $ æ¡†æ¶å¦‚ä¸‹:\n$$ P \\equiv \\lambda xy. T(xy)[params] $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda [params]. \\dots$$ $$ B \\equiv \\lambda [params]. \u0026hellip;$$\næ­¤æ—¶ $PXY = _{\\beta,w} T(XY) $ï¼Œ$ XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A; XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B $ .\næˆ‘ä»¬é¢„æœŸï¼šå°†åˆ†æ”¯çš„å…·ä½“é€»è¾‘æ”¾åœ¨ $T$ ä¸­ï¼Œå°†åˆ†æ”¯çš„é€‰æ‹©å’Œåˆ†æ”¯å‡½æ•°å‚æ•°ä¼ é€’æ”¾åœ¨ $P$ ä¸­.\nå…·ä½“ç»†èŠ‚ ä¸Šé¢æˆ‘ä»¬å¿½ç•¥äº†è®¸å¤šç»†èŠ‚ï¼Œç°åœ¨æ˜¯è€ƒè™‘ç»†èŠ‚çš„æ—¶å€™äº† :)\né¦–å…ˆæ³¨æ„ä¸€ä¸ªäº‹å®ï¼šæˆ‘ä»¬å°†åˆ†æ”¯å‡½æ•°å‚æ•°ä¼ é€’çš„å·¥ä½œæ”¾åœ¨ $P$ ä¸­ï¼Œæ„å‘³ç€æ— è®ºå½“å‰ $P$ ä¸­çš„ $(xy)$ å°†å¯¼å‘å“ªä¸ªåˆ†æ”¯ï¼Œæˆ‘ä»¬ä¼ é€’çš„å‚æ•°åˆ—è¡¨éƒ½æ˜¯ä¸€è‡´çš„ / éƒ½åªèƒ½æ˜¯ä¸€è‡´çš„. å› ä¸º $(xy) = _{\\beta,w}\\bar{0}$ å¯¹åº”çš„æƒ…å†µæ›´ç®€å•ï¼Œåªéœ€è¿”å›å½“å‰ $y$ï¼Œæ‰€ä»¥æˆ‘ä»¬å»¶åè€ƒè™‘è¿™ä¸€æƒ…å†µï¼Œå…ˆè€ƒè™‘ $(xy) â‰  _{\\beta,w}\\bar{0}$ çš„æƒ…å†µï¼Œè®©å‰è€…è¿å°±åè€…ï¼ˆï¼Œå› ä¸ºä¸¤ä¸ªåˆ†æ”¯éƒ½ä¸ $y$ æœ‰å…³ï¼Œæ‰€ä»¥å‚æ•°åˆ—è¡¨ä¸­å¿…ç„¶æœ‰ $y$ï¼Œåœ¨è¿™ä¸€ç‚¹ä¸Šä¸¤ä¸ªåˆ†æ”¯æ˜¯æœ‰å…±æ€§çš„ï¼›å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥ä¸¤ä¸ªåˆ†æ”¯å‡½æ•°å¯¹åº”çš„å‚æ•°å¹¶åˆ—ä¼ é€’ï¼Œç„¶ååœ¨ $A$,$B$ çš„å…·ä½“å®ç°ä¸­ ä¸å¯¹ä¸æœ¬åˆ†æ”¯æ— å…³çš„å‚æ•°è¿›è¡Œç»‘å®šï¼‰.\né€’å½’ï¼ˆè¿­ä»£ï¼‰åˆ†æ”¯çš„æ„é€  ç›®æ ‡æ˜¯ï¼š$XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B \\xlongequal{\\text{expected}} PX(\\bar{\\sigma}Y) $ï¼Œæˆ‘ä»¬å¸Œæœ›å‡½æ•° $B$ ä¸ $P$ ä¸­ä¼ é€’çš„ $[params]$ åº”ç”¨åå¾—åˆ°çš„ $\\lambda$-term å’Œ $PXY$ å…·å¤‡ä¸€æ ·çš„ç»“æ„ï¼ˆæ³¨æ„ä¸æ˜¯ $B$ å’Œ $P$ ä¸¤ä¸ª abstraction æœ¬èº«ç»“æ„ä¸€è‡´ï¼‰ï¼Œåªæ˜¯ $Y$ ä½ç½®çš„å€¼æ›¿æ¢æˆäº† $(\\bar{\\sigma}Y)$ï¼Œä¸ºäº†å¾—åˆ°å’Œ $P$ ä¸€æ ·çš„ç»“æ„ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯â€”â€”æŠŠ $P$ ç°æœ‰çš„ç»„ä»¶ä½œä¸º $[params]$ ä¼ é€’åˆ° $B$ï¼ˆï¼Œå½“ç„¶ä¹Ÿä¼ é€’åˆ°äº† $A$ï¼‰ï¼Œç„¶ååœ¨ $B$ ä¸­æŠŠè¿™äº›ç»„ä»¶é‡ç»„æˆ $P$ çš„ç»“æ„ï¼š\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(uv) $$\nï¼ˆ$ T \\mapsto t, x \\mapsto u, y \\mapsto v$ï¼‰\nç”±äº $[params]$ çš„ä¼ é€’ï¼Œç°åœ¨ $P$ çš„ç»“æ„å‘ç”Ÿäº†æ”¹å˜ï¼Œæˆ‘ä»¬éœ€è¦è®© $B$ ä¸æ–°çš„ $P$ ç»“æ„åŒæ­¥ï¼›å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ $B$ çš„å†…éƒ¨å°†ä¼ é€’è¿›æ¥çš„ $y$ ï¼ˆç”± $v$ ç»‘å®šï¼‰å˜ä¸º $\\bar{\\sigma}y$ï¼š\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\nåšä¸€ä¸ªæ£€æŸ¥ï¼šå½“ $XY \\neq _{\\beta, w} \\bar{0}$ï¼š\n$ \\quad PXY $ $ = _{\\beta,w} T(XY)TXY $ $ = _{\\beta,w} BTXY $ $ = _{\\beta,w} T(X(\\bar{\\sigma}Y))TX(\\bar{\\sigma}Y) $ $ = _{\\beta,w} PX(\\bar{\\sigma}Y) $ ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸï¼Œè‡³æ­¤ï¼Œè¿­ä»£åˆ†æ”¯çš„æ„é€ å°±å®Œæˆäº†.\nè¿­ä»£ç»ˆæ­¢åˆ†æ”¯çš„æ„é€  ç›®æ ‡æ˜¯ï¼š$XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A \\xlongequal{\\text{expected}} Y $ï¼Œåœ¨ $B$ çš„æ„é€ è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²æœ‰çš„å‚æ•°åˆ—è¡¨æ˜¯ $ t \\mapsto T, u \\mapsto x, v \\mapsto y$ï¼Œåœ¨ $A$ ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠ $y$ æå–å‡ºæ¥å³å¯ï¼Œæ‰€ä»¥ $A = \\lambda tuv.v$ ï¼Œå¦‚æœä½ å¸Œæœ›å’Œ Definition 4.8 çš„è®°æ³•ä¿æŒä¸€è‡´ï¼Œé‚£ä¹ˆ $A = \\Pi^3_3$.\nå®Œæ•´ $\\lambda$ $$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. v (= _{\\beta,w} \\Pi^3_3) $$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\nLCaC Theorem 4.20 ä¸­çš„ $P$ ç®€è¿° LCaC Theorem 4.20 ä¸­ç»™å‡ºçš„ $P$ å®šä¹‰å¦‚ä¸‹ï¼š\n$$ T \\equiv \\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v)) $$ $$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$\nä»¥ä¸å‰æ–‡ä¸€è‡´çš„æ ¼å¼è½¬å†™ï¼š\n$$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$ $$ T \\equiv \\lambda x.\\textbf{D}AB $$ $$ A \\equiv \\bar{0} $$ $$ B \\equiv \\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v) $$\nåœ¨ä¸€äº›æ—¶åˆ»æŠŠ $(Tx)$ ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè®©è¡¨è¾¾å¼æ›´ç®€æ´äº†ä¸€äº›ï¼ŒåŒæ—¶è®© $x$ å’Œ $T$ æœ‰ç»‘å®šå…³ç³»ï¼ˆ$T \\equiv \\lambda x\u0026hellip;.$ï¼‰ï¼Œåœ¨ $T$ çš„å†…éƒ¨ä¾ç„¶å¯ä»¥å•ç‹¬åœ°æ‹¿å‡º $x$ ä½¿ç”¨ï¼›$P$ ä¸­çš„ $(Tx)$ é—­åŒ…ï¼Œä½¿å¾—ä¼ å‚çš„å½¢æ€æ˜¯ $B(Tx)y$ â€”â€” è€Œä¸æ˜¯ $BTxy$ â€”â€”è®© $A$ çš„è®¾è®¡æ›´ç®€æ´äº†ï¼Œ$A \\equiv \\bar{0}$.\nè™½ç„¶åœ¨ç»†èŠ‚ä¸Šç•¥æœ‰å·®åˆ«ï¼Œä½†æ˜¯æ•´ä½“ç»“æ„ä¸æœ¬æ–‡ç»™å‡ºçš„ $P$ æ˜¯ä¸€è‡´çš„ï¼Œæˆ‘è§‰å¾—å¯èƒ½æ˜¯åŒ…å«ä¸€äº›ç›´è§‰ / çµæ„Ÿ / ä¼˜åŒ–ä¸Šçš„å·®å¼‚.\nå…¶ä»– å°è¯•ç€å±•å¼€ä¸Šé¢çš„ $P$:\n$$ \\lambda xy.\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x(xy)(\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x)y$$\nå¦‚æœä½ æ„¿æ„æŠŠä»¥ä¸‹ä¹Ÿå…¨éƒ¨å±•å¼€ï¼š $ \\textbf{D} = _{\\beta, w} \\lambda xyz.z(\\textbf{K}y)x, \\quad \\textbf{K} = _{\\beta, w} \\lambda xy.x $ $ \\bar{0} = _{\\beta, w} \\lambda xy.y $ $ \\bar{\\sigma} = _{\\beta, w} \\lambda nfz. f (n f z)$ $$ \\lambda xy.\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x(xy)(\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x)y$$\nå¯ä»¥è¯´ï¼Œæˆ‘ä»¬ç”¨è¿™ä¸€å †ç¬¦å· + Pure Lambda Culculus çš„æ¼”ç®—è§„åˆ™å®Œæˆäº†ä¸€ä¸ªè¿­ä»£ç¨‹åºçš„æ„é€ â€”â€”Programming in Pure Lambda Calculus.\n","date":"2024-09-17T23:48:00+08:00","permalink":"http://fyshxfish.github.io/p/the-construction-of-the-iteration-combinator-lcac-4c-theorem-4.20/","title":"The Construction of the Iteration Combinator - LCaC Â§ 4C, Theorem 4.20"},{"content":"From Types and Programming Languages Â§ 1.2 What Type Systems Are Good For\nA safe language is one that protects its own abstractions. A safe language is completely defined by its programmer\u0026rsquo;s manual.\nComplete abstraction means that users can fully trust the language design, focusing only on the high-level language abstraction layer, without needing to concern themselves with the specific implementation at the hardware level.\nHigh-level languages provide abstractions over physical devices. For example, arrays are abstractions over memory. Programmers expect that arrays can only be modified through explicit update operations (e.g., arr[1] = 1024). \u0026ldquo;Modifying a variable, and some elements in an array are inexplicably changed\u0026rdquo; (e.g., buffer overflow attacks) is a manifestation of broken abstraction. This means that programmers must have a detailed understanding of the layout of variables (abstractions provided by high-level languages) in memory (real physical devices) to write programs that meet expectations.\nThis reminds me of a series of experiments in CSAPP. Since the goal of CSAPP is to examine computer systems from the programmer\u0026rsquo;s perspective, i.e., viewing hardware from a software perspective, if the programming language used is safe, then we can fully trust the abstractions it provides. Consequently, we cannot see the hardware through the software. If C were safe, then the experiments in CSAPP couldn\u0026rsquo;t be done ğŸ§.\n","date":"2024-09-10T14:10:00+08:00","permalink":"http://fyshxfish.github.io/p/safety-abstraction/","title":"Safety \u0026 Abstraction"},{"content":"Motivation: Abstraction Level Up! å¯¹ 2 åº”ç”¨ $3$ æ¬¡ square\n1 ]=\u0026gt; (square (square (square 2))) ;Value: 256 2 â†’ x: å¯¹æŸä¸ªæ•° x åº”ç”¨ $3$ æ¬¡ square\n(define square3 (lambda (x) (square (square (square x))))) square â†’ f: å¯¹æŸä¸ªå€¼ x åº”ç”¨ $3$ æ¬¡æŸä¸ªå‡½æ•° f\n(define three_times_f (lambda (f x) (f (f (f x))))) $3 â†’ i$ : å¯¹æŸä¸ªå€¼ x åº”ç”¨ $i$ æ¬¡æŸä¸ªå‡½æ•° f $(i \\in \\mathbb{N})$\n$i=0$\n(define zero_time_f (lambda (f x) (x))) $i=1$\n(define one_time_f (lambda (f x) (f x))) $i=2$\n(define two_times_f (lambda (f x) (f (f x)))) é€’å½’å®šä¹‰ $i$ æ¬¡åº”ç”¨\né€’å½’åŸºï¼š\n(define zero_time_f (lambda (f x) (x))) é€’å½’æ­¥ï¼š\n(define (succ z) (lambda (f x) (f (z f x)))) é€’å½’æ±‚è§£ $i$ å¯¹åº”çš„ $i$ æ¬¡åº”ç”¨ï¼š\n(define (church i) (if (= i 0) zero_time_f (succ (church (- i 1))) ) ) è¿™å°±æ˜¯è‡ªç„¶æ•° $i$ å¯¹åº”çš„ Church Encoding.\nåœ¨ REPL ä¸­ç®€å•åšä¸€ä¸ªæµ‹è¯•ï¼šå¯¹ 3 åº”ç”¨ $2$ æ¬¡ cube $((3^3)^3=19683)$\n1 ]=\u0026gt; (church 2) ;Value: #[compound-procedure 15] 1 ]=\u0026gt; ( #[compound-procedure 15] cube 3) ;Value: 19683 ç†è§£ Church Encoding Church Encoding ä¸æ˜¯ï¼š\nå¯ä»¥è¢«å­˜å‚¨åœ¨ç‰©ç†å­˜å‚¨å™¨ä¸­çš„ï¼Œå¯ä»¥ç”¨ bit è¡¨ç¤ºçš„æ•°å­—\nä¸ºäº†ç®—æ•°è¿ç®—ï¼ˆç±»ä¼¼ $3.14 Ã— 2.17$ ï¼‰è€Œè®¾è®¡\nChurch Encoding æ˜¯ï¼š\nå¯¹ \u0026quot; è®¡æ•° \u0026quot; çš„æŠ½è±¡ Church Encoding æ˜¯å¯¹è®¡æ•°è¿‡ç¨‹çš„ä¸€ç§æŠ½è±¡ï¼Œåœ¨ Lambda Calculus çš„è¯­å¢ƒé‡Œï¼Œå½’çº³å®šä¹‰ $Î»-term$ çš„ä¸‰æ¡è§„åˆ™åˆ†åˆ«æ¶‰åŠäº† $atom$, $abstraction$, $application$ï¼ŒChurch Encoding å¯ä»¥ç†è§£ä¸ºï¼šæœ‰ä¸€ä¸ªèµ·å§‹çš„ $atom$ å’Œä¸€ä¸ª $abstraction$ ï¼Œæˆ‘ä»¬å¸Œæœ›å¯¹è¿™ä¸ª $atom$ è¿›è¡Œè‹¥å¹²æ¬¡ $abstraction$ çš„åº”ç”¨ï¼ˆ$apply$ï¼‰ï¼Œæˆ‘ä»¬ä½¿ç”¨æ›´é«˜ä¸€å±‚çš„ $abstraction$ æ¥æŠ½è±¡å¯¹ \u0026quot; è‹¥å¹²æ¬¡ \u0026quot; è¿›è¡Œè®¡æ•°çš„è¿‡ç¨‹ï¼Œè¿™ä¸€å±‚å¯¹äºè®¡æ•°è¿‡ç¨‹çš„æŠ½è±¡å°±æ˜¯ Church Encoding.\nChurch Encoding in Scheme $zeroï¼šÎ»f.Î»x.x$\nå¯¹æŸä¸ª $term$ è¿›è¡Œ $0$ æ¬¡ä»»æ„ $abstraction$ çš„åº”ç”¨ï¼Œè¿”å›å€¼ä¾ç„¶æ˜¯åŸæ¥çš„ $term$.\n(define zero (lambda (f x) x)) $oneï¼šÎ»f.Î»x.(fâ€‰x)$ $twoï¼šÎ»f.Î»x.(fâ€‰(fâ€‰x))$ $three: Î»f.Î»x.(fâ€‰(fâ€‰(fâ€‰x)))$\n(define one (lambda (f x) (f x))) (define two (lambda (f x) (f (f x)))) (define thr (lambda (f x) (f (f (f x))))) å†™åˆ° thr çš„æ—¶å€™æ³¨æ„åˆ°è¿™é‡Œçš„é€’å½’ç»“æ„ï¼Œé€’å½’åŸºæ¯«æ— ç–‘é—®æ˜¯ zeroï¼Œé€’å½’æ­¥ succ å¦‚ä¸‹ï¼š\n(define (succ z) (lambda (f x) (f (z f x))) ) åº”ç”¨ä¸¾ä¾‹ Church Encoding æ˜¯å¯¹è®¡æ•°çš„æŠ½è±¡ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›å¯¹ 2 è¿›è¡Œ 3 æ¬¡å¹³æ–¹ï¼ˆsquareï¼‰æ“ä½œï¼š $((2^2)^2)^2=256$\n1 ]=\u0026gt; (thr square 2) ;Value: 256 éªŒè¯ succ çš„æ­£ç¡®æ€§ï¼š\n1 ]=\u0026gt; (succ (succ (succ zero))) ;Value: #[compound-procedure 17] 1 ]=\u0026gt; (#[compound-procedure 17] square 2) ;Value: 256 å‚è€ƒèµ„æ–™ Church Encoding wiki\nTypes and Programming Languages, Chapter 5 The Untyped Lambda-Calculus\nä¸€åˆ™çŸ¥ä¹å›ç­”\n","date":"2024-09-08T20:13:00+08:00","permalink":"http://fyshxfish.github.io/p/church-encoding-note/","title":"Church Encoding Note"},{"content":"æœ¬æ–‡æ¦‚è¿° SICP Â§ 2.4.3 ä¸­æè¿°äº†ä»¥æŸ¥è¡¨ï¼ˆ type Ã— operation äºŒç»´è¡¨ï¼‰ä¸ºå®ç°æ–¹å¼çš„æ³›å‹ç³»ç»Ÿï¼Œå…·ä½“å‡½æ•°è¢«éšè—åœ¨æ³›å‹å‡½æ•° + Selector è¿™æ ·çš„æŠ½è±¡ä¹‹ä¸‹ï¼Œé‚£ä¹ˆå¦‚æœå°†å…·ä½“å‡½æ•°æ”¾åœ¨æ•°æ® + Selector è¿™æ ·çš„æŠ½è±¡ä¹‹ä¸‹æ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Œæœ¬æ–‡å‘ˆç°äº†ç¬¦åˆæ­¤æŠ½è±¡ï¼ˆSICP ä¸­ç§°ä¸º Message Passingï¼‰çš„ Boolean. æ¥ä¸‹æ¥ä» Message Passingï¼ŒHaskell ä¸­çš„ $ å’Œ Haskell ä¸­çš„ä»£æ•°æ•°æ®ç±»å‹ ä¸‰ä¸ªè§’åº¦èŠèŠæ•°æ®ä¸å‡½æ•°ä¹‹é—´çš„å…³ç³». Message Passing - è®©æ•°æ®è‡ªå·±æºå¸¦å‡½æ•°ï¼›Haskell $çš„åº”ç”¨ - å°†æ•°æ®å˜æˆæŸç§å‡½æ•°ï¼›Haskellä¸­çš„ä»£æ•°æ•°æ®ç±»å‹ - ä½¿ç”¨å‡½æ•°æ„é€ æ•°æ®.\næ³›å‹å‡½æ•°ï¼šIntelligent Operations åœ¨ 2.4.3 è¿™ä¸€èŠ‚ä¸­ï¼Œä½œè€…æ„å»ºäº†ä¸€ä¸ªæ³›å‹ç³»ç»Ÿï¼Œæ³›å‹æ˜¯ä»€ä¹ˆå‘¢ï¼Œæ˜¯ä¸€ç§æŠ½è±¡ï¼›å¯¹äºè‹¥å¹²ä¸ªå…·å¤‡æŸç§ç›¸åŒç‰¹æ€§çš„ç±»å‹ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥å¯¹äºå…¶ä¸­æŸä¸ªç±»å‹ï¼Œä¾èµ–è¿™ä¸ªç‰¹æ€§å†™ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¸Œæœ›å°†è¿™ä¸ªå‡½æ•°æ¨å¹¿åˆ°å…·å¤‡è¿™ä¸ªç‰¹æ€§çš„å…¶ä»–ç±»å‹ï¼Œä¾‹å¦‚ï¼šå¯¹äºä¸¤ä¸ª Int ç±»å‹çš„å€¼ï¼Œæˆ‘å¯ä»¥å¯¹å…¶æœ€å¤§å€¼è¿›è¡Œè®¡ç®—ï¼ˆmax Int Intï¼‰ï¼Œå› ä¸º Int æ˜¯å¯ä»¥æ¯”è¾ƒ (Orderable) çš„ï¼Œå³ï¼ŒInt ç±»å‹æä¾›äº† \u0026gt; / \u0026lt; / \u0026hellip; ç­‰æ¯”è¾ƒå‡½æ•°çš„å®ç°ï¼Œé‚£ä¹ˆï¼Œå¯¹äºå…¶ä»–å¯æ¯”çš„ï¼ˆæä¾›æ¯”è¾ƒå‡½æ•°å®ç°çš„ï¼‰ç±»å‹ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥å°† max æ¨å¹¿åˆ°è¿™äº›ç±»å‹ï¼š\nmax :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a max x y = if x \u0026gt;= y then x else y æˆ‘ä»¬å°†å¯æ¯”è¿™ä¸ªç‰¹æ€§æŠ½è±¡æˆ Ord ç±»å‹ç±»ï¼ˆtype classï¼‰ï¼Œmax å‡½æ•°å¯ä»¥ä½œç”¨äºä»»æ„è¯¥ç±»çš„æˆå‘˜ç±»å‹.\nå½“æˆ‘ä»¬åœ¨ä»»æ„ Ord ç±»çš„ç±»å‹ä¸Šåº”ç”¨ max å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬æ‰¾åˆ°å¯¹åº”ç±»å‹çš„ \u0026gt;= çš„å…·ä½“å®ç°.\né‚£ä¹ˆå¦‚ä½•æ‰¾åˆ°ï¼Ÿä¸€ç§ç­”æ¡ˆæ˜¯ï¼šæŸ¥è¡¨. å½“æˆ‘éœ€è¦å¯¹ Float (type) æ‰§è¡Œ max (operation) ï¼Œé‚£ä¹ˆæˆ‘åœ¨ type Ã— operation çš„ç¬›å¡å°”ç§¯ä¸­æ‰¾åˆ° (Float, max) å¯¹åº”çš„å‡½æ•° (ä¹Ÿå°±æ˜¯ Float å¯¹åº”çš„ max éæ³›å‹å…·ä½“å®ç°) å°±å¯ä»¥äº†.\nSICP Page 252: æ³›å‹å°±æ˜¯æŠŠ type Ã— operation è¿™å¼ è¡¨åˆ†è§£æˆä¸€è¡Œä¸€è¡Œçš„ï¼Œæ¯ä¸ªæ³›å‹å‡½æ•°ä»£è¡¨ä¸€è¡Œ. âœ¨\næ•°æ®ä¸å‡½æ•°çš„è¾¹ç•Œ Intelligent Operation? WHAT IF Intelligent Data Objects? åœ¨æœ¬æ–‡ä¸Šä¸€èŠ‚ä¸­æåˆ°çš„æ³›å‹ï¼ˆæ³›å‹å‡½æ•°ï¼‰ä¸­ï¼Œæ•°æ®ä½œä¸ºè¢«æ“ä½œçš„å®¢ä½“å­˜åœ¨ï¼Œæ•°æ®çš„å·¥ä½œå°±æ˜¯è¢«å‡½æ•°ä½œç”¨ï¼Œæˆ‘ä»¬çš„æ³›å‹é’ˆå¯¹çš„æ˜¯å‡½æ•°ï¼ˆoperationï¼‰ï¼Œåœ¨æˆ‘ä»¬çš„é¢„æœŸä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›å‡½æ•°æ˜¯èªæ˜çš„ï¼Œæ¯”å¦‚ max :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a æ˜¯èªæ˜çš„ï¼Œå¯¹äºå®ƒæ‰€ä½œç”¨çš„å…·ä½“ç±»å‹ï¼Œå®ƒå¯ä»¥\u0026quot;è‡ªåŠ¨\u0026quot;è½¬å˜æˆè¯¥ç±»å‹å¯¹åº”çš„éæ³›å‹å…·ä½“å®ç° max :: Int -\u0026gt; Int -\u0026gt; Int. è€Œæ•°æ®åªéœ€è¦ç­‰å¾…è¢«ä½œç”¨å°±å¯ä»¥äº†.\nğ–ğ¡ğšğ­ ğ¢ğŸ: è®©æ³›å‹å‡½æ•°æ‰¾åˆ°æ•°æ®å¯¹åº”çš„å…·ä½“å®ç° â†’ è®©æ•°æ®æ‰¾åˆ°å‡½æ•°å¯¹åº”çš„å…·ä½“å®ç°ï¼Ÿä»åˆ†è§£ type Ã— operation è¡¨çš„è§’åº¦è¯´ï¼Œå°†è¿™å¼ è¡¨åˆ†è§£æˆä¸€åˆ—ä¸€åˆ—çš„ï¼Œè®©æŸç§æ•°æ®ï¼ˆå¯¹åº”generic operationï¼Œæš‚ä¸”ç§°ä¹‹ä¸º generic? dataï¼‰ä»£è¡¨ä¸€åˆ—ï¼Œè¿™æ ·å¦‚ä½•å‘¢ï¼Ÿ\nåœ¨ SICP 2.1.3 ä¸­è°ˆåŠç»„åˆæ•°æ®çš„æå–æ—¶å¯¹æ­¤å°±æœ‰æ‰€å‘ˆç°ï¼Œæœ¬ç«™çš„ä¸Šä¸€ç¯‡åšå®¢ä¹Ÿæœ‰æåˆ°. åœ¨ SICP 2.1.3 ä¸­çš„ä¾§é‡ç‚¹åœ¨å¯¹ç»„åˆæ•°æ®æœ¬èº«çš„æ“ä½œï¼ˆæå–å­—æ®µï¼‰ä¸Šï¼šä¸ºäº†ä¿è¯åˆ—è¡¨å…ƒç´ å­˜å–å‰åçš„ä¸€è‡´æ€§ï¼Œæˆ‘ä»¬å°†åˆ—è¡¨å†™æˆä¸€ä¸ª procedure å‘å¤–æä¾›ï¼Œæ­¤ procedure æ¥æ”¶å‚æ•°ï¼Œå¹¶æ ¹æ®å‚æ•°è¿”å›å¯¹åº”çš„åˆ—è¡¨å…ƒç´ .\nè¿™é‡Œæˆ‘ä»¬å…³å¿ƒçš„æ˜¯æ•°æ®åœ¨ç¨‹åºä¸­çš„è¡Œä¸ºï¼Œå³ æ•°æ®å¦‚ä½•ä¸å‡½æ•°ã€å…¶ä»–æ•°æ®è¿›è¡Œäº¤äº’ï¼Œæˆ‘ä»¬å¸Œæœ›æ•°æ®è‡ªå·±æºå¸¦ä¸å…¶ä»–æ•°æ®çš„äº¤äº’æ–¹å¼ï¼Œè€Œä¸æ˜¯è®©æ•°æ®ä½œä¸ºåªèƒ½è¢«å…¶ä»–å‡½æ•°ä½œç”¨çš„é™æ€å®ä½“. åŸºäºè¿™æ ·çš„æƒ³æ³•ï¼Œå°è¯•ç€å†™ä¸€ä¸ªè¿™æ ·ç¬¦åˆè¿™æ ·çš„è¡Œä¸ºè§„èŒƒçš„ Boolean.\næºå¸¦å‡½æ•°çš„ Boolean é¦–å…ˆç»™å‡ºç±»ä¼¼çš„ type Ã— operation äºŒç»´è¡¨ï¼Œåªæ˜¯ç®€å•å»ºæ¨¡ï¼Œæ‰€ä»¥åªè€ƒè™‘ä¸ï¼ˆlogic_andï¼‰æˆ–ï¼ˆlogic_orï¼‰ä¸¤ç§è¿ç®—ï¼š\nç±»ä¼¼äºä»£è¡¨ä¸€è¡Œçš„æ³›å‹å‡½æ•°ï¼Œå†™ä¸€ä¸ªå¯ä»¥ä»£è¡¨ä¸€åˆ—çš„\u0026quot;æ•°æ®\u0026quot;ï¼ŒTRUE, FALSEåˆ—å¯¹åº”çš„æ ‡è¯†ç¬¦åˆ†åˆ«ä¸º tru, flsï¼Œå¦‚ä½•è®©æ•°æ®æºå¸¦å‡½æ•°ï¼Œä¸€ç§ç­”æ¡ˆæ˜¯ è®©æ•°æ®æœ¬èº«å°±æ˜¯ä¸€ä¸ªå¯ä»¥æ¥æ”¶å‚æ•°çš„å‡½æ•°ï¼Œç”±å‚æ•°æ¥æå–æ•°æ®æºå¸¦çš„å‡½æ•°ï¼š\n(define tru ; (define tru (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) tru_logic_and) ((eq? op \u0026#39;or) tru_logic_or) ) ) ) (define fls ; (define fls (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) fls_logic_and) ((eq? op \u0026#39;or) fls_logic_or) ) ) ) lambda - cond å¯¹åº”çš„å‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯æŸ¯é‡ŒåŒ–çš„é€»è¾‘ä¸æˆ–ï¼‰å®ç°å¦‚ä¸‹ï¼š\n(define (tru_logic_and x) (if (eq? x tru) tru fls)) ; 1 AND x (define (tru_logic_or x) tru) ; 1 OR _ = 1 (define (fls_logic_and x) fls) ; 0 AND _ = 0 (define (fls_logic_or x) (if (eq? x tru) tru fls)) ; 0 OR x åœ¨ REPL ä¸­æŸ¥çœ‹ tru flsï¼šæ¯«æ— ç–‘é—®ä¸¤è€…éƒ½æ˜¯ compound procedure\n1 ]=\u0026gt; tru ;Value: #[compound-procedure 13 tru] 1 ]=\u0026gt; fls ;Value: #[compound-procedure 12 fls] åšä¸€ä¸ªç®€å•çš„æµ‹è¯•ï¼š\n1 ]=\u0026gt; ((tru \u0026#39;and) fls) ;Value: #[compound-procedure 12 fls] è¿™é‡Œæˆ‘ä»¬åšäº†ä»€ä¹ˆäº‹æƒ…å‘¢ï¼Ÿé¦–å…ˆ tru æ˜¯æ¥æ”¶ç¬¦å·å‚æ•°çš„ä¸€ä¸ª lambda è¡¨è¾¾å¼ï¼Œ(tru 'and) å¾—åˆ°çš„æ˜¯ tru_logic_and â€”â€” ä¸€ä¸ªæŸ¯é‡ŒåŒ–çš„é€»è¾‘ä¸ï¼ˆä¹Ÿå°±æ˜¯å·²ç»ä¼ å…¥äº†ä¸€ä¸ª TRUE çš„é€»è¾‘ä¸ï¼‰ï¼Œç„¶åå°† tru_logic_and åº”ç”¨äº fls ï¼Œæœ€åçš„è¿”å›å€¼æ˜¯ compound procedure fls.\nç»™å‡ºå›¾ç¤ºå¦‚ä¸‹ï¼š\nå¦‚æœè¡¨è¾¾å¼é•¿ä¸€äº›ï¼šå¦‚æœå¿½ç•¥ä¸€éƒ¨åˆ†æ‹¬å·ï¼Œçœ‹èµ·æ¥å°±æ˜¯ä¸­ç¼€çš„é€»è¾‘è¡¨è¾¾å¼\n1 ]=\u0026gt; ((((fls \u0026#39;or) tru) \u0026#39;and) fls) ; ((0 or 1) and 0) ;Value: #[compound-procedure 12 fls] å¦‚æœæ›´åå¥½å‰ç¼€è°ƒç”¨ï¼Œå¯ä»¥åšä¸€å±‚å°å°è£…ï¼š\n(define (logic op x y) ((x op) y)) å¯¹ logic è¿›è¡Œæµ‹è¯•ï¼š\n1 ]=\u0026gt; (logic \u0026#39;and tru fls) ;Value: #[compound-procedure 12 fls] 1 ]=\u0026gt; (logic \u0026#39;or (logic \u0026#39;and fls fls) tru) ; (or (and 0 0) 1) ;Value: #[compound-procedure 13 tru] â†’ Message Passing: çœ‹å¾…æ•°æ®çš„å¦ä¸€ç§è§†è§’ ä¸Šé¢è¿™ç§æ„å»º Boolean çš„ç¼–ç¨‹é£æ ¼è¢«ç§°ä¸º Message Passingï¼šä¸€ä¸ªæ•°æ®æ˜¯ä¸€ä¸ªæ¥æ”¶æ“ä½œåï¼ˆmessageï¼‰çš„å®ä½“ï¼Œä¾‹å¦‚ï¼štru å¯ä»¥æ¥æ”¶ 'and / 'or è¿™æ ·çš„ Message å¹¶è¿”å›å¯¹åº”çš„æŸ¯é‡ŒåŒ–å‡½æ•°ä¾›æˆ‘ä»¬åç»­ä½¿ç”¨. åœ¨è¿™æ ·çš„è§†è§’ä¸‹ï¼Œæ•°æ®æœ¬èº«å’Œæ•°æ®æ‰€æºå¸¦çš„æ–¹æ³•ä¸€æ ·é‡è¦ï¼Œä¹Ÿæ˜¯\u0026quot;æ•°æ®å³ç¨‹åº\u0026quot;çš„ä¸€ç§ä½“ç°. ä¸çŸ¥é“çœ‹åˆ°è¿™é‡Œçš„ä½ æ˜¯å¦ä¹Ÿåœ¨æ­¤å¤„å¯Ÿè§‰åˆ°äº†ä¸€äº›é¢å‘å¯¹è±¡çš„é£å‘³.\nHaskell ä¸­çš„ $ $ æ˜¯ä¸€ä¸ªä¸­ç¼€è°ƒç”¨çš„å‡½æ•°ï¼Œå…¶ç±»å‹ç­¾åå’Œä¼˜å…ˆçº§å¦‚ä¸‹ï¼Œå®ƒçš„ä½œç”¨æ˜¯æ”¹å˜è¡¨è¾¾å¼æ±‚å€¼é¡ºåºï¼Œä¸€ä¸ªå®¢è§‚ç»“æœæ˜¯ $ çš„ä½¿ç”¨å‡å°‘äº†ä»£ç ä¸­çš„æ‹¬å·é‡ï¼Œ\nghci\u0026gt; :i ($) ($) :: (a -\u0026gt; b) -\u0026gt; a -\u0026gt; b -- Defined in â€˜GHC.Baseâ€™ infixr 0 $ å°† $ ï¼ˆæŸ¯é‡ŒåŒ–ï¼‰åº”ç”¨äºä¸€ä¸ªå€¼ï¼Œè¿”å›å€¼æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š\nghci\u0026gt; x = 5 :: Int ghci\u0026gt; :t ($ x) ($ x) :: (Int -\u0026gt; b) -\u0026gt; b ä¸€ç§ç†è§£æ˜¯ï¼š($ x) æŠŠ x ä»é™æ€æ•°æ®ï¼Œå˜æˆäº†ä¸€ä¸ªç­‰å¾…è¢«å‡½æ•° Int -\u0026gt; b ä½œç”¨çš„æ•°æ®ï¼ˆä»ç±»å‹ç­¾åä¸Šçœ‹ï¼Œè¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼‰. åŸºäºè¿™ç§ç†è§£ï¼Œå¯ä»¥å†™è¿™æ ·çš„ä»£ç ï¼š\nghci\u0026gt; map ($ 5) [(* 2), (+ 10), (^ 3)] [10,15,125] Haskell ä¸­çš„ä»£æ•°æ•°æ®ç±»å‹ ç»å…¸çš„ä»£æ•°æ•°æ®ç±»å‹å¯¹äºŒå‰æ ‘è¿›è¡Œé€’å½’å®šä¹‰ï¼š\ndata Tree a = Empty | Node a (Tree a) (Tree a) Empty å’Œ Node æ˜¯ Tree a çš„å€¼æ„é€ å­ï¼Œå€¼æ„é€ å­å°±æ˜¯è¿”å›æŸç§ç±»å‹çš„å€¼çš„å‡½æ•°. Empty æ˜¯æ— å‚æ„é€ å­ï¼ŒNode æ¥å— aï¼ŒTree aï¼ŒTree aä¸‰ä¸ªå€¼å‚æ•°.\nTree a æ˜¯ç±»å‹æ„é€ å­ï¼Œç±»å‹æ„é€ å­æ˜¯è¿”å›æŸç§å…·ä½“ç±»å‹çš„å‡½æ•°ï¼ŒTree a æ¥å— a ä¸€ä¸ªç±»å‹å‚æ•°ï¼Œè¿”å›ç›¸åº”çš„å…·ä½“çš„ Tree ç±»å‹. ä¾‹å¦‚ Tree Intï¼ŒTree Char åˆ†åˆ«æ˜¯ç»“ç‚¹æ•°æ®ç±»å‹ä¸º Int, Char çš„ Tree.\nè¿™é‡Œå¯ä»¥çœ‹å‡º Haskell éå¸¸æ¼‚äº®çš„è¯­è¨€è®¾è®¡ä¸Šçš„ä¸€è‡´æ€§ï¼Œæ²¡æœ‰ç‰¹æ®Šçš„æ³›å‹è¯­æ³•ï¼Œåªæœ‰å‡½æ•°è´¯ç©¿å§‹ç»ˆ.\n","date":"2024-09-07T23:18:00+08:00","permalink":"http://fyshxfish.github.io/p/boolean-from-a-message-passing-perspective-sicp-2.4.3-generics-boundaries-of-data-and-functions/","title":"Boolean from a Message Passing Perspective - SICP Â§ 2.4.3 | Generics | Boundaries of Data and Functions"},{"content":"åœ¨çœ‹ SICP Section 2.3.4ï¼Œå¯¹è¿™èŠ‚ä¸­ Huffman æ ‘çš„å®ç°ä¸­ä½¿ç”¨çš„ç»„åˆ / æŠ½è±¡æœ‰ç›¸å½“ç¨‹åº¦çš„å‚è€ƒ.\nå…¶å®æˆ‘åº”è¯¥æŠŠä»£ç æ”¾åœ¨æŸä¸ªä»“åº“é‡Œï¼Œæ¯”å¦‚æŠŠä¸€äº›æ•°æ®ç»“æ„çš„ Haskell å®ç°æ•´åˆåœ¨ä¸€ä¸ªä»“åº“é‡Œï¼Œä½†æ˜¯æˆ‘è¿˜æ²¡æœ‰è¿™ä¹ˆå¤šå¯ä¾›æ•´åˆçš„ææ–™ï¼Œæ‰€ä»¥ä»¥åå†è¯´å§.\nä»£ç é“¾æ¥ï¼šHuffman Tree in Haskell\nHuffman æ ‘çš„ Haskell å®ç° æ•°æ®æŠ½è±¡ type Weight = Int data Symbol = A | B | C | D | E | F | G | H deriving Show data HuffmanTree a = Empty | Leaf a Weight | Node (HuffmanTree a) (HuffmanTree a) [a] Weight deriving Show Symbol + Weight â†’ Leaf è®¾å®šå¯¹ç¬¦å· (Symbol / æ³›å‹ a) æ ¹æ®ä½¿ç”¨é¢‘ç‡/æƒé‡ (Weight) è¿›è¡Œ Huffman ç¼–ç ï¼Œå°†è¿™ä¸¤ä¸ªä¿¡æ¯æ•´åˆæŠ½è±¡æˆ Leafï¼Œå¯¹åº” SICP ä¸­çš„ ((define (make-leaf symbol weight) (list 'leaf symbol weight))).\næ³›å‹ä¸ç±»å‹çº¦æŸï¼šå¯¹ç¬¦å·æ²¡æœ‰ç±»å‹çº¦æŸï¼Œå¯¹æƒé‡çš„çº¦æŸæ˜¯ Weight å±äº Ord typeclassï¼Œå› ä¸ºéœ€è¦æƒé‡æ˜¯å¯ä»¥æ¯”è¾ƒçš„ï¼Œè¿™é‡Œæ²¡æœ‰å†™æ³›å‹ï¼Œç›´æ¥ç”¨ Int ä½œä¸ºæƒé‡çš„ç±»å‹ .\nHuffmanTree çš„é€’å½’å®šä¹‰ å« Empty, Leaf, Node ä¸‰ç§æ„é€ å­:\nEmpty: ç©ºæ ‘\nLeaf: åŒ…å«ç¬¦å· a å’Œæƒé‡ Weight çš„å¶å­ç»“ç‚¹\nNode: åŒ…å«å·¦å³å­æ ‘ (HuffmanTree a)ã€å­æ ‘ç¬¦å·å¹¶é›† [a] å’Œå­æ ‘æ€»æƒé‡ Weight çš„åˆ†æ”¯ç»“ç‚¹.\nHuffman æ ‘çš„æ„å»º æƒé‡è·å– é€šè¿‡æ¨¡å¼åŒ¹é…è·å– Leafï¼ŒNodeçš„æƒé‡.\nè¿™é‡Œæ²¡æœ‰è€ƒè™‘ç©ºæ ‘ Empty çš„æƒ…å†µï¼Œå¦‚æœè€ƒè™‘åº”è¯¥å†™ getWeight :: HuffmanTree a -\u0026gt; Maybe Weightï¼ŒåŒ¹é…åˆ° Empty æ—¶è¿”å› Nothing. å¯¹ä¸€ç§ç±»å‹åšæ¨¡å¼åŒ¹é…æ—¶åº”è¯¥åŒ¹é…åˆ°æ¯ä¸€ä¸ªæ„é€ å­ï¼Œè¿™æ˜¯æ ‡å‡†çš„å®è·µ.\ngetWeight :: HuffmanTree a -\u0026gt; Weight getWeight (Leaf _ w) = w getWeight (Node _ _ _ w) = w åˆ—è¡¨æ•´ç† Huffman æ ‘å»ºç«‹çš„èµ·ç‚¹æ˜¯ä¸€ä¸ªæœ‰åºçš„å¶å­åˆ—è¡¨ï¼Œå»ºç«‹è¿‡ç¨‹ä¸­ä¹Ÿéœ€è¦ä¿æŒ [HuffmanTree a] åˆ—è¡¨çš„æœ‰åº. è¿™ä¸€éƒ¨åˆ†çš„å‡½æ•°çš„ç›®æ ‡æ˜¯å°†ä¸€ä¸ªæ— åºçš„åˆ—è¡¨æ•´ç†æˆä¸€ä¸ªæœ‰åºçš„åˆ—è¡¨.\nÂ» adjoinLeaf: æ ¹æ®æƒé‡å°† HuffmanTree a æ’å…¥åˆ°å·²æœ‰çš„æœ‰åº [HuffmanTree a] ä¸­. ï¼ˆå‡åºæ’åˆ—ï¼‰\nÂ» initLeafs: å°†å·²æœ‰çš„æ— åºå¶å­åˆ—è¡¨æ•´ç†æˆæœ‰åºçš„å¶å­åˆ—è¡¨.\nÂ» moveFirstNode: Huffman Tree å»ºç«‹è¿‡ç¨‹ä¸­çš„ Merge æ“ä½œå°†æŠŠæƒé‡æœ€å°çš„ä¸¤ä¸ª HuffmanTree (Leaf / Node) â€”â€”ä¹Ÿå°±æ˜¯åˆ—è¡¨å‰ä¸¤ä¸ªå…ƒç´ â€”â€”ç»„æˆä¸€ä¸ªæ–°çš„ Nodeï¼Œæ‰€ä»¥ Merge åéœ€è¦å°†æ–°ç”Ÿæˆçš„ Node é‡æ–°æ”¾ç½®ï¼Œåˆ©ç”¨æ­¤å‡½æ•°å®ç°è¿™ä¸ªé‡ç½®.\nadjoinTree :: HuffmanTree a -\u0026gt; [HuffmanTree a] -\u0026gt; [HuffmanTree a] adjoinTree t [] = [t] adjoinTree t (t\u0026#39;:ts) | w \u0026lt; w\u0026#39; = t: t\u0026#39;: ts | otherwise = t\u0026#39;: (adjoinTree t ts) where w = getWeight t w\u0026#39; = getWeight t\u0026#39; initLeafs :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] -- I know pl(leaf) = leaves, btw. ^^ initLeafs [] = [] initLeafs (p:ps) =adjoinLeaf p (initLeafs ps) moveFirstNode :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] moveFirstNode (t:ts) =adjoinLeaf t ts æ ‘çš„å»ºç«‹ Â» makeNode: å°†ä¸¤ä¸ª HuffmanTree ç»„åˆæˆä¸€ä¸ª Node.\nÂ» constructHuffTree: æ ‘çš„è‡ªåº•å‘ä¸Šå»ºç«‹ï¼Œå°¾é€’å½’å»ºç«‹ Huffman Tree.\né€’å½’æ­¥ï¼šå°†å½“å‰åˆ—è¡¨ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ é€šè¿‡ makeNode åˆå¹¶æˆä¸€ä¸ªçˆ¶ç»“ç‚¹ Nodeï¼Œç§»åŠ¨çˆ¶ç»“ç‚¹å¾—åˆ°æ–°çš„æœ‰åºåˆ—è¡¨ï¼Œå¯¹æ–°åˆ—è¡¨æ‰§è¡Œé€’å½’;\né€’å½’åŸºï¼šåˆ—è¡¨ä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œå³æ ¹ç»“ç‚¹.\nÂ» initAndConstructHuffTree: æœ€åçš„å°è£…ï¼Œå¯¹å¶å­åˆ—è¡¨çš„åˆå§‹åŒ– initLeafs å’Œæ ‘çš„å»ºç«‹ constructHuffTree è¿›è¡Œ Point-less çš„ç»„åˆ.\nmakeNode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; HuffmanTree a makeNode (Leaf s1 w1) (Leaf s2 w2) = Node (Leaf s1 w1) (Leaf s2 w2) [s1, s2] (w1 + w2) makeNode (Leaf s w) (Node l r ss w\u0026#39;) = Node (Leaf s w) (Node l r ss w\u0026#39;) (s:ss) (w + w\u0026#39;) makeNode (Node l r ss w\u0026#39;) (Leaf s w) = Node (Node l r ss w\u0026#39;) (Leaf s w) (ss ++ [s]) (w + w\u0026#39;) makeNode (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) = Node (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) (ss1 ++ ss2) (w1 + w2) constructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = Empty constructHuffTree [t] = t constructHuffTree (x:y:ts) = constructHuffTree $ moveFirstNode $ (makeNode x y): ts initAndConstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a initAndConstructHuffTree = constructHuffTree . initLeafs Huffman æ ‘çš„ç¼–è§£ç  è·å–ç¬¦å·ç¼–ç  Huffman æ ‘çš„å»ºç«‹è¿‡ç¨‹å°±æ˜¯ç¼–ç è¿‡ç¨‹ï¼Œè¿™é‡Œåªæ˜¯å°†ç¼–ç ç”¨å¦ä¸€ç§å½¢å¼å‘ˆç°å‡ºæ¥.\næ­¤å¤„çš„ç¼–ç è¡¨ç¤ºï¼š\ndata Bit = L | R deriving Show type Bits = [Bit] L å¯¹åº”äºŒè¿›åˆ¶ 0ï¼ŒR å¯¹åº”äºŒè¿›åˆ¶ 1.\nç¼–ç çš„è·å–è¿‡ç¨‹å°±æ˜¯å¯¹ Huffman æ ‘è¿›è¡Œéå†ä¸è®°å½•çš„è¿‡ç¨‹ï¼š\ngetCode\u0026#39; :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [(a, Bits)] getCode\u0026#39; (Node (Leaf s1 _) (Leaf s2 _) _ _) rec = [(s1, rec ++ [L]), (s2, rec ++ [R])] getCode\u0026#39; (Node (Leaf s\u0026#39; _) node _ _) rec = [(s\u0026#39;, rec ++ [L])] ++ getCode\u0026#39; node (rec++[R]) getCode\u0026#39; (Node node (Leaf s\u0026#39; _) _ _) rec = getCode\u0026#39; node (rec++[L]) ++ [(s\u0026#39;, rec ++ [R])] getCode\u0026#39; (Node nodel noder _ _) rec = getCode\u0026#39; nodel (rec++[L]) ++ getCode\u0026#39; noder (rec++[R]) getCode :: HuffmanTree a -\u0026gt; [(a, Bits)] getCode t = getCode\u0026#39; t [] Â» getCode'ï¼šå®ç°å¯¹ Huffman æ ‘çš„é€’å½’éå†\né€’å½’æ­¥ï¼šå¯¹äºä¸€ä¸ªç»“ç‚¹ï¼Œå¯¹å·¦å³å­æ ‘è¿›è¡ŒåŒ¹é…ï¼Œå¯¹éå¶ç»“ç‚¹ï¼ˆnodeï¼‰ç»§ç»­é€’å½’éå†ï¼Œåœ¨ rec ä¸­è®°å½•é€”å¾„çš„åˆ†å‰æ–¹å‘.\né€’å½’åŸºï¼šå½“å¯¹å·¦/å³å­æ ‘åŒ¹é…åˆ° Leaf æ—¶ï¼Œè¡¨æ˜å·²ç»æŠµè¾¾äº†ä¸€ä¸ª Symbolï¼Œæ­¤æ—¶çš„ rec ++ [L] / rec ++ [R] å°±æ˜¯ Symbol å¯¹åº”çš„ç¼–ç .\næ¨¡å¼åŒ¹é…çš„è§£é‡Šï¼šå›é¡¾ Huffman æ ‘çš„æ„é€ è¿‡ç¨‹ï¼Œæˆ‘ä»¬æ€»æ˜¯æŠŠä¸¤ä¸ªç»“ç‚¹åˆå¹¶æˆå…¶çˆ¶ç»“ç‚¹ï¼Œæ‰€ä»¥ä¸å­˜åœ¨æŸä¸ªå­æ ‘ä¸º Empty çš„æƒ…å†µï¼Œä¹Ÿå³â€”â€”æ¯ä¸ªåˆ†æ”¯ç»“ç‚¹çš„æ¨¡å¼éƒ½æ˜¯ Node lhs rhs _ _ï¼›åŒæ—¶ï¼Œæˆ‘ä»¬å°† Leaf ä½œä¸ºé€’å½’åŸºï¼Œä¸å†å¯¹ Leaf åšé€’å½’ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆè¿™é‡Œåªå¯¹ä¸åŒå½¢æ€çš„ Node æ„é€ å­åšæ¨¡å¼åŒ¹é…ï¼Œå¹¶æŠŠå« Leaf é€’å½’åŸºçš„æƒ…å½¢æ”¾åœ¨å‰é¢çš„åŸå› .\nÂ» getCodeï¼šå¯¹ getCode' åšä¸€ä¸ªå°è£…ï¼Œç»™ rec ä¸€ä¸ªèµ·å§‹å€¼ []ï¼Œå³ åœ¨ Huffman æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ²¡æœ‰ä»»ä½•é€”å¾„è®°å½•.\nè§£ç  åŸºæœ¬æ€è·¯ï¼šæ ¹æ® Bit åœ¨æ ‘ä¸Šç§»åŠ¨ï¼ŒL - å‘å·¦å­æ ‘ç§»åŠ¨ï¼ŒR - å‘å³å­æ ‘ç§»åŠ¨ï¼ŒæŠµè¾¾å­æ ‘ä¸º Leaf æ—¶ï¼Œå®Œæˆä¸€ä¸ªå­—ç¬¦çš„è§£ç ï¼Œæ­¤æ—¶å›åˆ°æ ¹èŠ‚ç‚¹ç»§ç»­å¯¹ä¸‹ä¸€ä¸ªå­—ç¬¦è§£ç ï¼Œç›´åˆ° Bit åˆ—è¡¨ä¸ºç©º.\n-- decode one symbol decodeOne :: HuffmanTree a -\u0026gt; Bits -\u0026gt; (a, Bits) decodeOne (Node (Leaf s _) _ _ _) (L:bs) = (s, bs) decodeOne (Node _ (Leaf s _) _ _) (R:bs) = (s, bs) decodeOne (Node node _ _ _) (L:bs) = decodeOne node bs decodeOne (Node _ node _ _) (R:bs) = decodeOne node bs -- decode from scratch decode :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode _ [] = [] decode t bs = let (s, remainBits) = decodeOne t bs in s: decode t remainBits Â» decodeOne:\né€’å½’åŸºï¼šå½“å‰ Bit å¯¹åº”çš„å­æ ‘ä¸º Leaf ï¼Œå³å®Œæˆäº†ä¸€ä¸ªå­—ç¬¦çš„è§£ç ï¼Œå°†è¯¥å­—ç¬¦å’Œå‰©ä½™çš„ Bit è¿”å›\né€’å½’æ­¥ï¼šå½“å‰ Bit å¯¹åº”çš„å­æ ‘ä¸º Node ï¼Œç»§ç»­åœ¨è¯¥ Node ä¸Šé€’å½’è§£ç ï¼Œç›´åˆ°é‡åˆ°é€’å½’åŸºçš„æƒ…å†µ\nÂ» decode:\né€’å½’åŸºï¼šBit åˆ—è¡¨ä¸ºç©ºï¼Œä»£è¡¨è§£ç å®Œæ¯•.\né€’å½’æ­¥ï¼šBit åˆ—è¡¨éç©ºï¼Œå°†æ ¹ç»“ç‚¹å’Œå½“å‰ Bit åˆ—è¡¨äº¤ç»™ decodeOne è¿›è¡Œå•å­—ç¬¦çš„è§£ç ï¼Œå•å­—ç¬¦è§£ç å®Œæ¯•åï¼Œç»§ç»­å¯¹å‰©ä½™çš„ Bit åœ¨æ ¹èŠ‚ç‚¹ä¸Šåšå•å­—ç¬¦è§£ç ï¼Œç›´åˆ° Bit åˆ—è¡¨ç©º.\nÂ» å¦‚ä½•å›åˆ°æ ¹èŠ‚ç‚¹ï¼š\nä¸€å¼€å§‹å†™çš„å‡½æ•°ç±»å‹ç­¾åæ˜¯è¿™æ ·çš„ decode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a]ï¼Œä¸¤ä¸ª HuffmanTree åˆ†åˆ«æ˜¯åŸå§‹æ ¹èŠ‚ç‚¹å’Œå½“å‰æ‰€åœ¨çš„æ ¹èŠ‚ç‚¹ï¼Œå®ç°å¤§è‡´å¦‚ä¸‹ï¼š\ndecode\u0026#39; :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode\u0026#39; originT (Node (Leaf s _) _ _ _) (L:bs) = s: (decode\u0026#39; originT originT bs) --snip-- çœ‹ç€ä¸æ˜¯å¾ˆèˆ’æœï¼Œå› ä¸º originT è¿™ä¸ªå‚æ•°åœ¨é€’å½’è¿‡ç¨‹ä¸­æ²¡æœ‰å˜è¿‡ï¼Œæ‰€ä»¥ç¨ç¨æ”¹å˜äº†é€’å½’ç»“æ„ï¼Œå†™äº†ä¸Šé¢çš„ decode å’Œ decodeOne. SICP ä¸­ä½¿ç”¨é—­åŒ…æ¥è®°å¿†åˆå§‹æ ¹èŠ‚ç‚¹.\nç»„åˆæ•°æ® (compound data) çš„ç»“æ„ä¸è§£æ„ (construct / extract) SICP (Scheme): Blur the Barrier of Data and Procedure / abstraction barrier ä¸€è‡´æ€§ æˆ‘ä»¬å¸Œæœ›å°†æœ‰ç»“æ„çš„æ•°æ®â€”â€”è€Œä¸æ˜¯æ•£è½çš„å˜é‡â€”â€”ä½œä¸ºç¨‹åºçš„ç»„ä»¶ï¼Œæ‰€ä»¥æœ‰äº†ç»„åˆæ•°æ® (compound data)ï¼Œæ¯”å¦‚ struct / classï¼Œäºæ˜¯å‡ºç°çš„é—®é¢˜æ˜¯ï¼Œå¦‚ä½•æŠŠç”¨äºæ„é€  compound data çš„å­—æ®µé‡æ–°æå–å‡ºæ¥ï¼Œæå–çš„è¡Œä¸ºéœ€è¦ä¿è¯çš„ä¸€ä»¶äº‹æƒ…æ˜¯ï¼šå­—æ®µè¢«æå–å‰åè¡Œä¸ºæ˜¯ä¸€è‡´çš„ï¼Œä¸»è¦æ˜¯ç¼–è¯‘å™¨çš„å·¥ä½œï¼Œå¦‚æœä¸€å®šè¦åœ¨æºä»£ç çš„å±‚é¢ä¸Šå»ä½“ç°è¿™ä¸€ç‚¹ï¼Œå¦‚ä½•åšåˆ°ï¼Ÿåœ¨æ­¤å¤„è´´ SICP 2.1.3 (Page 124) çš„ç¤ºä¾‹ä»£ç ï¼š\n(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \u0026#34;Argument not 0 or 1: CONS\u0026#34; m)))) dispatch) (define (car z) (z 0)) (define (cdr z) (z 1)) Exercise 2.4 (Page 125) ä¸­çš„é€šè¿‡ lambda å®ç°ä¹Ÿå¾ˆæ¼‚äº®ï¼š\n(define (cons x y) (lambda (m) (m x y))) (define (car z) (z (lambda (p q) p))) ï¼ˆç”¨ Pure Lambda Calculus å®ç°æ­¤ä¾‹ï¼Œå‚è§æœ¬èŠ‚çš„æœ€åä¸€å°èŠ‚.ï¼‰\nSICP è¿™ä¸€ç« é‡ç‚¹å‘ˆç°çš„ä¸€ä¸ªç‚¹æ˜¯: æ•°æ®ï¼ˆdataï¼‰ä¸ç¨‹åºï¼ˆprocedureï¼‰çš„åˆ†ç•Œçº¿å¹¶ä¸æ˜¯é‚£ä¹ˆæ³¾æ¸­åˆ†æ˜çš„. ä»¥ä¸Šçš„ä¸¤ä¸ªç¨‹åºå¾ˆå‡†ç¡®åœ°ä½“ç°äº†è¿™ä¸€ç‚¹ï¼šåˆ—è¡¨çš„æ„é€ å­è¿”å›çš„æ˜¯ä¸€ä¸ª procedureï¼Œè¯¥ procedure æä¾›äº†è®¿é—®ç»„æˆåˆ—è¡¨çš„å…ƒç´ çš„æ¥å£ï¼Œæ‰€ä»¥å¯ä»¥åŸºäºæ­¤å®šä¹‰ car/ cdr.\næ•°æ®çš„ç»„åˆä¸æå– â†’ ç¨‹åºçš„æ„é€ ï¼šæŠ½è±¡å±‚ ç»„åˆè¿™ä»¶äº‹æƒ…åœ¨ LISP (LISt Programming) ä¸­æ˜¯ç®€æ´çš„ï¼Œæ•°æ®çš„ç»„åˆæ–¹å¼å°±æ˜¯æ„é€ åˆ—è¡¨ï¼Œå¦‚ (list 1 2 3) / (list 3 4 (list 9 7) 5).\nè€Œå¤„äºç¨‹åºä¹‹ä¸­çš„æ•°æ®ä¸å¯èƒ½ç›´æ¥ä»¥è¿™æ ·çš„å½¢å¼åœ¨å‡½æ•°ä¹‹é—´æµè½¬ï¼Œæ‰€ä»¥æœ‰äº†æŠ½è±¡å±‚:\nconstructor (make-rat) å’Œ selector (denom, numer) æ˜¯ä»åŸºæœ¬ç±»å‹ (primitive data type) åˆ°ç»„åˆæ•°æ® (compound data) çš„ä¸€æ¬¡æŠ½è±¡ï¼Œç»™äº†ç¨‹åºï¼ˆåœ¨æ­¤æŠ½è±¡å±‚ä¹‹ä¸Šçš„å‡½æ•°ï¼Œadd-rat / sub-ratï¼‰ä¸€ä¸ªæ›´é«˜çš„è§†è§’å»çœ‹å¾…æ•°æ®ï¼Œæ•°æ®ä¸å†åªæ˜¯é›¶æ•£çš„æ•´å‹/æµ®ç‚¹å‹ï¼Œè€Œæ˜¯å¯ä»¥è¢«æ„é€  / æå– / åˆ†æçš„ ratï¼›åœ¨ add-rat / sub-rat ä¹‹ä¸Šçš„å‡½æ•°æ— éœ€å…³å¿ƒ rat çš„å®ç°ç»†èŠ‚ï¼Œåªéœ€ä½¿ç”¨ add-rat ç­‰è¿ç®—æ¥è§£å†³é—®é¢˜å³å¯. ç¨‹åºçš„æ„é€ è¿‡ç¨‹æ˜¯æŠ½è±¡å±‚æ¬¡æå‡çš„è¿‡ç¨‹.\nHaskell: Pattern Match å†™è¿‡ Lisp ä¼šæ›´æ‡‚ Haskell çš„å¥½ï¼Œå°±åƒå†™è¿‡ C å¯ä»¥æ›´å¥½åœ°ä½“ä¼š Python å¼€å‘çš„ä¾¿æ·ï¼Œè¿™é‡Œåªæ˜¯è€ƒé‡è¯­æ³•çš„æ˜“ç”¨æ€§ï¼Œæ²¡æœ‰å¯¹äºæ€§èƒ½/åº”ç”¨åœºæ™¯ç­‰å…¶ä»–æ–¹é¢çš„æ¯”è¾ƒ.\nåœ¨ Scheme ä¸­å†™ (define (make-leaf symbol weight))/ (define (leaf? object )) / (define (weight tree)) è¿™æ ·çš„å‡½æ•°å†™å¾—å¤ªå¤šçš„æ—¶åˆ»ï¼Œä¼šæƒ³ Haskell ä¸­æ˜¯å¦‚ä½•åº”å¯¹æ•°æ®çš„æ„é€ å’Œæå–è¿™ä¸ªé—®é¢˜çš„å‘¢ï¼Ÿ\næ„é€ ï¼š\nå£°æ˜ä¸€ç§ç»„åˆæ•°æ®çš„è¯­æ³•å¦‚ä¸‹ï¼š\ndata Point = Point Int Int å®šä¹‰äº† Point ç±»å‹ï¼Œå¯¹åº”ä¸€ä¸ªæ„é€ å­ Point Int Intï¼Œå³åç»­å¯ä»¥é€šè¿‡æ­¤æ„é€ å­æ„é€  Point ç±»å‹çš„ç»„åˆæ•°æ®ï¼Œæ¯”å¦‚ p = Point 1 2.\næå–ï¼š\næ¨¡å¼åŒ¹é… Pattern Match\nä¸€ä¸ªç®€å•çš„ä¾‹å­:\ngetX :: Point -\u0026gt; Int getX (Point x _) = x å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šå¦‚ä½•æ„é€ ï¼ˆPoint Int Intï¼‰è¿™ä¸ªç»„åˆæ•°æ®å°±å¦‚ä½•å»åŒ¹é…å®ƒ ï¼ˆPoint x _ï¼‰ï¼Œå½¢å¼æ˜¯ä¸€æ ·çš„.\nå¦‚ä½•ç»“æ„ï¼Œå°±å¦‚ä½•è§£æ„.\nå¾ˆå¤šè¯­è¨€éƒ½æœ‰ Pattern Match çš„è¯­æ³•ï¼Œä½†æ˜¯ Haskell è®¾è®¡å¾—çœŸçš„å¤ªä¸æ»‘ï¼Œæˆ‘å†™è¿™ç¯‡åšå®¢çš„ç›®çš„å°±åœ¨äºå‘ˆç°ä¸Šé¢åŠ é»‘çš„é‚£å¥è¯.\nè¿™ä¸ªè¯­æ³•æä¾›çš„ä¸€ä¸ªä¼˜åŠ¿æ˜¯ï¼Œå¯ä»¥å¯¹å‡½æ•°å‚æ•°é€šè¿‡ Pattern Match åšè§£æï¼Œæ¯”å¦‚ä¸Šé¢çš„ä¾‹å­ï¼š\nconstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = ... -- ç©ºå¶å­åˆ—è¡¨ â†’ è¿”å›ç©ºæ ‘ constructHuffTree [t] = ... -- åªæœ‰ä¸€ä¸ªå¶å­ â†’ è¿”å›åªæœ‰æ ¹èŠ‚ç‚¹çš„æ ‘ constructHuffTree (x:y:ts) = ... -- æœ‰ä¸¤ä¸ªåŠä»¥ä¸Šå¶å­ â†’ é€’å½’å»ºç«‹ Huffman æ ‘ å‘ˆç°å‡ºæ¥çš„è¡¨ç°æ˜¯ï¼šå‡½æ•°å‚æ•°è¢«è§£æ„çš„æ–¹å¼ï¼Œå†³å®šäº†å‡½æ•°çš„è¡Œä¸º.\næ¯”å¦‚å¯¹äºè¿™æ ·çš„é—®é¢˜ï¼šæ±‚è§£äºŒå‰æ ‘çš„èŠ‚ç‚¹çš„æ•°é‡\ndata Tree a = Empty | Node a (Tree a) (Tree a) treeSize :: Tree a -\u0026gt; Int treeSize Empty = 0 treeSize (Node _ left right) = 1 + treeSize left + treeSize right ä½¿ç”¨ Empty æ„é€ å­æ„é€ å‡ºçš„ç©ºæ ‘ â†’ ç›´æ¥è¿”å› 0 (é€’å½’åŸº)\nä½¿ç”¨ Node æ„é€ å­æ„é€ å‡ºçš„éç©ºæ ‘ â†’ é€’å½’æ±‚è§£ (é€’å½’æ­¥)\næ•°æ®çš„æ„é€ æ–¹å¼å†³å®šäº†æˆ‘ä»¬å¯¹æ•°æ®çš„å¤„ç†æ–¹å¼ï¼Œè€Œåœ¨ Haskell ä¸­ï¼Œæ„é€ æ•°æ®çš„å½¢å¼å’Œå¯¹æ•°æ®è¿›è¡Œæ¨¡å¼åŒ¹é…çš„å½¢å¼æ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å‡½æ•°å‚æ•°ä½åšæ¨¡å¼åŒ¹é…ï¼Œä¸€ç§æ¨¡å¼å¯¹åº”ä¸€ç§å‡½æ•°è¡Œä¸º.\nLambda Calculus - pair abstraction Pure Lambda Calculus ä¸­çš„ pair abstraction ä¸Šé¢ä¸€è‡´æ€§è¿™ä¸€èŠ‚æåˆ°çš„ä¾‹å­ï¼Œå¯ä»¥ä½¿ç”¨çº¯ Lambda Calculus æ¥å®ç°1ï¼š\npair = Î»m Î»n Î»b. b m n pair v w = Î»b. b v w è¿™æ ·çš„ abstraction æä¾›çš„è§†è§’æ˜¯ï¼šé€šè¿‡å¯¹ pair çš„ä¸¤æ¬¡åº”ç”¨ï¼ˆapplicationï¼‰ï¼Œå¯¹ m, n è¿›è¡Œå®ä¾‹åŒ–ï¼Œå³ ç¡®å®š pair ä¸­æ‰€å«çš„å…ƒç´ ï¼Œå‰©ä¸‹çš„ b ä¸ºåç»­åœ¨ pair å…ƒç´ ä¸Šè¿›è¡Œçš„æ“ä½œç•™æ¥å£. è‹¥æƒ³å¯¹ pair ä¸­çš„å…ƒç´ è¿›è¡ŒæŒ‰åºæå–ï¼Œå¯å®šä¹‰ fst å’Œ sndï¼š\nfst = Î»a Î»b. a snd = Î»a Î»b. b (pair v w) fst â†’ v // æ ¹æ® left associativity conventionï¼Œè¿™é‡Œçš„æ‹¬å·æ˜¯å¯ä»¥çœç•¥çš„ (pair v w) snd â†’ w å¦‚æœä½ æ›´å¸Œæœ›ä»¥ fst (pair v w) è¿™æ ·çš„ç¼–ç¨‹é£æ ¼å‘ˆç°ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åšåˆ°ï¼š\ntru = Î»t Î»f. t // Î± ç­‰ä»·äºä¸Šä¸€ä¸ªä»£ç æ®µå®šä¹‰çš„ `fst`ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŒä¸€ä¸ªæŠ½è±¡åšä¸åŒçš„ç†è§£ fls = Î»t Î»f. f // ... `snd` ... fst = Î»p. p tru snd = Î»p. p fls fst (pair v w) â†’ v snd (pair v w) â†’ w å†æ¬¡å®¡è§†è¿™ä¸ª abstractionï¼špair = Î»m Î»n Î»b. b m n.â€‚Lambda Calculus ä¸­å°†æˆ‘ä»¬æƒ¯å¸¸ç§°ä¹‹ä¸ºå‡½æ•°çš„ç»“æ„ç§°ä¸º abstractionï¼ˆæŠ½è±¡ï¼‰ï¼Œè¿™é‡Œçš„ pair abstraction å°±å¯¹ pair çš„æ„é€ ä¸æ“ä½œè¿›è¡Œäº†æŠ½è±¡ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡å¤–å±‚å‚ m, n ç¡®å®šåŒ…å«çš„å…ƒç´ ï¼Œæ„å»º pairï¼Œæœ€åé€šè¿‡å†…å±‚å‚ b æ¥æ‰§è¡Œå¯¹å·²æœ‰å…ƒç´ çš„æ“ä½œï¼›åœ¨è¿™æ ·çš„è§†è§’ä¸‹ï¼Œpair å¤©ç„¶å…·å¤‡ä¸ Lambda Calculus ä½“ç³»å†…å…¶ä»–å‡½æ•°ï¼ˆabstractionï¼‰äº¤äº’çš„å±æ€§ï¼Œå› ä¸ºåœ¨å®ä¾‹åŒ– pair å…ƒç´ ä¹‹åï¼Œå®ƒå‘å¤–ç•Œæä¾› b è¿™ä¸ªäº¤äº’æ¥å£ï¼Œç­‰å¾…å…¶ä»– abstraction ä¸ pair å·²æœ‰çš„å…ƒç´ é€šè¿‡åº”ç”¨ï¼ˆapplicationï¼‰äº¤äº’.\nBÃ¶hmâ€™s theorem å¯¹äº (pair v w) fst è¿™æ ·çš„ç»“æ„ï¼Œå‡å®š a,b,c,d æ˜¯ä¸åŒçš„å››ä¸ªç¬¦å·ï¼Œå¯ä»¥æƒ³è§ (pair a b) fst å’Œ (pair c d) fst çš„å€¼å¿…ç„¶æ˜¯ä¸åŒçš„ï¼Œæé«˜æ­¤è§‚å¯Ÿçš„æŠ½è±¡ç¨‹åº¦ï¼Œæˆ‘ä»¬å¯ä»¥é™ˆè¿°ï¼šå¯¹äºä¸åŒçš„æŠ½è±¡ï¼Œåº”ç”¨ç›¸åŒçš„æ“ä½œï¼Œå¾—åˆ°çš„å€¼ä¸åŒ.â€‚Lambda Calculus å’Œ Combinator Logic é‡Œçš„ BÃ¶hm\u0026rsquo;s theorem 2 å¦‚ä¸‹ï¼š\nIn Î» and CL: let $M$ and $N$ be combinators, either in Î²Î·-normal form (in Î») or in strong normal form (in CL). If $M \\not\\equiv N$, then there exist $n â‰¥ 0$ and combinators $L_1$, \u0026hellip;, $L_n$ such that $$ ML_1 \u0026hellip;L_nxy \\quad \\rhd_{\\beta,w} \\quad x, $$ $$ NL_1 \u0026hellip;L_nxy \\quad \\rhd_{\\beta,w} \\quad y. $$ Roughly speaking, BÃ¶hmâ€™s theorem says that $M$ and $N$ can be distinguished, not just by their structure, but by their behaviour.\nBÃ¶hm\u0026rsquo;s theorem æä¾›çš„è§†è§’æ˜¯ï¼šåœ¨ä¸ç­‰çš„ä¸¤ä¸ªç»„åˆå­ï¼ˆå³ä¸å«è‡ªç”±å˜é‡çš„ Î»-termï¼‰ä¸Šåº”ç”¨ç›¸åŒçš„æ“ä½œï¼Œå¾—åˆ°çš„å€¼ä¸åŒï¼›å³ æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»„åˆå­çš„è¡Œä¸ºæ¥å¯¹ä¸åŒç»„åˆå­è¿›è¡ŒåŒºåˆ†.â€‚ä¸Šæ–‡æåˆ°çš„ (pair v w) fst å°±æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œ(pair a b) å’Œ (pair c d)æ˜¯ä¸åŒçš„ç»„åˆå­ï¼Œå°†æ­¤äºŒè€…æ–½ä»¥åŒæ ·çš„æ“ä½œ fst ï¼Œå¾—åˆ°çš„å€¼ä¸åŒ.â€‚æˆ‘ä»¬åœ¨ Scheme ä¸­å®ç°çš„ cons - dispatch ä¹Ÿå¯ä»¥ç”¨è¿™ä¸ªæ€è·¯æ¥ç†è§£.\nTypes and Programming Languages - Chapter 5 The Untyped Lambda-Calculus\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLambda-calculus and Combinators, an introduction - 3C Theorem 3.11\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-02T01:53:00+08:00","permalink":"http://fyshxfish.github.io/p/huffman-tree-implementation-in-haskell-sicp-2.3.4-structuring-and-destructuring-of-composed-data/","title":"Huffman Tree Implementation in Haskell - SICP Â§ 2.3.4 | Structuring and Destructuring of Composed Data"},{"content":"Problem Description Problem: Given a positive integer $n$, find all ordered pairs of distinct positive integers $i$ and $j$, where $ 1 \\leq i \\leq j \\leq n $, such that $ i + j $ is prime.\nImplementation in Haskell isDivisible :: Int -\u0026gt; Int -\u0026gt; Bool isDivisible x y | mod x y == 0 = True | otherwise = False isPrime :: Int -\u0026gt; Bool isPrime x | x \u0026lt;= 2 = True | otherwise = not (foldr (||) False (map (isDivisible x) [2..((floor . sqrt . fromIntegral) x)])) genPairs :: Int -\u0026gt; [((Int, Int), Int)] genPairs n = do x \u0026lt;- [1..n] y \u0026lt;- [1..(x-1)] return ((y, x), (x + y)) sumPrimePairs :: Int -\u0026gt; [((Int, Int), Int)] sumPrimePairs = (filter (\\(_, s) -\u0026gt; (isPrime s))) . genPairs About List Monad: Context, Nested lambda and do-notation Context of List Monad : nondeterministic result.\nThe title of this section is Nested Mappings, represented in code with nested lambdas. In Haskell, do notation is syntactic sugar for nested lambdas.\nAnd flatMap defined in this chapter is actually Haskell \u0026gt;\u0026gt;= (bind) in Haskell.\nFor further details, consult Learn You a Haskell for Great Good: A Fistful of Monads - the List Monad\nAnother Example: The List Monad for Permutation An intuitive way to understand this is that nondeterministic results are well-suited for solving permutations.\npermutations :: Eq a =\u0026gt; [a] -\u0026gt; [[a]] permutations [] = [[]] permutations xs = do x \u0026lt;- xs perm \u0026lt;- permutations $ removeByElem x xs return (x: perm) removeByElem :: Eq a =\u0026gt; a -\u0026gt; [a] -\u0026gt; [a] removeByElem x = filter (/= x) ","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/nested-mapping-examples-implemented-in-haskell-sicp-2.2.3-list-monad/","title":"Nested Mapping Examples Implemented in Haskell - SICP Â§ 2.2.3  | List Monad "},{"content":" let çš„è¯­ä¹‰ ç»“è®º: let scope ä¼šç«‹å³æ±‚å€¼ (åŒ…æ‹¬ç»‘å®šå’Œç»‘å®šä¹‹åçš„è¡¨è¾¾å¼, ä¹Ÿå°±æ˜¯ let ä¹‹å¤–çš„ä¸€å±‚æ‹¬å·æ‰€åŒ…è£¹çš„èŒƒå›´), å³ä½¿ä½ æŠŠ let åµŒå¥—åœ¨å†…å±‚å‡½æ•°é‡Œè€Œä¸”è¿™ä¸ªå‡½æ•°è¿˜å®Œå…¨æ²¡æœ‰è¢«è°ƒç”¨.\nç¤ºä¾‹:\n(define (comp x) (if (\u0026gt; 3 x) (display \u0026#34;then-clause\u0026#34;) (display \u0026#34;else-clause\u0026#34;) ) #| (define foo1 (let ((bar1 (/ 2 0))) ; * evaluted immediately (display \u0026#34;should not be printed\u0026#34;) ) ) |# (define foo2 (let ((bar2 (/ 5 2))) ; * evaluted immediately (newline) (display \u0026#34;let in `foo2`, bar2: \u0026#34;) (display bar2) ) ) ) è¿è¡Œç¤ºä¾‹:\nfoo1: å¯ä»¥çœ‹åˆ° let ç»‘å®šè¢«æ±‚å€¼äº†, å¦åˆ™ä¸ä¼šæŠ›å‡ºé™¤é›¶å¼‚å¸¸.\nprompt\u0026gt; (comp 4) else-clause ;Division by zero signalled by /. ;To continue, call RESTART with an option number: ;snip foo2: å¯ä»¥çœ‹åˆ° let ç»‘å®šåçš„è¡¨è¾¾å¼è¢«æ±‚å€¼äº†, å¦åˆ™ä¸ä¼šæœ‰ display çš„è¾“å‡º\nprompt\u0026gt; (comp 2) then-clause let in `foo2`, bar2: 5/2 ;Unspecified return value if çš„è¯­ä¹‰ ifçš„è¯­ä¹‰: æ ¹æ®å¯¹æ¡ä»¶å¼è¿›è¡Œæ±‚å€¼ï¼Œæ ¹æ®æ±‚å€¼ç»“æœå†³å®šç»§ç»­å¯¹ then/else åˆ†æ”¯è¿›è¡Œæ±‚å€¼.\nå¯ä»¥ä¸æ­¤å¯¹ç…§å‚è€ƒçš„ææ–™æ˜¯ SICP (2nd Edition) Exercise 1.6ï¼Œæ­¤é¢˜ä¸­ä½¿ç”¨ abstraction ï¼Œé€šè¿‡ cond å®šä¹‰äº† new-if:\n(define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause) ) ) å‡½æ•°åº”ç”¨çš„è¯­ä¹‰æ˜¯ï¼ˆapplicative mode evaluationï¼‰ï¼šå…ˆå¯¹å‚æ•°ï¼ˆæ¯”å¦‚è¿™é‡Œçš„then-clause å’Œ else-clauseï¼‰è¿›è¡Œæ±‚å€¼ï¼Œç„¶åè¿›è¡Œå‡½æ•°åº”ç”¨ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¸èƒ½åœ¨then-clause æˆ– else-clauseé‡Œå†™é€’å½’è¡¨è¾¾å¼ï¼Œå› ä¸ºå®ƒä»¬ä¼šå…ˆè¢«æ±‚å€¼ï¼Œè€Œä¸æ˜¯æ ¹æ® predicate çš„å€¼å†³å®šæ˜¯å¦æ±‚å€¼ï¼Œäºæ˜¯é€’å½’å°±æ— ç©·æ— å°½äº†. if/cond/\u0026hellip; æ˜¯ special form, ç›¸è¾ƒäºé€šè¿‡ define å®šä¹‰çš„ abstraction, è¯­ä¹‰æ˜¯ç‰¹æ®Šçš„. æˆ‘å–œæ¬¢ new-if è¿™ä¸ªä¾‹å­ï¼Œå®ƒç®€æ´è€Œæœ‰åŠ›åœ°ä½“ç°äº† lisp å…ƒç¼–ç¨‹çš„ç‰¹æ€§ï¼Œé€šè¿‡æ­¤ä¾‹ä¹Ÿå¯ä»¥æ›´å¥½åœ°æ¥çº³ lisp é‡Œå¤§é‡çš„æ‹¬å·ï¼Œæ ¹æ® substitution model, è¿™é‡Œçš„ predicate, then-clause, else-clause å¯ä»¥æ›¿æ¢æˆä½ éœ€è¦çš„è¡¨è¾¾å¼, è€Œè¡¨è¾¾å¼å°±æ˜¯è¢«æ‹¬å·åŒ…è£¹çš„, å³ æ‹¬å·æ˜¯è¡¨è¾¾å¼çš„è¾¹ç•Œ, ä½ å¯ä»¥æŠŠè¢«æ‹¬å·åŒ…è£¹çš„è¡¨è¾¾å¼æ”¾åœ¨ä»»æ„çš„å‚æ•°ä½ (å½“ç„¶è¦ç¬¦åˆ abstraction éšå¼çš„å¯¹äºå‚æ•°çš„ç±»å‹çº¦æŸ).\nlet ç«‹å³æ±‚å€¼å¼•å‘çš„é”™è¯¯å®ä¾‹ å¯¹äºè¿™æ ·ç´ æ•°åˆ¤æ–­çš„ä¸€æ®µä»£ç ï¼š\n(define (prime? x) (if (or (= x 1) (= x 2)) #t test_prime ) (define (divisible? y) (= 0 (remainder x y)) ) (define (iter_biggest_divisor y) (cond ((= y 1) 1) ((divisible? y) y) (else (iter_biggest_divisor (- y 1))) ) ) (define test_prime (let ((biggest_divisor (iter_biggest_divisor (quotient x 2)) )) ; Notice (display biggest_divisor) (if (= biggest_divisor 1) #t #f ) ) ) ) è¿è¡Œçš„ç»“æœæ˜¯:\nprompt\u0026gt; (prime? 1) ;The object 0, passed as the second argument to integer-remainder, is not in the correct range. prompt\u0026gt; (prime? 2) 1 ;Value: #t æŒ‰ç…§é¢„æœŸ, (prime? 1) å’Œ (prime? 2) éƒ½åº”è¯¥ç›´æ¥è¿”å› #t, è€Œä¸æ˜¯å‰è€…æŠ¥é”™, åè€…å‘ˆç°å‡º (display biggest_divisor) çš„è¡Œä¸º. æ ¹æ®å‰æ–‡çš„é™ˆè¿°, åŸå› æ˜¯: æ•´ä¸ª let scope éƒ½è¢«æ±‚å€¼äº†.\n","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/semantics-of-let-in-schemefeat.-semantics-of-if/","title":"Semantics of `let` in Scheme(feat. Semantics of `if`)"},{"content":"åŒ…å«å¯¹äº VSCode ä½œä¸ºæ–‡æœ¬ç¼–è¾‘å™¨çš„é…ç½®ï¼Œä¸åŒ…å«å¯¹è¯­è¨€ç¯å¢ƒçš„é…ç½®.\nAbout: Command Palette \u0026amp; Ctrl + Shift + P å…³äº Ctrl + Shift + P: é¦–å…ˆåœ¨è¿™é‡Œè´´è’‹ç‚å²©è€å¸ˆçš„ä¸€åœºä¸VSCodeç›¸å…³çš„è®²åº§ï¼ŒCtrl+Shift+Pï¼šå¦‚æœéœ€è¦åšæŸäº›äº‹æƒ…ï¼Œå¯ä»¥å…ˆå°è¯•ç”¨ Ctrl+Shift+P æ‰“å¼€å‘½ä»¤é¢æ¿æœç´¢ï¼ˆæ¯”å¦‚ä¹Ÿè®¸ä½ æƒ³é‡æ–°åŠ è½½ VSCode çª—å£ï¼Œå°±å¯ä»¥ Ctrl+Shift+P æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œç„¶åæœç´¢ \u0026ldquo;reload window\u0026rdquo; ï¼‰ï¼Œå¦‚æœå‘ç°è‡ªå·±éœ€è¦ç»å¸¸åšè¿™ä¸ªåŠ¨ä½œï¼Œé‚£ä¹ˆå°± Ctrl+K Ctrl+S è¿›å…¥ Keyboard Shortcuts ä¸ºè¿™ä¸ªæ“ä½œç»‘å®šå¿«æ·é”®å§ï¼Œé…ç½®å¿«æ·é”®çš„å“²å­¦åœ¨äºï¼šå‘ç°è‡ªå·±ç»å¸¸é‡å¤åšæŸä»¶äº‹æƒ…ï¼Œæœ‰ä¸€ä¸ªç¬é—´å‘ç°è‡ªå·±ä¸æƒ³ç”¨é¼ æ ‡å†æ¬¡é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œäºæ˜¯å»æ£€ç´¢è®°å¿† / é…ç½®è¿™ä¸ªçƒ­é”®ã€‚\nLayout è®© VSCode çš„ç•Œé¢æ›´ç®€æ´ï¼šéšè— Activity Bar å’Œ Status Bar å…¶å®å¹¶ä¸æ˜¯æ—¶æ—¶åˆ»åˆ»éƒ½éœ€è¦çœ‹åˆ° Activity Bar å’Œ Status Barï¼Œå¦‚æœä½ ä¹Ÿè§‰å¾—å®ƒä»¬å ç”¨äº†å®è´µçš„å±å¹•ç©ºé—´ï¼Œé‚£ä¹ˆå¯ä»¥ç»‘å®šä»¥ä¸‹å¿«æ·é”®ï¼š\nView: Toggle Activity Bar Visibility - Ctrl+Shift+9\nView: Toggle Status Bar Visibility - Ctrl+Shift+8\nä¸ºä»€ä¹ˆæ˜¯ Ctrl+Shift+8/9ï¼šå› ä¸º Shift+9 å¯¹åº”çš„å­—ç¬¦æ˜¯å·¦æ‹¬å·ï¼Œå’Œ Activity Bar åœ¨å½¢æ€ä¸Šç•¥æœ‰ç›¸ä¼¼ï¼Œé¡ºæ‰‹æŠŠ Status Bar å¯¹åº”çš„å¿«æ·é”®è®¾ç½®ä¸º Ctrl+Shift+8ï¼Œé”®ä½è¿‘æ¯”è¾ƒé¡ºæ‰‹ï¼Œå› ä¸ºæˆ‘æ€»æ˜¯åŒæ—¶å…³é—­æ­¤äºŒè€…çš„å¯è§æ€§ï¼›æƒ³å¿«æ·é”®è¿˜æ˜¯ä¸€ä¸ªä¸é‚£ä¹ˆå®¹æ˜“çš„äº‹æƒ…ï¼Œä¸€æ–¹é¢è¿™é‡Œçš„å¿«æ·é”®è¯­ä¹‰å«é‡æ²¡æœ‰é‚£ä¹ˆé«˜ï¼Œå¦ä¸€æ–¹é¢å®¹æ˜“å’Œå·²æœ‰çš„é”®ä½ç»‘å®šå†²çªï¼Œè®¾ç½®å®Œäº†ä¸€æ®µæ—¶é—´ä¸ç”¨åˆä¼šå¿˜è®°ï¼Œç„¶åå‘ç° Ctrl+Shift+P æ£€ç´¢æ‰æ˜¯æ°¸è¿œçš„å®¶.\nTerminal: Move Terminal to Editor Area å¹¶ç½®ç»ˆç«¯ tab å’Œä»£ç  tab.\nCtrl+Shift+P â†’ åœ¨å‘½ä»¤é¢æ¿ä¸­æ£€ç´¢ Terminal: Move Terminal to Editor Area ï¼Œå³å¯å°†ç»ˆç«¯æ”¾ç½®åˆ° Editor Areaï¼Œå…¶ä»–ç±»ä¼¼æ“ä½œè¿˜æœ‰ Move Terminal to Panel, Create New Terminal in Editor Area\u0026hellip;å½“ç„¶ï¼Œå¯ä»¥ä¸ºä½ ç»å¸¸ä½¿ç”¨çš„æ“ä½œç»‘å®šå¿«æ·é”®ã€‚\nä¸€ç§é€‚ç”¨çš„åœºæ™¯æ˜¯ï¼šå¦‚æœä½ åœ¨å­¦ä¹ æŸç§ç¼–ç¨‹è¯­è¨€ï¼Œè€Œè¿™ç§è¯­è¨€ï¼ˆæ¯”å¦‚ Haskell, Lisp, Python\u0026hellip;ï¼‰åˆšå¥½æœ‰REPLï¼Œä½ å°±å¯ä»¥åœ¨ Editor Area åˆ‡åˆ†ï¼Œä¸€åŠæ”¾ä»£ç ï¼Œä¸€åŠæ”¾ Terminal REPLï¼Œå¦‚æœéœ€è¦ï¼Œå¯ä»¥ç¼–è¾‘æ–‡ä»¶ï¼Œç„¶ååœ¨ REPL ä¸­å¯¼å…¥ä»£ç æ–‡ä»¶ï¼ˆåƒHaskell ghciä¸­çš„:l foo.hsï¼‰ï¼Œè¿™æ ·å°±å¾ˆæ–¹ä¾¿ï¼Œå¯ä»¥é€šè¿‡ Ctrl+1/Ctrl+2 åœ¨ä»£ç  tab å’Œç»ˆç«¯ tab ä¹‹é—´åš Focus çš„åˆ‡æ¢ï¼›è§†è§‰ä¸Šæˆ‘è®¤ä¸ºè¿™æ ·çš„ä½“éªŒä¹Ÿä¸€äº›ï¼Œæ¯”é»˜è®¤çš„ä¸Šä¸‹åˆ†å±æ›´å¥½ï¼ˆæ¯•ç«Ÿæ›´å¤šæƒ…å†µä¸‹ç”µè„‘çš„å±å¹•æ°´å¹³è¾¹æ¯”ç«–ç›´è¾¹é•¿ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæˆ‘å–œæ¬¢ç«–ç›´å‘çš„æµè§ˆå™¨æ ‡ç­¾æ ï¼‰.\nè¿˜æœ‰ä¸€ç§ç±»ä¼¼çš„å®ç°ï¼šé€šè¿‡ Ctrl+Shift+B æ‰“å¼€ Secondary Side Barï¼ŒæŠŠç»ˆç«¯æ‹–åˆ° Secondary Side Bar.\nEditor Area Rainbow Brackets åœ¨Settings(GUI)ä¸­é”®å…¥ @id:editor.bracketPairColorization.enabled @id:editor.guides.bracketPairsï¼Œé€‰æ‹©ä½ éœ€è¦çš„é€‰é¡¹ï¼Œeditor.bracketPairColorization.enabled æ˜¯é»˜è®¤å¯ç”¨çš„ï¼Œeditor.guides.bracketPairsæ˜¯é»˜è®¤å…³é—­(false)çš„ï¼Œå¯ä»¥é€‰æ‹© true æˆ–è€… active å¯ç”¨ï¼Œ true çš„æ•ˆæœæ˜¯æ‰€æœ‰æ‹¬å·éƒ½æœ‰å¼•å¯¼çº¿ï¼Œ active çš„æ•ˆæœæ˜¯åªæœ‰æœ€æ¥è¿‘å…‰æ ‡çš„å¤–å±‚æ‹¬å·æœ‰å¼•å¯¼çº¿ï¼Œæˆ‘è§‰å¾— active å°±è¶³å¤Ÿäº†ï¼Œæ•ˆæœå¦‚ä¸‹ï¼š\né¡ºä¾¿ä¸€ä¸ªå¿«æ·é”®ï¼šCtrl+Shift+\\ï¼Œå¯ä»¥åœ¨å½“å‰æ–‡æœ¬å¯¹åº”çš„å·¦å³æ‹¬å·ä¹‹é—´è·³è½¬ï¼Œå¯ä»¥ç”¨æ¥æ£€æŸ¥è¡¨è¾¾å¼åµŒå¥—çš„å±‚çº§ï¼Œå¯¹åº” Vim Normal Mode ä¸‹çš„%.(P.S. æ­¤å¿«æ·é”®åœ¨ Terminal ä¸­ä½¿ç”¨ï¼Œå¯ä»¥ç”¨æ¥åœ¨ä¸åŒçš„ Terminal tab ä¸­è·³è½¬)\nèµ·å› æ˜¯æˆ‘æœ€è¿‘åœ¨çœ‹ SICP ï¼Œè¿™æœ¬ä¹¦ä½¿ç”¨çš„è¯­è¨€æ˜¯ lisp (scheme)ï¼Œè¿™é—¨è¯­è¨€çš„æ‹¬å·å®åœ¨æ˜¯å¤š(ï¼ŒçœŸçš„æœ‰å…¶ä»–è¯­è¨€çš„è¯­è¨€è®¾è®¡ä¸­å…·å¤‡æ¯”lispæ›´å¤šçš„æ‹¬å·å—ï¼Ÿ) äºæ˜¯æˆ‘åœ¨ Extensions ä¸­æœç´¢ Rainbow Brackets ï¼Œå¯¹åº”æ’ä»¶è¡¨ç¤ºé¡¹ç›®å·²æ”¾å¼ƒç»´æŠ¤ï¼Œå› ä¸ºæ­¤ç‰¹æ€§å·²ç”± VSCode å†…ç½®ï¼Œå¹¶ä¸ºæˆ‘æŒ‡è·¯è‡³ Settings(GUI) çš„é…ç½®å…·ä½“ä½ç½®ã€‚\nHotKey Baseline\nå°†å…‰æ ‡æ‚¬åœåœ¨ GUI çš„ button ä¸Šï¼Œå¦‚æœè¯¥ button æœ‰å¯¹åº”çš„å¿«æ·é”®ï¼Œå¼¹å‡ºçš„æ‚¬çª—ä¼šå‘ˆç°å¿«æ·é”®ä¿¡æ¯ï¼ˆå¾ˆå¤šç¨‹åºéƒ½éµå¾ªè¿™ä¸ªè®¾è®¡å“²å­¦ï¼‰ï¼Œæ‰€ä»¥å¦‚æœå‘ç°è‡ªå·±ç»å¸¸ç‚¹å‡»æŸä¸ªé”®ï¼Œä¸å¦¨åœä¸‹æ¥çœ‹çœ‹å®ƒå¯¹åº”çš„çƒ­é”®æ˜¯ä»€ä¹ˆ.\nCtrl-bï¼štoggle side bar.\nè¿™é‡Œå¯¹åº”çš„ä¸€ä¸ªæ•…äº‹æ˜¯ï¼Œæœ‰äººç»™ VSCode æäº†ä¸€ä¸ªissueï¼Œå¸Œæœ› VSCode æä¾›ä¸€ä¸ªç±»ä¼¼ toggleExplorerVisibility é…ç½®é¡¹ï¼Œç„¶åä¸€ä¸ªç”¨æˆ·å›å¤ \u0026ldquo;Ctrl-B to toggle side bar\u0026rdquo; å¹¶å…³é—­äº†æ­¤issue. ä¸ºä»€ä¹ˆæˆ‘ä¼šçŸ¥é“è¿™ä»¶äº‹æƒ…ï¼Œå› ä¸ºæˆ‘ä¹Ÿä»¥ä¸ºæˆ‘çš„éœ€æ±‚æ˜¯ toggleExplorerVisibilityï¼Œç»“è®ºæ˜¯ï¼šæ˜ç¡®æ¯ä¸ªç»„ä»¶çš„ç§°å‘¼å¾ˆé‡è¦ã€‚(ä½†æ˜¯ï¼Œä¸€ä¸ªçƒ­é”®å¯¹åº” toggleï¼Œä¸¤ä¸ªçƒ­é”®åˆ†åˆ«å¯¹åº” show / hideï¼Œå‰è€…åº”è¯¥æ›´åˆç†ä¸€äº›.)\nAlt-left/right Arrowï¼šå›é€€åˆ°ä¸Šä¸€å…‰æ ‡ä½ç½®/å‰è¿›åˆ°ä¸‹ä¸€å…‰æ ‡ä½ç½®\næ¯”è¾ƒæœ‰ç”¨çš„ä¸€ä¸ªæƒ…æ™¯æ˜¯ï¼šå’Œ F12 é…åˆï¼Œåœ¨å‡½æ•°çš„è°ƒç”¨é“¾é‡Œå¯¼èˆª.\nCtrl-[/]ï¼šå¯¹å…‰æ ‡æ‰€åœ¨è¡Œå·¦ç§»/å³ç§»ç¼©è¿›ã€‚\nåŒ Vim Visual Mode ä¸‹çš„ \u0026gt;/\u0026lt;. Vim çš„è¿™ä¸ªé”®ä½æˆ‘ç”¨ç€ä¸€ç›´ä¸æ˜¯å¾ˆé¡ºï¼Œå› ä¸ºé€‰ä¸­ä¹‹ååªèƒ½è¿›è¡Œä¸€æ¬¡æ“ä½œï¼Œå¦‚æœæƒ³å†åšä¸€æ¬¡ç¼©è¿›ï¼Œé‚£è¦å†é€‰ä¸€æ¬¡ï¼Œè™½ç„¶æ˜¯å¯ä»¥2 \u0026gt;è¿™æ ·å‘å³ç¼©è¿›ä¸¤ä¸ªtabï¼Œä½†æ˜¯å¯¹æˆ‘æ¥è¯´è¿˜æ˜¯æ²¡æœ‰é‚£ä¹ˆé¡ºï¼Œè‡ªä»å‘ç°åœ¨ç¼–è¾‘ä¸­ä½¿ç”¨ Ctrl/Shift/Alt å¯ä»¥åšä¸€äº›è·³è½¬/é€‰ä¸­ç­‰æ“ä½œï¼Œæˆ‘å°±å¾ˆå°‘ç¦»å¼€Vim Insert Modeäº†ï¼Œå½“ç„¶è¿™äº›çƒ­é”®åœ¨è¯­ä¹‰åŒ–çš„æ–¹é¢æ˜¯æ¯”ä¸è¿‡ Vim çš„é”®ä½.\nAlt-up/down Arrowï¼šä¸Šç§»/ä¸‹ç§»å…‰æ ‡æ‰€åœ¨è¡Œ.\nShift-Alt-f: format ä»£ç ï¼Œå‰ææ˜¯é…ç½®å¥½äº† formatter.\näºæ˜¯æˆ‘ä¸å†éœ€è¦æ‰‹åŠ¨è°ƒç©ºæ ¼/ç©ºè¡Œçš„æ•°é‡ï¼ŒCtrl + V çš„æ—¶å€™ä¹Ÿä¸å¿…æ‹…å¿ƒå…‰æ ‡æ‰€åœ¨åˆ—ï¼Œç²˜è´´å®Œä¸€é”® format å®Œäº‹ï¼Œå¾ˆå¯æƒœåƒ Python è¿™æ ·å¼ºåˆ¶ç¼©è¿›çš„è¯­è¨€ä¸å¤ªå¥½ format.\nCtrl-(Shift-)Enter: åœ¨å½“å‰å…‰æ ‡æ‰€åœ¨è¡Œä¸‹(ä¸Š)æ–¹æ–°å»ºä¸€è¡Œï¼Œå…‰æ ‡è·³è½¬åˆ°æ–°è¡Œè¡Œé¦–.\nåŒ Vim Normal Mode ä¸‹çš„ o(O).\nExtensions Bluloco Light Theme (Author: Umut TopuzoÄŸlu)\néå¸¸æ¼‚äº®çš„ä¸»é¢˜ï¼Œæˆ‘çš„ Wezterm ä½¿ç”¨çš„ä¹Ÿæ˜¯è¿™ä¸ªä¸»é¢˜.\nRemove empty lines (Author: Alexander)\nåˆ é™¤é€‰åŒºå†…çš„æ‰€æœ‰ç©ºè¡Œ. å¯ä»¥é€šè¿‡ Ctrl + Shift + P è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥ä¸ºå…¶ç»‘å®šå¿«æ·é”®.\nMisc ä¸€äº›å†™åœ¨ User Settings (JSON) é‡Œçš„å°é…ç½®ï¼ŒåŒ…å«:\né…ç½® VSCode-Vim æ’ä»¶:\nä¸ VSCode é»˜è®¤é”®ä½å†²çªå¤„ç†\nä½¿ç”¨ç³»ç»Ÿå‰ªåˆ‡æ¿\næ™ºèƒ½ç›¸å¯¹è¡Œå·ï¼ˆåªåœ¨ Insert Mode ä½¿ç”¨ç»å¯¹è¡Œå·ï¼‰\næ”¹å˜æ‚¬åœçª—å£ï¼ˆå¦‚ Language Server æä¾›çš„å‡½æ•°æè¿°ï¼‰çš„èƒŒæ™¯è‰²;\né»˜è®¤ç¼©æ”¾ç­‰çº§ï¼Œå› ä¸ºæˆ‘ä¹‹å‰æ‰“å¼€ VSCode åšçš„ç¬¬ä¸€ä»¶äº‹æ€»æ˜¯ ^+ è°ƒå¤§ä¸€æ¬¡ Zoom Level;\nå½©è™¹æ‹¬å·å¼•å¯¼çº¿è®¾ç½®.\n{ \u0026#34;vim.smartRelativeLine\u0026#34;: true, \u0026#34;vim.useSystemClipboard\u0026#34;: true, \u0026#34;vim.handleKeys\u0026#34;: { // å¦‚ä½ æ‰€è§ï¼Œæˆ‘æ˜¯ä¸€ä¸ªéå¸¸ä¸çº¯çš„ Vim ç”¨æˆ· \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-x\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-a\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-s\u0026gt;\u0026#34;: false, // save \u0026#34;\u0026lt;C-z\u0026gt;\u0026#34;: false, // undo \u0026#34;\u0026lt;C-[\u0026gt;\u0026#34;: false, // outdent line \u0026#34;\u0026lt;C-]\u0026gt;\u0026#34;: false, // indent line \u0026#34;\u0026lt;C-b\u0026gt;\u0026#34;: false, // toggle side bar \u0026#34;\u0026lt;C-o\u0026gt;\u0026#34;: false, // open files \u0026#34;\u0026lt;C-k\u0026gt;\u0026#34;: false, // leading key for ... }, \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editorHoverWidget.background\u0026#34;: \u0026#34;#edeeee\u0026#34;, // è®¾ç½®æ‚¬åœæç¤ºçš„èƒŒæ™¯é¢œè‰² }, \u0026#34;window.zoomLevel\u0026#34;: 1, \u0026#34;editor.guides.bracketPairs\u0026#34;: \u0026#34;active\u0026#34; } ","date":"2024-08-26T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/my-vscode-configuration/","title":"My VSCode Configuration"},{"content":" Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. \u0026ndash; Antoine de Saint-ExupÃ©ry\né€šè¿‡åŒ…ç®¡ç†å™¨ä¸‹è½½ mit-scheme MacOS:\nbrew install mit-scheme Ubuntu:\nsudo apt-get update sudo apt-get install mit-scheme REPL åŸºæœ¬ä½¿ç”¨ ï¼ˆREPL: Read-Evaluate-Print Loopï¼‰\nè¿›å…¥ REPL:\nmit-scheme åœ¨ REPL åŠ è½½ä¸­åŠ è½½ scheme ä»£ç :\n1 ] =\u0026gt; (load \u0026#34;path/to/file.scm\u0026#34;) (åç¼€ .scm å¯ä»¥çœç•¥.)\næŸ¥çœ‹æ‰‹å†Œ:\nman mit-scheme å‘½ä»¤è¡ŒæŸ¥çœ‹ mit-scheme CLI æ‰‹å†Œ, å¾ˆç®€çŸ­, å¯ä»¥é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æŒ‡å®šå †æ ˆå¤§å° / åŠ è½½æ–‡ä»¶ / åŒæ—¶æ‰“å¼€ç¼–è¾‘å™¨/ \u0026hellip;\næŒ‰ä¸‹ Ctrl-C åé”®å…¥ H æŸ¥çœ‹ä¸­æ–­æ‰‹å†Œ:\nCtrl-C: æ¥æ”¶ä¸‹ä¸€ä¸ªé”®ç›˜è¾“å…¥, å†³å®šä¸­æ–­è¡Œä¸º.\nCtrl-G: å›åˆ° top-level\nCtrl-Z: æŒ‚èµ·å½“å‰ mit-scheme è¿›ç¨‹\næŒ‰ä¸‹ Ctrl-C åé”®å…¥ ? æŸ¥çœ‹æ‰‹å†Œ: ä¸‹ä¸€é”®ç›˜è¾“å…¥ (option) ä¸ REPL è¡Œä¸º (æ¸…å± / æŒ‚èµ· / é€€å‡º / å¿½ç•¥ä¸­æ–­ / \u0026hellip;) çš„å¯¹åº”å…³ç³»;\nå¦‚æœ REPL æ²¡æœ‰ååº”:\næ£€æŸ¥æ‹¬å·æ˜¯å¦é€å¯¹åŒ¹é…;\nCtrl-C ä¸­æ–­åå›åˆ° REPL, æç¤ºç¬¦ (1 ] =\u0026gt; / 2 error\u0026gt;) ä¸ä¼šé‡æ–°æ˜¾ç¤º.\næ‹…å¿ƒé€’å½’å¤ªæ·±? é€’å½’æ·±åº¦è¶…é™æ—¶, REPL ä¼šæç¤º Recursion depth limit exceeded. Aborting! (3.1 ä¸­æåˆ°å¯ä»¥é€šè¿‡ CLI å‚æ•°æŒ‡å®šå †æ ˆå¤§å°, å³, mit-schemeä½¿ç”¨çš„å †æ ˆèµ„æºæ˜¯æœ‰é™çš„.)\nScHeMe Scheme æ˜¯å¤§å°å†™ä¸æ•æ„Ÿçš„è¯­è¨€.\næ‰€ä»¥ (LoAd \u0026quot;path/to/file.scm\u0026quot;)/(DEFINE x 1)/(define x 1)/(defiNE x 1)/\u0026hellip; éƒ½ä¸ä¼šå¼•å‘é”™è¯¯.\nHistory variable (procedure): é‡ç”¨ REPL æ±‚å€¼åè¿”å›çš„ procedure:\n1 ]=\u0026gt; (average-dump square) ;Value: #[compound-procedure 12] ; å¯ä»¥åœ¨åç»­è¡¨è¾¾å¼ä¸­é‡ç”¨, å°±åƒ gdb ä¸­çš„ history variable `$1` 1 ]=\u0026gt; (#[compound-procedure 12] 10) ; è™½ç„¶ä¹Ÿä¸æ˜¯å¾ˆæ–¹ä¾¿ç›´æ¥ä½¿ç”¨, ä½†æ˜¯ç¡®å®æ˜¯èƒ½ç”¨ ;Value: 55 1 ]=\u0026gt; (define newfunc #[compound-procedure 12]) ; å¯ä»¥ç»‘å®šåˆ°ä¸€ä¸ªæ ‡è¯†ç¬¦ä¸Š, å†å¤ç”¨ ;Value: newfunc 1 ]=\u0026gt; (newfunc 10) ;Value: 55 åè®° ä¸çŸ¥é“æ˜¯å¦æœ‰æ›´å¥½ç”¨çš„ Scheme REPLï¼Œè¿™ä¸ª REPL ç¡®å®æ˜¯æ¯”è¾ƒåŸå§‹ï¼Œä¸æ”¯æŒå†å²è¡¨è¾¾å¼çš„å›æº¯ï¼Œä¸æ”¯æŒå…‰æ ‡ç§»åŠ¨ï¼Œä½†æ˜¯ä¸€æƒ³åˆ° lisp å†å²è¿™ä¹ˆæ‚ ä¹…ï¼Œè¯­æ³•æœ¬èº«ååˆ†ç®€æ´çº¯å‡€ï¼Œæˆ‘å°±æ¥å—äº†ä¸€åˆ‡ã€‚ï¼ˆä¸åƒå†™ Haskell çš„æ—¶å€™ LSP å‡ºäº†é—®é¢˜ï¼Œæˆ‘å¿…é€šè¿‡é‡å¯ VSCode / é‡å¯ç”µè„‘ / æ›´æ”¹ LSP ç‰ˆæœ¬å…ˆæŠŠ LSP é‡æ–°æ‹‰èµ·æ¥ï¼Œè€Œä¸æ˜¯å…ˆæŠŠä»£ç å†™äº†ã€‚ï¼‰\n","date":"2024-08-24T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/mit-scheme-configuration-and-basic-usage/","title":"MIT-Scheme Configuration and Basic Usage"},{"content":" ghcup ä¿®å¤ ç»ˆç«¯ä½¿ç”¨ ghcup ç›´æ¥è¢«æ€è¿›ç¨‹ï¼Œè¾“å‡ºå¤§è‡´å¦‚ï¼šghcup terminated by SIGKILL\nä½¿ç”¨ ghcup å®˜ç½‘ä¸Šçš„å‘½ä»¤é€šè¿‡ curl é‡æ–°å®‰è£…ï¼Œä¼šå¾—åˆ°ä¸€å¥çº¢è‰²çš„æŠ¥é”™ä¿¡æ¯\u0026quot;ghcup --metadata-fetching-mode=Strict upgrade\u0026quot; failed!\nä¸çŸ¥é“æ˜¯ä¸æ˜¯å› ä¸ºå¤ªä¹…æ²¡æ‰“å¼€äº†ï¼Œè§£å†³æ–¹å¼æ˜¯æ¸…é™¤ç¼“å­˜ï¼šrm -rf ~/.ghcup/cache\nghcup é…ç½®ç¯å¢ƒ ghcup tuiä¸‹è½½å’Œè®¾ç½® HLS å’Œ ghcï¼ˆä»¥åŠ stack, cabalï¼‰ç‰ˆæœ¬ï¼Œ\nghc ç‰ˆæœ¬ï¼šæ³¨æ„ ghc çš„å¤‡æ³¨ä¿¡æ¯ä¸­éœ€è¦æœ‰ hls-poweredï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘çš„ mac ä¸Šçš„ç‰ˆæœ¬æ˜¯ 9.4.7ï¼Œæ­£å¥½æ²¡æœ‰ hls æ”¯æŒï¼ˆ9.8.4æ˜¯æœ‰ hls æ”¯æŒçš„ï¼‰ï¼Œå½“æ—¶ä¸‹è½½çš„æ—¶æœºè¿™ä¹ˆåˆšå¥½å—ã€‚\nHLS ç‰ˆæœ¬ï¼šVSCode çš„ Haskell æ’ä»¶ä¼šè¦æ±‚ HLS æ˜¯æœ€æ–°çš„ç‰ˆæœ¬ï¼Œæ‰€ä»¥å°±ç›´æ¥ä¸‹æœ€æ–°çš„ç‰ˆæœ¬å§ï¼ŒVSCode å¼¹å‡ºæç¤º\u0026quot; Haskell æ’ä»¶éœ€è¦ 2.9.0.1 çš„ HLSï¼Œæ˜¯å¦ä¸‹è½½\u0026quot;ï¼Œè¿™é‡Œçš„ä¸‹è½½æ¯”è¾ƒæ…¢ï¼Œè€Œä¸”çœ‹ä¸åˆ°è¿›åº¦ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥åœ¨ç»ˆç«¯çš„ ghcup ä¸‹è½½ï¼Œç„¶åå›åˆ°VSCï¼ˆé‡å¯ï¼Ÿåæ­£æˆ‘é‡å¯äº†ï¼‰ï¼Œæ’ä»¶å°±å¯ä»¥æ­£å¸¸ä½¿ç”¨äº†ã€‚\nHLS æ— æ³•æ­£å¸¸å·¥ä½œä¹Ÿå¯ä»¥å°è¯•é€šè¿‡ ghcup tui ä¸‹è½½å¹¶åˆ‡æ¢ HLS çš„ç‰ˆæœ¬ã€‚\nä¸€ä¸ªç½‘ç»œé—®é¢˜ åœ¨ç¬¬ä¸€æ­¥ä¸­ä¿®å¤ ghcup ä¹‹åï¼Œä½¿ç”¨ ghcup ä¼šé‡åˆ°è¿™æ ·çš„æŠ¥é”™ï¼š\næ ¹æ®æç¤ºæ‰§è¡Œï¼šghcup config set downloader Wgetï¼Œå†æ¬¡ä½¿ç”¨ ghcupï¼Œå¾—åˆ°å·®ä¸å¤šä¸€æ ·çš„æŠ¥é”™ï¼š\nå…³äº yamlï¼šå°è¯•è¿‡æœ€åä¸€è¡Œçš„ removing \u0026hellip;yamlï¼Œç»“æœä¸ºæœ¬æœºä¸­ç¡®å®ä¸å­˜åœ¨è¿™ä¸ªæ–‡ä»¶ï¼Œæ‰€ä»¥ä¸æ˜¯è¿™é‡Œçš„é—®é¢˜ã€‚\nè§£å†³æ–¹å¼ï¼šå¤åˆ¶ clash çš„ç»ˆç«¯ä»£ç†å‘½ä»¤ï¼Œå°±ä¸ä¼šæŠ¥è¿™ä¸ªé”™äº†ï¼ŒåŒæ—¶ä¸‹è½½é€Ÿåº¦å¾—åˆ°äº†æå¤§æå‡ã€‚\n","date":"2024-08-16T00:00:00Z","permalink":"http://fyshxfish.github.io/p/fix-haskell-development-environment-vscode--ghcup--hls/","title":"Fix Haskell Development Environment (VSCode + GHCup + HLS)"},{"content":"â€ƒå¦‚ä½•è°ƒè¯•ä¸€ä¸ªrustç¨‹åºï¼Ÿ $ gdb excutable ç®€å•çš„ç¤ºä¾‹ï¼š\næŸ¥çœ‹å˜é‡çš„åœ°å€ï¼š\næ ¼å¼åŒ–p sçš„è¾“å‡ºï¼š\n$17 = alloc::string::String { vec: alloc::vec::Vec\u0026lt;u8, alloc::alloc::Global\u0026gt; { buf: alloc::raw_vec::RawVec\u0026lt;u8, alloc::alloc::Global\u0026gt; { ptr: core::ptr::unique::Unique\u0026lt;u8\u0026gt; { pointer: core::ptr::non_null::NonNull\u0026lt;u8\u0026gt; { pointer: 0x5555555abb80 }, _marker: core::marker::PhantomData\u0026lt;u8\u0026gt; }, cap: alloc::raw_vec::Cap (16), alloc: alloc::alloc::Global }, len: 16 } } æè¦ï¼šp \u0026lt;variable\u0026gt; p \u0026amp;\u0026lt;variable\u0026gt; ptype \u0026lt;variable\u0026gt;\ndbg! è¾…åŠ©è¾“å‡ºè°ƒè¯•ä¿¡æ¯ä¸­çš„æ‰€æœ‰æƒé—®é¢˜ é”™è¯¯çš„ï¼š\ndbg!(var); // move dbg!(var); // invalid reference dbg!å°†æ‹¿èµ°varçš„æ‰€æœ‰æƒ(Move)ï¼Œvarå°±ä¸èƒ½å†ç”¨äº†ã€‚\næ­£ç¡®çš„ï¼š\ndbg!(\u0026amp;var); // or let new_var = dbg!(var); dbg!(\u0026amp;new_var); // if u will å…³äº gdb å¯¹äºæƒ³æ¢ç©¶çš„ä¸œè¥¿ï¼Œä½¿ç”¨gdbå»è¿›è¡Œæ¢ç´¢ï¼Œä¾‹å¦‚ï¼š[enumçš„åº•å±‚è¡¨ç¤ºï¼Ÿ] -\u0026gt; å†™ä¸€ä¸ªç®€å•çš„ä¾‹ç¨‹ï¼Œç¼–è¯‘æˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œç„¶åè¿›è¡Œgdbï¼Œä½¿ç”¨print var print \u0026amp;var x/x \u0026lt;addr\u0026gt;è¿›è¡Œæ¢ç´¢ã€‚\nå…³äºå¯¹ vector çš„å¼•ç”¨ ä¸€ä¸ªæ‘˜å½•\nch08-01\n/* CANNOT COMPILE */ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\nä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•è®©ä¸€ä¸ªVectorçœ‹èµ·æ¥å­˜å‚¨äº†å¤šç§ç±»å‹çš„æ•°æ®ï¼Ÿ ç­”æ¡ˆï¼šè®©Vectorå­˜å‚¨enumï¼Œenumå«æœ‰å¤šç§ç±»å‹çš„variantï¼Œåœ¨æŸç§ç¨‹åº¦ä¸Šå¯ä»¥è¯´Vectorå­˜å‚¨äº†å¤šç§ç±»å‹çš„æ•°æ®ã€‚\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Text(String::from(\u0026#34;word\u0026#34;)), CellType::Float(3.14), ]; let v1 = \u0026amp;v[0]; } enum CellType { Int(i32), Float(f64), Text(String), } gdb è°ƒè¯• enum ç¤ºä¾‹ä¸ gdbï¼ˆä»¥åŠå…¶ä»–REPLï¼‰ä¸­çš„ history variable æºä»£ç ï¼š\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Float(3.14), ]; let v1: \u0026amp;CellType = \u0026amp;v[0]; let v2: \u0026amp;CellType = \u0026amp;v[1]; println!(\u0026#34;END\u0026#34;); } enum CellType { Int(i32), Float(f64), } è°ƒè¯•å®å½•ï¼š\np v1ï¼šæ‰“å°v1: \u0026amp;CellTypeçš„å€¼ï¼Œä¹Ÿå°±æ˜¯æŒ‡é’ˆå€¼ï¼Œå³é™„å¸¦æ•°æ®å­˜å‚¨åœ¨å †ä¸Šçš„åœ°å€ï¼Œæ³¨æ„åˆ°v1, v2å¯¹åº”çš„æ•°æ®å„å æ®äº†16ä¸ªå­—èŠ‚ã€‚ x/4x $1ï¼šæ£€æŸ¥v1æŒ‡é’ˆæŒ‡å‘çš„16å­—èŠ‚ p *v1ï¼šè§£å¼•ç”¨v1æŸ¥çœ‹è¯¥å†…å­˜å¤„å­˜å‚¨çš„å®é™…å€¼ enumåœ¨è®¡ç®—æœºä¸­å­˜å‚¨çš„å®é™…æ•°æ®åˆ†æ\nç¬¬ä¸€ä¸ªå­—èŠ‚åº”è¯¥æ˜¯variantæ ‡è¯†ç¬¦ï¼Œå¯¹åº”å…³ç³»ï¼š0-Int 1-Float Intï¼šé™„å¸¦æ•°æ®å­˜å‚¨åœ¨ç¬¬äºŒä¸ªå­—èŠ‚ï¼Œ0x0000000cå³ä»£ç ä¸­çš„Int(12) Floatï¼šé™„å¸¦çš„æ•°æ®å­˜å‚¨åœ¨ç¬¬ä¸‰ã€å››ä¸ªå­—èŠ‚0x40091eb8_51eb851fæ˜¯3.14çš„IEEE 754 64bitè¡¨ç¤º é—ç•™çš„é—®é¢˜ï¼šä¸ºä»€ä¹ˆä¸Šè¿°ä¸¤å˜ä½“å­˜å‚¨é™„åŠ æ•°æ®çš„ä½ç½®ä¸åŒï¼ŒFloatä¸­çš„0x00005555æ˜¯ä»€ä¹ˆï¼Ÿ gdbçš„ä½¿ç”¨æ‹¾é— (history variable)ï¼š\np var æ‰“å°å‡ºæ¥çš„ $x æ˜¯ä¸€ç§ history variable, ä¾›ç”¨æˆ·åç»­å¤ç”¨çš„ï¼Œç±»ä¼¼çš„ REPL è¡Œä¸ºè¿˜æœ‰bash é‡Œ echo $(ls)ï¼Œmit-scheme ä¹Ÿä¼šä¸ºè¿”å›çš„ procedure ç»™å‡ºä¸€ä¸ªå¯å¼•ç”¨çš„ history variableï¼ˆä¸è¿‡è¿™ä¸ª variable å¾ˆé•¿ï¼Œä¸”åŒ…å«äº† #[] ç­‰ç‰¹æ®Šå­—ç¬¦ï¼ŒçœŸæ­£è¦å¤ç”¨è¿˜æ˜¯è¦å¤åˆ¶ä¸€éæ ‡è¯†ç¬¦ï¼Œç»‘å®šåœ¨æŸä¸ªæ ‡è¯†ç¬¦ä¸Šå†å¤ç”¨ã€‚ï¼‰ã€‚\nRUST_BACKTRACE ä¸å‘½ä»¤è¡Œæ‹¾é— $ RUST_BACKTRACE=1 cargo run $ A=12 B=23 echo \u0026#34;$A $B\u0026#34; åœ¨å‘½ä»¤çš„æœ€å·¦å¯ä»¥å†™ä¸´æ—¶çš„ç¯å¢ƒå˜é‡ã€‚\nèŠ±é‡Œèƒ¡å“¨çš„æŠ€æœ¯ï¼šrustçš„printlnçš„è‰²å½©è½¬ä¹‰ println!(\u0026#34;\\x1b[34mMESSAGE\\x1b[0m\u0026#34;); ä½¿ç”¨\\x1b[34mè¿›è¡Œè½¬ä¹‰\n\\x1bæ˜¯ä»€ä¹ˆï¼Ÿ\n\\xè¡¨åå…­è¿›åˆ¶ï¼Œ1bæ˜¯ESCçš„ASCIIåå…­è¿›åˆ¶ç \nResult\u0026lt;T, E\u0026gt;çš„unwrapå’Œexpect ä¹‹é—´çš„åŒºåˆ«ï¼š é€‚å½“åœ°çœ‹ä¸€äº›åº“å‡½æ•°çš„å®ç°ï¼Œå¯ä»¥å¯¹å°è£…å¥½çš„å‡½æ•°æœ‰æ›´å…·ä½“çš„äº†è§£ï¼Œä¾‹å¦‚Result\u0026lt;T, E\u0026gt;çš„unwrapå’Œexpectï¼Œçœ‹è¿‡æºç å°±å¯ä»¥çŸ¥é“è¿™ä¸¤è€…çš„åŒºåˆ«åœ¨äºä½•å¤„ï¼ˆåªåœ¨äºunwrap_failedçš„msgå‚æ•°ï¼Œè‡³äºunwrap_failedåªæ˜¯ä¸€ä¸ªå¯¹panic!çš„å°è£…ï¼‰ï¼š\nimpl\u0026lt;T, E\u0026gt; Result\u0026lt;Result\u0026lt;T, E\u0026gt;, E\u0026gt; { ... pub fn expect(self, msg: \u0026amp;str) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(msg, \u0026amp;e), } } pub fn unwrap(self) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(\u0026#34;called `Result::unwrap()` on an `Err` value\u0026#34;, \u0026amp;e), } } ... } fn unwrap_failed(msg: \u0026amp;str, error: \u0026amp;dyn fmt::Debug) -\u0026gt; ! { panic!(\u0026#34;{msg}: {error:?}\u0026#34;) } ","date":"2024-08-05T00:00:00Z","permalink":"http://fyshxfish.github.io/p/explore-rust-basic/","title":"Explore Rust (Basic)"}]