[{"content":" 引言 标题的这个问题，其实是一个不太正确的问题，因为对于语言而言，设计先于实现——先设计语言的语法和语义，然后写编译器去检查一个程序语法是否正确，然后根据设定好的语义将它转写成目标机器代码。从“上下文”这个视角去思考，常见情况下，语法是上下文无关的，而语义正是用来处理上下文相关的问题的，x = 1; print(x); 和 x = 2; print(x);，同样是 print(x)，它的上文是不一样的，所以它导致的结果也不一样.\n举例 1 比如：\nfoo = 3 foo = 4 假设对这个程序只做语法分析，那么它符合 Python 语法，也符合 Haskell 语法，但是对它做语义分析，作为一个 Python 程序，它的意思是，“先将 3 赋值给 foo，然后将 4 赋值给 foo”；作为一个 Haskell 程序，它不是一个合格的 Haskell 程序，因为 Haskell 语义不允许做重复的绑定，所以核心原因是，Python 的 = 的语义是赋值（assign），内存覆写，Haskell 的 = 的语义是绑定（name binding），为了保证无副作用、执行顺序无关等特性，只允许单次绑定.\n举例2 - polyglot 下面这个程序改写自 polyglot(computing) wikipedia\n#define a /* echo -e \u0026#34;\\033[34mHello, World! from echo\\033[0m\u0026#34;;// \u0026amp;\u0026gt; /dev/null; x=5; if (($x)) // 2\u0026gt; /dev/null; then return 0; // 2\u0026gt; /dev/null; fi #define e ?\u0026gt; #define b */ #include \u0026lt;stdio.h\u0026gt; #define main() int main(void) #define printf printf( #define true ) #define function function main() { printf \u0026#34;\\033[31mHello, World! from main\\033[0m\\n\u0026#34;true/* 2\u0026gt; /dev/null | grep -v true*/; return 0; } #define c /* main #*/ 它既符合 C 语法，又符合 Bash 语法，然而编译/解释执行它得到的结果不同，因为两个程序的语义不同（当然 C 和 Bash 的语法也是不一样的，polyglot 编写的核心就是利用各语言之间的注释/宏/\u0026hellip;使用的符号不同，符号（广义）的使用和布局正是语法侧关心的事情）：\n","date":"2025-02-17T16:32:00+08:00","permalink":"http://fyshxfish.github.io/p/context-syntax-/-semantic-analysis/","title":"Context \u0026 Syntax / Semantic Analysis"},{"content":"Preface Inspiration came from a lecture by Yanyan Jiang：[算法竞赛入门] 为什么要逼大家用 NOILinux？，有参考，但不完全一样.\nMastering this skill will allow you to—display \u0026ldquo;slides\u0026rdquo; in the terminal. Its practicality is limited, but it’s fun to play with ·^v^·.\nDemo Implementation Overall Framework Directory .sh files are bash scripts for displaying a single slide, .md files are the Markdown content to be rendered, and .png files are the images to be displayed.\nLauncher First, print the cover (essentially outputting a page of rendered text in the terminal), then use read to take input and control slide behaviors such as page flipping, image display, exiting, etc.\n0_flow.sh：\n#!/bin/bash bash ./1_banner.sh ## print the cover pc=1\t# page counter while true do read -p \u0026#34;:\u0026#34; choice ## take input and control slide behaviors if [ \u0026#34;$choice\u0026#34; == \u0026#34;p\u0026#34; ]; then # previous page ((pc--)) bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then # display an image xdg-open ./load_init.png elif [[ $choice =~ ^[1-7]$ ]]; then # go to the specific page pc=$choice bash ./${pc}* elif [ \u0026#34;$choice\u0026#34; == \u0026#34;E\u0026#34; ]; then # exit the script break else # default: next page ((pc++)) bash ./${pc}* fi done Single Page Display Displaying a single page essentially means showing a page of text. The basic steps are:\nClear the previous page\u0026rsquo;s content using clear; Calculate the total number of lines of the rendered text; To center the content vertically, calculate the padding for the top and bottom; Print the top padding, render and print the content text, then print the bottom padding. For example: (2_question.sh)\nclear length=`python3 renderer.py question.md | wc -l` total=`tput lines` sus=$((($total-$length)/2)) for ((i=1; i\u0026lt;=$sus; i++)) do echo done python3 renderer.py question.md for ((i=1; i\u0026lt;$sus; i++)) do echo done Image Display and External Program Calls Use read to take input. When the input is a specific character, use xdg-open to open a specific image. Close it with the ESC key after displaying.\nread -p \u0026#34;:\u0026#34; choice if [ \u0026#34;$choice\u0026#34; == \u0026#34;g\u0026#34; ]; then xdg-open ./picture.png fi Similarly, replacing xdg-open ... with other commands can play audio/video or execute various programs.\nText Rendering ASCII Art for Cover Pages Use figlet to display the theme word and lolcat to color it. Besides the font styles that come with figlet, you can find and download more font styles from figlet-fonts. The \u0026ldquo;Boot\u0026rdquo; shown above corresponds to the command figlet \u0026quot; Boot\u0026quot; -f roman | lolcat -S 30. (Another optional command-line tool is toilet.)\nESC Escape Sequences The printf command can output fancier text in the terminal using \\033 escape sequences. It can achieve simple effects like color, bold, italics, etc., and multiple effects can be combined. For example, the last line in the image corresponds to printf \u0026quot;\\033[2;34;01;21;09myour text\\033[0m\\n\u0026quot;. (This also applies to output in other programming languages. 033 is the octal ASCII code for ESC. The specific colors depend on the terminal\u0026rsquo;s color scheme.)\nMarkdown Rendering glow: glow is a command-line tool, used as glow foo.md. rich: rich is a Python library that can render Markdown. Other Interesting Command-Line Tools asciiquarium\nASCII Art aquarium, very beautiful. You can find the ASCII fish in my avatar here, above the third seaweed from the left in the image below:\noneko\nSummon a little cat, VERY cute:\ncowsay\ndialog\nInteractive TUI dialog boxes, which are also very suitable for single-page slide presentations, for example:\n#!/bin/bash choice=$(dialog --clear --title \u0026#34;Menu\u0026#34; --menu \u0026#34;Make Your Choice\u0026#34; 10 40 3 \\ 1 \u0026#34;Show Greeting\u0026#34; 2 \u0026#34;Enter Something\u0026#34; 3 \u0026#34;Show Figure\u0026#34; 2\u0026gt;\u0026amp;1 \u0026gt;/dev/tty) case $choice in 3) xdg-open ./figure_1.png ;; # SNIP # esac ","date":"2025-02-07T22:52:00+08:00","permalink":"http://fyshxfish.github.io/p/slides-but-in-terminal/","title":"Slides, But in Terminal"},{"content":"Following exercise is from functional and is available on Steam for 29 CNY.\nBasic anything 写出任意一个符合 Lambda Calculus 语法 (1. variable 2. abstraction 3. application) 的 term 即可.\nidentity x: x two arguments x:y: y x squaring f:x: f (f x) indirection f:x:y: f y x Boolean 定义：\nTRUE = t:f: t FALSE = t:f: f IF p:t:f: p t f Simple LC 没有类型系统，所以编程者需要自己确保 p 一定能求值到 TRUE / FALSE，然后 p t f 进一步求值到 t/ f，如果 p 不能被求值到 TRUE / FALSE，那么 p t f 会被保留下来或者产生预期外的求值行为.\n你可以轻松注意到的一点是：IF P A B ≡ P A B，你完全可以在所有使用 IF 的场合省略掉 IF，这不改变语义，同时可以减少一次 reduction，不过为了保证可读性，还是有理由在有点复杂的程序里保留 IF.\nNOT b: b FALSE TRUE 这个看着有点隐隐约约的巧妙. 可以直白地通过 b: IF b FALSE TRUE → b FALSE TRUE 得到，或者利用 TRUE / FALSE 的意义——选第一个 / 第二个——直接得到.\nAND p:q: p q p 如果 p = TRUE，那么 AND p q ≡ q；如果 p = FALSE，那么 AND p q ≡ FALSE ≡ p.\nOR p:q: p p q 如果 p = TRUE，那么 OR p q ≡ p ≡ TRUE；如果 p = FALSE，那么 OR p q ≡ q.\nXOR p:q: p (NOT q) q 类似 AND, OR，可以画个真值表整理思绪.\nPair and List PAIR x:y:f: f x y PAIR A B → (x:y:f: f x y) A B → (f: f A B) 是一个这样的抽象：有序地内涵 A, B，等待一个函数 f 作用于内涵的 A, B，比如当 A, B 是 Boolean，那么，f 可以是 AND / OR / \u0026hellip;（当然语法并不约束 f,A,B 的形状，如果你想写 PAIR TRUE 0 PAIR 解释器不会拦你）\nFST p: p TRUE 当 p = PAIR A B 时, p TRUE → (PAIR A B) TRUE → (f: f A B) TRUE → TRUE A B → A，注意 p 是一个可以接收一个参数 f 的函数，这里我们让它接收 TRUE 函数来选取第一个元素. 在 LC 里，TRUE / FALSE 更恰当的解释是选取其后跟随的第一 / 二个项，而不是表达某个命题的真 / 假，这是有意义的，因为我们写其他高级语言程序的时候，如果我们需要一个 Boolean 值 X ，X 最终的效用往往还是发挥在 then-clause / else-clause 的选择上.\nSND p: p FALSE 类似 FST.\nsimple list 取出列表的第 3 项 (1-indexed)：\nl: FST ( SND ( SND l ) ) 列表是一种简单的递归结构，递归基是空列表，这里用 FALSE 表示，递归步是向某个列表添加元素，这里用 PAIR 实现，e.g. [] ↦ FALSE, 1 ↦ (PAIR 1 FALSE), [1,3] ↦ (PAIR 1 (PAIR 3 FALSE))，注意 [1,3]的例子，如果从向列表添加元素的视角看，表头是最接近 FALSE 的项，越接近 FALSE 的元素索引越小，因为它比较早地被添加进来，在这种解释下，[1,3] ↦ (PAIR 3 (PAIR 1 FALSE))，然而游戏里不采取这个解释，而是和我们熟悉的 [a,b,..] 保持视觉上的对齐，将最晚被添加的项——最左的项——作为表头，在后续涉及升降序的问题的时候记得留意这一点.\nANY 对一个含 3 个 Boolean 的列表，若任一项为 TRUE，返回 TRUE，否则返回 FALSE：\n(l: IF (OR (FST (SND (SND l))) (OR (FST l) (FST (SND l)) ) ) TRUE FALSE ) 直白地按逻辑写即可. 这里的列表是定长的，比较方便，非定长列表就需要递归，见后.\nPUSH (m:l: PAIR m l) 用 PUSH 向列表 l 添加新项 m，根据 $\\eta$-reduction，PUSH ≡ PAIR，所以这里直接写 PAIR 也足够了.\nPOP SND 弹出最外层的项.\nEMPTY l: l (t:x:y: FALSE) TRUE 首先 EMPTY 要接收一个列表，所以它的基本形状是 EMPTY = l: ...，考虑 l' = FALSE 的情形，EMPTY l' ~ᴇxᴘᴇᴄᴛᴇᴅ→ TRUE，根据 FALSE 的选择能力，我们使 EMPTY = l: l 𝕏 TRUE；考虑 l* = PAIR a (PAIR b (...)) = (f: f a (PAIR b (...))) ≈ (f: f a _tail)，把 l* 视作接收一个参数的函数，EMPTY l* = (f: f a _tail) 𝕏 TRUE → 𝕏 a _tail TRUE ~ᴇxᴘᴇᴄᴛᴇᴅ→ FALSE, 那么 𝕏 的工作就是接收后面的 3 项，然后返回 FALSE，所以 𝕏 = (t:x:y: FALSE)，综合以上得到最终的解 EMPTY = l: l (t:x:y: FALSE) TRUE\nRecursion create recursion - Y combinator 动机：LC 中的递归 尝试着在 LC 中定义递归的阶乘函数：\nf = a: IF (EQ a 1) 1 (a * f (a - 1)) 上述的定义是不符合 LC 的语法的，因为 LC 的函数都是匿名函数，不支持通过名称来调用函数（如上面的 f），而递归函数不可避免的需要自指，如何解决这个问题？\n将函数 $F$ 应用于参数 $A$，可以这样表达 $F A$，也可以利用高阶函数这样表达：$(\\lambda fa.\\ f\\ a) F A$，在此基础上，添加一些逻辑，比如表达\u0026quot;参数为 $a$ 和 $p$，函数为 $f$，若 $p\\ a$ 为真，那么返回 $f\\ a$，否则直接返回 $a$ 本身\u0026quot;：$(\\lambda fap.\\ IF\\ (p\\ a)\\ (f\\ a)\\ a)$. 根据这个想法，假设我们的目标阶乘函数为 F，那么 F 满足这个等式，将 (f:a: ..) 记作 F'：\nF = (f:a: IF (EQ a 1) 1 (a * f (a - 1)) ) F ≡ F\u0026#39; F 看等式的右侧，F' 的涵义是，接收函数 f 和参数 a，若 EQ a 1 那么返回 1，否则返回返回 a * f (a - 1). 向 F' 传递递归函数 F，由此得到的函数 F' F 的行为和我们目标的阶乘函数 F 是一致的，从语义上来讲，左右侧相等.\n目前我们有的等式是 F = F' F ①，其中 F' 是已知的 closed term，因为 F 涉及自引，所以不存在 normal form，于是考虑是否存在某个 Y s.t. Y F' = F②，将 ② 代入 ①，Y F' = F' (Y F')，接下来的目标就是解出 Y 的 normal form，得到 Y 之后，目标递归函数 F = Y F' 也随之得到了.\n为什么要试图将 F 分解成 Y F'？\n不严谨地说，从方程的角度看 F = F' F 只有一个未知量 F，将 F 转化成 Y F'，同样只含一个未知量 Y，而 F'已知且和我们的求解目标（递归函数 F）紧密相关.\nY combinator 设计 Y 是一个这样的 term：Y F = F (Y F) = F (F (Y F)) = ....\n为设计满足以上目标的 Y ，做出如下的初步分析：\n根据 inversion lemma，Y 的形状毫无疑问是 (f: ...).\nY 的自指？—— 我们需要重复 Y，或者说构建右侧的 Y.\nFunction / Abstraction is All You Need —— 因为 LC 没有存储，所以 Y F = F (Y F)，等号左右的 Y 并不是同一个 Y，不是值拷贝或者地址拷贝（因为 LC 不提供存储的概念，无处安放值或者地址，这里只有函数），右侧的 Y 需要通过构建得到，与左侧的 Y 在 alpha-conversion 的意义下相等.\n如何重复 F？这很简单，Y = (f: ...) 接收参数 F，在 Y 的函数体内，想怎么重复就怎么重复.\n设计一个 abstraction M 做构建，M 将接收一些必要的参数，在函数体内组织这些参数，形成和 Y 一样的结构.\nY = f: M f ... ~ᴇxᴘᴇᴄᴛᴇᴅ→ M = f: f (Wai f)：毫无疑问，M 需要拿到 Y 的参数 f，M 内部需要建立起和 Y F 一致的结构； Y = f: M f M ... ~ᴇxᴘᴇᴄᴛᴇᴅ→ M = f:m: f (m f m)：因为我们希望 M 可以建立起和 Y F 一致的结构，而 Y 包含了 M，那么 M 也需要包含 M，所以通过参数 m 将 M 原封不动地传进 M. M 的函数体中，最左的 f 实现 f 的再次应用，(m f m) 构建了和左侧的 Y F alpha 等价的结构. Y = f: M f M, 其中 M = f:m: f (m f m)，可以验证这已经是一个可行的 Y 组合子了，Y F = M F M = (f:m: f (m f m)) F M = F (M F M) = F (M F M) = F (Y F). Y 组合子可以有无数种，比如 (a) Y = f: M M f, M = m:f: f (m m f) 这和上文所呈现的 Y 组合子是几乎一样的，只是改变了 M, f 参数的顺序，利用一步 $\\eta$ 规约，使之更简洁——Y = M M, M = ...，这也是图灵给出的 Y 组合子；(b) Y = f: E (E f) E f, E = r:s:f: f (s r s f) 也是可以的，看起来不够简洁，但是理念和上面的陈述是一致的，用 E 接收需要知道的参数，然后做构建，你会发现 E 接收了 E 和 f，又多余地接收了 (E f)，把 (E f) 拿掉并做相应的修改，就得到了本段落陈述的第一种 Y 组合子；(c) 最简洁的 Y = f: (x: f (x x)) (x: f (x x))，它和前面提到的 Y 组合子的区别在于，前面的 Y 组合子是用组合子组成的，比如 4 中的 Y = f: M f M 中的 M 本身也是组合子，而这个 Y 组合子不包含组合子子项.\n小练习：如何实现满足双边延展的 D F D = D (D F D) D = ... 的组合子 D？\n一种解法可以是 D = f:d: d (d f d) d，道理和之前所说的是一致的.\nY 一定要是组合子吗，可以引入自由变量吗？\n假设 Y 包含自由变量 z，因为 Y 包含 z，那么用 M 构建 Y 时也要考虑到 z：\nclosed M：将 z 作为参数传给 M，那么可以在之前的 Y 组合子的基础上修改，得到 Y = f: M f c M, M = f:c:m: f (m f c m)，可以验证，这可以达成 Y F = F (Y F) = ... 的目标，同时你可以注意到引入 z 并没有什么意义，只是平添负担; open M：即 M 本身包含了自由 z，可以尝试 Y = f: K f K z, K = f:k: f (k f k z)这个例子，你会发现这是行不通的： Y F = F (K F K z) z = F (Y F) z = F (F (Y F) z) z，这个 Y 的效果是在左侧不断做 F 的应用，右侧不断产生新的 z. 根据以上的讨论，这个问题的答案是：可以，但没必要. 且从直觉上去理解，随意地引入自由变量也没有意义. 我提出这个问题的原因是，有一瞬间突然觉得 Y 组合子太熟悉了，第一次在 LC 里见到 Y 这个大写字母后面接的就是\u0026quot;组合子\u0026quot;三个字，所以开始考虑，如果不是组合子是否可以.\nY combinator 使用 承接动机部分，我们用 F' = f:a: ... 表达递归函数 f 与其参数 a 之间的应用逻辑，将目标递归函数为 F，那么 F = F' F，因为自引的不合法，考虑用 Y F' 来表示 F，在上一节中我们涉及出了可行的 Y，于是 F = Y F' 就是我们希望得到的目标函数.\n想明白 Y 组合子的使用，本 section 的关卡都很简单了，唯一值得提示的是 1. 使用以往关卡已定义过的函数时，注意函数的参数顺序，例如 FILTER 先传列表，再传过滤依赖的函数，因为 Simple LC 语法层面的约束很少，所以编程者自己要多当心一些 2. 有若干个关卡可能涉及列表反转，所以 REVERSE 可以先写，然后直接拿来用 3. 注意括号配对，可以现在先进的编辑器里先写，确保不犯低级错误，再复制进来评测. 下面给出的答案仅供参考，可以过评测，但未必最简.\nstrip prefix 去除不定长列表前缀的 FALSE：\nY (f:l: IF (FST l) l (f (SND l)) ) ACC Y (a:l:f:i: IF (EMPTY l) i (a (SND l) f (f i (FST l))) ) ALL l: ACC l AND TRUE REVERSE Y (i:c:l: IF (EMPTY l) c (i (PAIR (FST l) c) (SND l)) ) FALSE MAP Y (m:c:l:f: IF (EMPTY l) (REVERSE c) (m (PAIR (f (FST l)) c) (SND l) f) ) FALSE NONE (l: ALL (MAP l NOT)) FILTER Y (m:c:l:f: IF (EMPTY l) (REVERSE c) ( IF (f (FST l)) (m (PAIR (FST l) c) (SND l) f) (m c (SND l) f) ) ) FALSE ZIP Y (z:c:m:n: IF (EMPTY m) (REVERSE c) (z (PAIR (PAIR (FST m) (FST n)) c) (SND m) (SND n)) ) FALSE EQBLIST (m:n: ALL (MAP (MAP (ZIP m n) (p: XOR (FST p) (SND p)) ) NOT ) ) CONCAT (m:n: (Y (g:c:r: IF (EMPTY r) c (g (PAIR (FST r) c) (SND r)) ) ) n (REVERSE m) ) Numerals Church Numeral 用函数表达自然数，两个关键点是 1. 基 (0 := f:x: x) 2. 后继 (SUC)，在基之上不断做后继，就可以得到所有 Church Numeral.\nSUC 给定 Church Numeral n，n 是一个函数，参数为 f, x，n f x 表示将 f 应用于 x $n$ 次，SUC n 是一个函数，这个函数的能力是接收 f, x，将 f 应用于 x $(n+1)$ 次.\n(n: (f:x: f (n f x) ) ) ZERO 利用逻辑运算来判断给定的 n 是不是 f:x: x.\n(n: n (x: AND FALSE x) TRUE) PRE 一个基本的观察是 n = n SUC 0，这里的等号表示内涵等价（intensional equality），那么在 PAIR 0 0 上做 $n$ 次迭代，一轮迭代的工作是：1. 右侧数对齐左侧数 2. 左侧数做一次后继，那么右侧数始终慢左侧数一步，即 $n$ 轮迭代后，左侧数是 n，右侧数是左侧数的后继.\n(n: SND (n (p: PAIR (SUC (FST p)) (FST p)) (PAIR 0 0) ) ) ADD 给定 x, y，目标是给出 x+y，x+y 的含义是：预备接收 f, z，将 f 应用于 z $(x+y)$ 次. 先将 f 应用于 z $x$ 次，得到结果 x f z，再将 f 应用于 (x f z) $y$ 次.\n(x:y: (f:z: y f (x f z)) ) SUB (x:y: (f:z: (y PRE x) f z)) MUL (x:y:f:z: y (x f) z ) DIV (Y (d:c:x:y: IF (ZERO x) 0 ( IF (ZERO (y PRE x)) (SUC c) (d (SUC c) (y PRE x) y) ) ) ) 0 EQ (x:y: AND (ZERO (x PRE y)) (ZERO (y PRE x)) ) MIN (x:y: IF (ZERO (x PRE y)) y x ) MAX (x:y: IF (ZERO (x PRE y)) x y ) More Numerals is odd (n: (n NOT FALSE)) 顺便想起了判断奇偶的递归方法：（看起来还挺有意思的，比熟悉的 mod 2 新鲜一些）\nisEven :: Int -\u0026gt; Bool isEven 0 = True isEven x = isOdd (x-1) isOdd :: Int -\u0026gt; Bool isOdd 0 = False isOdd x = isEven (x-1) increasing list 尾递归：\n(Y (f:c:n: IF (ZERO n) (PAIR 0 c) (f (PAIR n c) (PRE n)) ) ) FALSE 非尾递归：\n(n: REVERSE ( (Y (f:x: IF (ZERO x) (PAIR 0 FALSE) (PAIR x (f (PRE x)))) ) n ) ) decomposition 将给定数分解成 2 的幂之和：\n(Y (f:c:k:n: IF (ZERO n) c (IF (AND (EQ n (MIN k n)) (NOT (EQ k n))) (f c (DIV k 2) n) (f (PAIR k c) (DIV k 2) (SUB n k) ) ) ) ) FALSE 8 * primes 和 sort 都需要大把时间运行（本机测试两关各自耗时都在 30min 左右）\nprimes Y (f:l:p:n: IF (EQ n (FST p)) (PAIR n l) (IF (EQ (FST p) (MAX n (FST p))) (f l (SND p) n) ( IF ( (Y (f:n:p: IF (EQ n (MIN n p) ) (IF (EQ n p) TRUE FALSE ) (f (SUB n p) p) ) ) n (FST p) ) (f (PAIR (FST p) l) p (DIV n (FST p))) (f l (SND p) n) ) ) ) FALSE (PAIR 47 (PAIR 43 (PAIR 41 (PAIR 37 (PAIR 31 (PAIR 29 (PAIR 23 (PAIR 19 (PAIR 17 (PAIR 13 (PAIR 11 (PAIR 7 (PAIR 3 (PAIR 2 FALSE)))))))))))))) sort 选择排序：\nY (f:c:l: IF (EMPTY l) c ( (m: (f (PAIR m c) (FILTER l (x: NOT (EQ x m)) )) ) (ACC l MAX 0) ) ) FALSE trees NODE l:v:r:f: f l v r LEF t: t (l:v:r: l) RIG t: t (l:v:r: r) VAL t: t (l:v:r: v) BEMPTY 类似于列表判空，NODE l v r = f: f l v r，空树用 FALSE := a:b: b，将一个树 t 作为函数使用，若是空树，t A B = FALSE A B = B ~ᴇxᴘᴇᴄᴛᴇᴅ→ TRUE，若不是空树 t A B = (f: f l v r) A B = A l v r B ~ᴇxᴘᴇᴄᴛᴇᴅ→ FALSE，根据以上，B = TRUE, A = l:v:r:x FALSE，所以：\n(t: t (l:v:r:x: FALSE) TRUE ) FIND 判断树 t 中是否存在值为 v 的结点：\nY (f:t:v: IF (BEMPTY t) FALSE (IF (EQ (VAL t) v) TRUE (OR (f (LEF t) v) (f (RIG t) v)) ) ) BSIZE 计算树的规模：\nY (f:t: IF (BEMPTY t) 0 (SUC (ADD (f (LEF t)) (f (RIG t)))) ) BUILD 二叉搜索树的构造：\nY (f:c:l: IF (EMPTY l) c ( f ( ( Y (f:v:t: IF (BEMPTY t) (NODE FALSE v FALSE) ( IF (EQ v (MIN v (VAL t))) (NODE (f v (LEF t)) (VAL t) (RIG t)) (NODE (LEF t) (VAL t) (f v (RIG t))) ) ) ) (FST l) c) (SND l) ) ) FALSE [ 游戏里的 PREORDER 和 INORDER 两个函数似乎反了？ ]\nPREORDER 二叉树的中序遍历：\nY (f:t: IF (BEMPTY t) FALSE (CONCAT (f (LEF t)) (PUSH (VAL t) (f (RIG t)) ) ) ) INORDER 二叉树的前序遍历：\nY (f:t: IF (BEMPTY t) FALSE (PUSH (VAL t) (CONCAT (f (LEF t)) (f (RIG t)) ) ) ) SPLIT 树 t 以 v 为界进行分割：\nY (f:t:v: IF (BEMPTY t) (PAIR FALSE FALSE) ( IF (EQ v (MAX v (VAL t))) ( (p: PAIR (NODE (LEF t) (VAL t) (FST p)) (SND p)) (f (RIG t) v) ) ( (p: (PAIR (FST p) (NODE (SND p) (VAL t) (RIG t) ))) (f (LEF t) v) ) ) ) KTH 对给定的二叉搜索树，给出其中第 k 大的元素，取出树的中序遍历列表中的第 k 项即可：\n(t:k: Y (f:c:l: IF (EQ c 0) (FST l) (f (PRE c) (SND l) ) ) k (PREORDER t) ) inverse 6 对给定的二叉搜索树 t，找出 [1..6] 中的若干个缺席者，升序排列：\nt: IF (BEMPTY t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ( Y (f:c:m:n: IF (EMPTY n) (REVERSE c) ( IF (EQ (FST m) (FST n)) (f c (SND m) (SND n)) (f (PAIR (FST n) c) m (SND n)) ) ) FALSE (PREORDER t) (PAIR 1 (PAIR 2 (PAIR 3 (PAIR 4 (PAIR 5 (PAIR 6 FALSE)))))) ) ","date":"2025-02-02T21:29:00+08:00","permalink":"http://fyshxfish.github.io/p/programming-in-lambda-calculus-basic/","title":"Programming in Lambda Calculus, Basic"},{"content":"-Inspired by Algorithm Design and Analysis course, 2024 Fall-\nIntroduction In this semester\u0026rsquo;s algorithms course, we focused on two major categories of search algorithms: backtracking and branch-and-bound. Previously, I always treated various search algorithms like DFS and BFS separately, comparing their differences. In this article, I aim to abstract search algorithms, expecting to derive familiar search strategies from a concise abstract model.\nAbstracting the Search Model and Process Here\u0026rsquo;s the model I\u0026rsquo;ve summarized, demonstrated in Haskell:\nclass (Ord node) =\u0026gt; Search env node where initN :: env -\u0026gt; node check :: env -\u0026gt; node -\u0026gt; Bool child :: env -\u0026gt; node -\u0026gt; [node] search :: env -\u0026gt; node Search env node: A search requires two elements: the search environment env and the search node node. Since we need to determine the expansion order based on the priority of node, we want node to be orderable, hence the Ord constraint. initN :: env -\u0026gt; node: A search needs initialization. The search tree requires a root node, so we want to generate a simple root node from the search environment env. check :: env -\u0026gt; node -\u0026gt; Bool: A search needs a stopping condition. We need a function to determine if the current node is a solution based on the properties of env. child :: env -\u0026gt; node -\u0026gt; [node]: A search needs to continue. The live nodes of the search tree are expandable, so we need a function child to generate a list of child nodes [node] based on env and the current node. search :: env -\u0026gt; node: The main search function. Its goal is to search within the environment env and eventually return the terminal node node, which is the optimal solution we seek. To implement a search algorithm for a specific problem, we need to define the abstraction of the search environment env, design the node node, and implement the above functions: initN, check, child, and search.\nThe search model can be abstracted, and so can the search process. Therefore, I provide a default implementation of the search function (since initN, check, and child are often strongly tied to the specific problem and need to be provided during instantiation, they cannot rely on default implementations). This function abstracts the basic search process—starting from the root node (initN), checking (check) if the highest-priority node is a solution, returning it if true, otherwise expanding (child) its child nodes, reordering the live node list based on priority, and repeating this process:\nsearch e = let step :: [node] -\u0026gt; node step (n:ns) | check e n = n | otherwise = step $ sort (ns ++ child e n) in step [initN e] Example: Instantiating the TSP Search from the Model Search Environment: The directed weighted graph Graph is abstracted as follows:\ntype Vertex = Int type Distance = Int type Edge = (Vertex, Vertex, Distance) data Graph = Graph { vertices :: [Vertex], edges :: [Edge] } Additionally, the search process relies on graph functions like minOut and distance:\nminOut :: Graph -\u0026gt; [(Vertex, Distance)] minOut (Graph vs es) = [ (v, minimum ds) | v \u0026lt;- vs, let es\u0026#39; = filter (\\(v1, _, _) -\u0026gt; v1 == v) es, let ds = [ d | (_, _, d) \u0026lt;- es\u0026#39;]] distance :: Graph -\u0026gt; (Int, Int) -\u0026gt; Maybe Distance distance (Graph _ []) _ = Nothing distance (Graph vs ((v1, v2, d):es)) (s, t) | s == v1 \u0026amp;\u0026amp; t == v2 = Just d | otherwise = distance (Graph vs es) (s, t) Node Design (TspNode):\nA node needs to store the current cost, the list of visited vertices, and the heuristic value (upper bound of the total cost):\ndata TspNode = TspNode { cost :: Int, visited :: [Vertex], -- reverse heuristic :: Int -- heuristic / priority } deriving (Show) The lower the heuristic value of a node, the higher its expansion priority.\ninstance Ord TspNode where compare :: TspNode -\u0026gt; TspNode -\u0026gt; Ordering compare n1 n2 | heuristic n1 \u0026gt; heuristic n2 = GT | heuristic n1 \u0026lt; heuristic n2 = LT | otherwise = EQ Search Function Instantiation:\nTo make Graph TspNode an instance of the Search type class, we can use the default search implementation. However, we still need to implement the initN, check, and child functions:\ninitN:\nThe root node\u0026rsquo;s cost is 0, the visited list is empty, and the heuristic value is irrelevant since the root node will always be the first to be checked and removed from the live node list, never participating in sorting. Thus, heuristic can be set to 0:\ninitN :: Graph -\u0026gt; TspNode initN _ = TspNode 0 [] 0 If the current node has visited all vertices (starting from the origin, traversing a loop, and returning to the origin), then it is considered a solution:\ncheck :: Graph -\u0026gt; TspNode -\u0026gt; Bool check g (TspNode _ vs _) | length vs == length (vertices g) = True | otherwise = False child:\nBased on the visited list, calculate unvisited adjacent nodes. If all other vertices have been visited, attempt to return to the origin:\nchild :: Graph -\u0026gt; TspNode -\u0026gt; [TspNode] child g n = let upBound :: [Vertex] -\u0026gt; Int upBound vs = sum [ d | (s,d) \u0026lt;- minOut g , s `notElem` vs ] at = if null (visited n) then 0 else head (visited n) -- then-clause only for initNode nodes = [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39; | v \u0026lt;- filter (\\v\u0026#39; -\u0026gt; v\u0026#39; `notElem` visited n \u0026amp;\u0026amp; isJust (distance g (at, v\u0026#39;))) -- or abstract this function to `checkChildValid` ((tail . vertices) g), -- `tail` for drop the origin vertex (0 here) let way = fromJust $ distance g (at, v), let cost\u0026#39; = cost n + way, let visited\u0026#39; = v: visited n, let heuristic\u0026#39; = upBound visited\u0026#39; + cost\u0026#39;] back = case distance g (at, 0) of Just wayback -\u0026gt; let cost\u0026#39; = cost n + wayback visited\u0026#39; = 0: visited n heuristic\u0026#39; = cost\u0026#39; in [TspNode cost\u0026#39; visited\u0026#39; heuristic\u0026#39;] Nothing -\u0026gt; [] in if length (visited n) == length (vertices g) - 1 then back else nodes Overall Program Framework:\nBrief Description of Other Instances We can also represent DFS and BFS using this model. In data structure courses, we often use recursion for DFS and queues + iteration for BFS. In this model, changing the priority criteria of nodes changes the strategy for selecting nodes to expand, thereby altering the search behavior.\nAssume we have a node like this:\ndata Node a = Node { info :: a, -- Problem-specific node information level :: Int, -- The level of the node in the search tree order :: Int -- The order in which the node was generated } DFS always expands the deepest live node in the current search tree. To perform depth-first search in any search environment using this node, the priority should be set to level:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | level n1 \u0026gt; level n2 = LT -- DEPTH first | level n1 \u0026lt; level n2 = LT | otherwise = EQ BFS always expands the earliest generated live node in the current search tree. To perform breadth-first search in any search environment using this node, the priority should be set to order:\ninstance Ord (Node a) where compare :: Node a -\u0026gt; Node a -\u0026gt; Ordering compare n1 n2 | order n1 \u0026gt; order n2 = LT -- BREADTH first | order n1 \u0026lt; order n2 = LT | otherwise = EQ Limitations Lack of Application to More Specific Problems:\nI initially planned to implement classic textbook cases using this model, but—time ran out. The deadline is approaching, so I only provided the instantiation of the TSP problem under this model.\nNumber of Solutions:\nHere, I limited the number of solutions to 1, defaulting to the first solution as the problem\u0026rsquo;s solution. This is effective in some cases, such as the TSP problem implemented here, where the heuristic calculation ensures the first solution is the optimal one. However, there may be other scenarios: (a) the first solution is only an approximation of the optimal solution, which may be found later, or (b) multiple solutions need to be retained. These cases are not handled by the current model.\n","date":"2024-11-24T12:09:00+08:00","permalink":"http://fyshxfish.github.io/p/abstractions-for-search-algorithms/","title":"Abstractions for Search Algorithms"},{"content":"前言 这个学期包含编译系统和算法设计与分析两门专业课，遇到一些问题总会想着放在 Haskell 里实现一下，对于程序构造多少有点新的体会，也度过了对于 Haskell 不平静的狂热期，现在的我已经不会想着到处传教了（☺️）. 本来只是准备随便写写做 0-1 背包的 Haskell 实现中的一些小思考，不过真开始动笔了就越写越正式了，也算是接触 FP / Haskell 以来的一点点小总结. Haskell 官网 对 Haskell 的描述是 \u0026ldquo;An advanced, purely functional programming language\u0026rdquo;，本文试图围绕 \u0026ldquo;purely\u0026rdquo; 做一些讨论：什么是纯，怎么样算不纯，追求纯度的理由是什么，纯度带来的效益是什么.\n首先从 0-1 背包的过程式实现出发，我把过程式实现 1:1 投射到 Haskell 里，感觉这段代码不是很符合 Haskell 的气质（😯），于是回到了递推式，回到了算法课上一笔带过的递归实现，对过程式语言的递推实现和函数式语言的递归实现做了一些比较，看看两者对于“如何避免重复计算的开销”这个问题（不局限于 0-1 背包问题）给出的不同答案，前者利用源代码上的记忆数组，后者则可以利用纯函数的特性，通过求值策略实现减少重复计算.\n一段算法设计与计算模型的讨论：从 0-1 背包问题这个例子里也可以看出\u0026quot;算法设计\u0026quot;其实是不完全独立于编程范式的，也许更合适的说法是，算法设计强相关于物理计算机的实际运行方式，毕竟算法设计除了解决问题，还有一个追求是降低在物理机上运行时的时空计算资源消耗，这和命令式语言的特性是相契合的，而函数式语言有点 Lambda Calculus 虚拟机的意思；比如复杂度的计算，直接把命令式程序的时间复杂度计算方式照搬给函数式程序是有问题的，前者的理论基础是图灵机 - 状态转移次数，后者的理论基础是 $λ$ 演算 - 规约次数，计算模型的不同势必带来一些差异. 因为我们使用的计算机采取冯诺依曼体系结构，即 图灵机的物理实现，所以算法课也采用更接近硬件的命令式的编程范式，还是很合理的. 不由得想起大一上 CPP 程序设计时老师说 “只要冯诺依曼体系结构还存在，我们就\u0026hellip;(后半句忘了)”，不知不觉我已经尝试走了走另一条路. 说起函数式语言的机器这件事情，其实 1970s,1980s 有学者为函数式的语言设计过专门的非冯诺依曼机器（combinator machine, dataflow machine, etc.），后来大家发现在效率的方面，现有机器 + 好的编译器 \u0026gt; 专用机器，可参考 A History of Haskell: Being Lazy With Class, Part I - 2.1\n命令式程序如何避免重复计算 关于过程式的 0-1 背包，你熟悉到几乎可以默写的一段程序：\n回忆：使用 dp 数组，而不是递归的原因是 —— 将递归转为迭代，避免重复计算；另一种陈述是将函数调用 dp(i, j) 的结果存储到内存中的数组 dp[i][j] 里，实现记忆化. int knapsack(int n, int* weight, int* value, int capacity) { int dp[n+1][capacity+1]; // INIT: BASE CASE// for (int j = 0; j \u0026lt;= capacity; j++) dp[0][j] = 0; for (int i = 0;i \u0026lt;= n;i++) dp[i][0] = 0; // DP // for (int i = 1; i \u0026lt;= n;i++) { int w = weight[i], v = value[i]; for (int j = 1; j \u0026lt;= capacity; j++) { if (j \u0026lt; w) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j], dp[i][j-w]+v); } } return dp[n][capacity]; } 将上述代码 1:1 翻译成 Haskell 程序，你将得到：\nimport Data.Array type Value = Int type Weight = Int type Item = (Value, Weight) knapsack01 :: Weight -\u0026gt; [Item] -\u0026gt; Value knapsack01 capacity items = dp ! (n, capacity) where n = length items dp = array((0,0), (n,capacity)) [((i, w), step i w) | i \u0026lt;- [0..n], w \u0026lt;- [0..capacity]] step 0 _ = 0 step _ 0 = 0 step i w | curWgt \u0026gt; w = dp ! (i - 1, w) | otherwise = max (dp ! (i - 1, w)) (curVal + dp ! (i - 1, w - curWgt)) where curVal = fst $ items !! (i - 1) curWgt = snd $ items !! (i - 1) 写的时候感觉不太对劲，第一感觉是：这两段代码没有区别. 这就是在函数式的语言里写命令式程序. 周五晚上我从炸鸡店走出来的时候，有了一些新的想法：\n函数式程序如何避免重复计算 当我们不能像过程式语言那样在内存条里随机存取的时候，当我们建立起一层层抽象的时候，如何追求性能呢？除了在 CSAPP 第五章里学习利用局部性、循环展开、提高并行性等方法，还有什么方式可以提高程序的性能？除了程序员本身从源代码层面提高性能，还可以在哪里优化性能？编译器从程序员手上接管代码，编译器可以做什么？\n0-1 背包：回到起点 所有物品为 $items$，规模为 $N$, 物品属性为价值 $v_i, w_i$，背包总容量为 $W$，定义 $z(i, j)$ 为可选物品为 $items[1..i]$，背包容量为 $j$ 时，可获得的最大价值，那么\n递推基：$\\forall i, j,\\quad z(i, 0) = 0, z(0,j) = 0;$\n递推步：$z(i,j) = max(z(i-1, j), v_i + z(i-1, j-w_i));$\n目标值：$z(N, W)$ 毫无疑问这是递归的结构，在 Haskell 里写递归实现，如同呼吸般自然：\n（NOTE：1. 看到这里也许你已经开始担忧重复计算、内存占用的事情了 ；2. 值得稍稍注意的一点是，这一段代码完全不涉及基于索引的数据存取）\ntype Item = (Value, Weight) knapsack :: [Item] -\u0026gt; Int -\u0026gt; Int -- items + capacity -\u0026gt; maximal value knapsack _ 0 = 0 knapsack [] _ = 0 knapsack ((v,w):items) c = let choose = v + knapsack items (c-w) -- choose current item chxxse = knapsack items c -- not choose current item in if w \u0026gt; c then chxxse else max choose chxxse 严格求值 - 不递归的理由 在背包问题的 C++ （严格求值语言）实现中，我们不用递归的理由是对于性能的追求，因而使用 dp[i][j] 用空间换时间，将递归中的重复计算转换为数组的索引访问. 这个记忆化的工作，除了我们自己做（也就是使用 dp 数组），还可以 —— 交给编译器. 当然这种形式的记忆化就不是在源代码层面上呈现一个记忆数组了，而是通过求值策略来实现. 在讨论求值策略前，先看看什么是纯函数.\n对于 \u0026quot; 纯 \u0026quot; 函数的讨论 函数是什么？/ 函数的表示法 / LUT 的类比 / 编译器行为 / 纯函数的求值策略\n—— 多年以后，面对 \u0026ldquo;函数式程序设计\u0026rdquo;，🐟将会回想起数学老师带她去见识函数的那节遥远的数学课.\n函数是一种映射关系. 体现这种关系的方式，即 函数的表示法，除了函数表达式、函数图像，还有表格.\n如果我们需要一台机器来执行定义域为某有穷集的完全平方函数 f(x, y) = x*x + y*y，除了依赖加法器、乘法器构成的组合逻辑电路，我们还可以用 LUT（LookUp Table），虽然听起来有点离谱，但是它的可行性是不可否认的.\nNOTE: 可能产生的疑惑 - 如何确定 / 如何描述电路实现的函数与我们预期的函数之间的等价性？或者说，我们预期的是函数 $f$，电路实现的是函数 $f\u0026rsquo;$，如何确定 $f\u0026rsquo; \\equiv f$？如果你对 $λ$ 演算（逻辑学）中函数等价的形式化理论感兴趣，可以参看 Lambda Calculus and Combinators, an introduction - Chapter 5~8. 这里 LUT 实现的函数 $f_1\u0026rsquo;$ 与预期函数 $f$ 外延等价（extensional equivalence），组合逻辑实现的函数 $f_2\u0026rsquo;$ 与预期函数 $f$ 内涵等价（intensional equivalence）.\n我们习惯的编译器的行为大致是：看到函数+参数 → 放入组合逻辑电路计算；如果只依赖映射表（LUT），那么编译器的行为大致是：看到函数+参数 → 在 LUT 中查找对应输出，这需要 LUT 存储好所有函数输入对应的输出，于是压力给到 LUT；折中的策略是，第一次见到函数+参数时，利用组合逻辑电路计算，并缓存到 LUT，再次见到这组函数+参数，直接在 LUT 中查找.（函数式有自己的高速缓存:）\n子过程与函数 / 副作用与纯度\n这里我们用函数指代“纯”函数（定义见下），将非纯的过程称为子过程.\n使用 LUT 实现函数的前提是：函数是纯的，即对相同的输入总是返回相同的输出，并且不产生副作用. 形象地说，我们希望 LUT 是严格的，IN / OUT 引脚保持干净，IN 接收函数参数，OUT 给出函数输出，不希望在 IN 之外，再从某个寄存器接进来一个输入，也不希望在 OUT 的旁边，多连接一个寄存器，把寄存器存储值的改变作为函数执行的结果；即 函数本身总是独立于程序的其他部分 - LUT 总是独立于电路的其他部分，不受其他部分影响.\n输入输出的纯度：\naddx 是不纯的，因为这个函数无法保证对于同样的 a 总是给出相同的输出，因为全局变量 x 可能随时被修改，导致修改前后 a + x 的值不同；readOneWord 是不纯的，因为无法保证对于同一个路径 p，始终返回同样的 firstWord，因为 p 对应的文件可能被其他程序随时修改.\nint x; // global int addx(int a){ return a + x; } string readOneWord(path p) { // IO return head(getFile(p)); } 副作用：\ngreeting 是不纯的，因为它产生了 print 的副作用； write 是不纯的，因为它造成了写文件的副作用.\nvoid greeting(string name){ print(f\u0026#34;Hello, {name}\u0026#34;); } void writeLine(path p) { getFile(p).append(\u0026#34;Append this line\u0026#34;); } \u0026ldquo;提纯\u0026rdquo;？\n对于上述的非纯函数，我们可以将副作用分离，得到对应的纯函数如下：\nint addx(int a, int x) { return a + x; } string readOneWord(file f) { string firstWord = head(f); return firstWord; } string greeting(string name){ return f\u0026#34;Hello, {name}\u0026#34;; } file writeLine(file f){ return f.append(\u0026#34;Append this line\u0026#34;); } 分离副作用的示例 / Imperative Shell, Functional Core\n提问：假设有两个类 Camera, FaceRecognizer，Camera 类有一个方法 getFrame 用于从物理摄像头捕获一帧图像，FaceRecognizer 类有一个方法 recognizePerson 用于识别一帧图像中的人脸并返回对应用户名. 若需要实现函数 getFrameAndRecognize 用于捕获当前帧、识别并返回用户名，如何组织程序结构？\n一种答案：将 FaceRecognizer 的实例作为 Camera 的成员，保证 FaceRecognizer 的纯度，即 FaceRecognizer 的方法总是对帧做计算，将 getFrame 这样的副作用分离、止步于 Camera 类.\nclass Camera: self.face_recognizer = FaceRecognizer() def getFrame(): # snip # return frame def getFrameAndRecognize(): frame = getFrame() name = face_recognizer.recognizePerson(frame) return name class FaceRecognizer: def recognizePerson(frame: image): # snip # return name 即：保证功能函数的纯度，并将其作为程序的核心，将 IO 等非纯操作分离到外层 —— Imperative Shell, Functional Core. （此处应有一场 Simon Peyton Jones 的讲座链接，但我一时找不到了.）\n追求纯度的理由\n方便单元测试与维护；\n易于并行；\n可以用查表作为一种求值策略，或者作为求值策略的一部分，避免了重复计算带来的开销.\n语法树与语法图 / 重复计算 / 求值策略\n一些参考资料\nHaskell Wiki - Graph Reduction\n从 Lambda Calculus 角度解释操作语义 call-by-value / call-by-name / call-by-need，可以参考 Types and Programming Language, Section 5.1\n[TODO]\n这一节还没写的原因是：我 也 不 是 很 懂.\ngraph reduction 的图示\n语法树与语法图比较\nlet 对应的语法图（及其 Core 解释？）\n\u0026hellip;\n惰性求值 - 递归的理由 照应本文 3.2 不递归的理由 避免重复计算的方式除了通过显式缓存（记忆数组），还可以依赖编译器采取的求值策略（惰性求值 Lazy Evaluation），将语法树中的所有相同的表达式结点指向同一个结点，实现计算结果的复用.\n其他 前文试图在 命令式语言 / 函数式语言，递归 / 非递归 之间做比较明确的区分，其实，当然递归不是 FP 的专利，记忆化数组也不只是在命令式程序里好用，只是不同语言 / 编程范式本身的特性（例如 C++ 的严格求值 / Haskell 的惰性求值），使得我们对于程序产生了不一样的思考和不一样的惯性. 对于纯度与惰性求值，命令式语言也可以有灵活的求值策略，比如判断函数的纯度，对非纯函数严格求值，对纯函数惰性求值.\n","date":"2024-10-20T19:48:00+08:00","permalink":"http://fyshxfish.github.io/p/how-to-avoid-redundant-computations--pure-functions-and-their-evaluation-strategies/","title":"How to Avoid Redundant Computations + Pure Functions and Their Evaluation Strategies"},{"content":"来自 Lambda-Calculus and Combinator § 4C Theorem 4.20 的 proof 部分，整体意图是证明符合 Definition 4.18 的全称递归函数可以用组合子来表示. 这里对该证明的关键部分，即迭代组合子的构造，做简要的陈述. 也可以理解为：在 Pure Lambda Calculus 中编写一个具有特定终止条件的迭代程序. 如果你好奇 \u0026quot; 如何在 Lambda Calculus 中编写一个指定迭代 / 递归次数的迭代 / 递归函数 \u0026quot; ，可以参考 Lambda-Calculus and Combinator § 4B Theorem 4.11 的 proof 中 $R_{\\text{Bernays}}$ 组合子的构造，这个构造过程也十分精巧.\n递归与迭代：在 $R_{\\text{Bernays}}$ 递归组合子的构造中，求解某个递归函数 $\\phi $ 的值 $ \\phi(n) $，用的方法就是从 $ \\phi(0) $ 开始，做 $n$ 次迭代得到的（大致如下：记递归步更新函数为 $\\chi$，$\\phi(n) = \\chi^n \\phi(0)$）. 迭代和递归是正向与逆向的区别. 本文中的\u0026quot;递归\u0026quot;意在描述\u0026quot;调用自身\u0026quot; 的结构特点，探讨的中心问题还是对迭代（$0 \\rightarrow 1 \\rightarrow \u0026hellip; \\rightarrow n$）问题的求解.\n构造目标 假设有一个检查函数 $X$，迭代的终止条件为 $XY=_{\\beta,w}\\bar{0}$, 我们希望构造一个组合子 $P$,得到最小的符合终止条件的 $Y$. 即从 $Y = \\bar{0}$ 开始，检查 $(XY) = _{\\beta,w}? \\bar{0}$ ，若条件满足，则返回值为此 $Y$，否则继续检查 $X(\\bar{\\sigma}Y)$，我们希望构造一个组合子 $P$ 自动化此检查过程，形式化地，我们预期 $P$ 的行为如下:\n$$ PXY =_{\\beta,w}Y \\quad \\text{, if } XY = _{\\beta,w}\\bar{0};$$\n$$ PXY =_{\\beta,w}PX(\\bar{\\sigma}Y), \\text{ otherwise} $$\n完全尊重预期，写一个 $P$ 组合子：$P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$，其中 $\\textbf{D}=\\lambda xyz.z(\\textbf{K}y)x$, 可以用 $\\textbf{Y}$ 对这个递归的 $P$ 组合子进行求解（$P = \\textbf{Y}(\\lambda uxy.\\textbf{D}y(ux(\\bar{\\sigma}y))(xy))$），使用 $\\textbf{Y} $ 组合子求解出的 $P$ 没有 normal form，这里不采用此 $P$，我们尝试逐层构造一个具备 normal form 的 $P$ 组合子.\n构造过程 基本结构 用高级语言的伪代码表示现有的 $P$:\ncombinator p(x,y): // L1: define p if (xy == 0): return const(y) else: return p(x, σ y) // L5: call p 递归的 $\\lambda $，形如 $P \\equiv \\lambda x. MPN $，像这样的 $\\lambda$-term，符合我们在高级语言程序设计的经验，但是不符合 Lambda Calculus 中的规范，因为 Lambda Calculus 对 $\\lambda$-term 的归纳定义并不包含为 abstraction 赋标识符的规则，我们写 $P$ 等标识符的目的只在于提升可读性和明确表达式结构，而不是借助标识符的复用来像高级语言编程一样定义递归函数. 一个细节是，我们在书里看到的为某个 $\\lambda$-term 记标识符用的符号是 $\\equiv$ 而不是 $=$.\n我们不能通过标识符的复用定义递归不意味着我们不能定义递归，只是我们需要依赖多一层的抽象来构造出 形式上的非递归，事实意义上的递归.\n从高级语言编程的角度出发，如果我们希望用某种方式取代 L5 中对 p 自身的调用，我们可以如下修改我们的代码. 为了两个分支的结构一致，我们设计一个函数列表 t，t 中的两个函数对应两个分支，函数 getCurrentY 将返回当前 y 值，recursion_p 将承担递归的工作：（这里先不考虑函数的具体结构和参数设计/参数传递的问题，后面总有办法的，这里我们只关心整体结构）\nt = [getCurrentY, recursion_p] // list of functions combinator p(x,y): if (xy == 0): return t[0] else: return t[1] 如何在 Lambda Calculus 中表达以上的代码？为了专注于我们目前处理的抽象层次，先将 $P \\equiv \\lambda xy.\\textbf{D}y(Px(\\bar{\\sigma}y))(xy)$ 的结构简化为 $P \\equiv \\lambda xy.\\textbf{D}AB(xy)$\n根据预期 / 上面的伪代码，我们可以写出大致的 $\\lambda $ 框架如下:\n$$ P \\equiv \\lambda xy. T(xy)[params] $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda [params]. \\dots$$ $$ B \\equiv \\lambda [params]. \u0026hellip;$$\n此时 $PXY = _{\\beta,w} T(XY) $，$ XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A; XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B $ .\n我们预期：将分支的具体逻辑放在 $T$ 中，将分支的选择和分支函数参数传递放在 $P$ 中.\n具体细节 上面我们忽略了许多细节，现在是考虑细节的时候了 :)\n首先注意一个事实：我们将分支函数参数传递的工作放在 $P$ 中，意味着无论当前 $P$ 中的 $(xy)$ 将导向哪个分支，我们传递的参数列表都是一致的 / 都只能是一致的. 因为 $(xy) = _{\\beta,w}\\bar{0}$ 对应的情况更简单，只需返回当前 $y$，所以我们延后考虑这一情况，先考虑 $(xy) ≠ _{\\beta,w}\\bar{0}$ 的情况，让前者迁就后者（，因为两个分支都与 $y$ 有关，所以参数列表中必然有 $y$，在这一点上两个分支是有共性的；另一方面，我们甚至可以两个分支函数对应的参数并列传递，然后在 $A$,$B$ 的具体实现中 不对与本分支无关的参数进行绑定）.\n递归（迭代）分支的构造 目标是：$XY \\neq _{\\beta, w} \\bar{0} \\longrightarrow PXY = B \\xlongequal{\\text{expected}} PX(\\bar{\\sigma}Y) $，我们希望函数 $B$ 与 $P$ 中传递的 $[params]$ 应用后得到的 $\\lambda$-term 和 $PXY$ 具备一样的结构（注意不是 $B$ 和 $P$ 两个 abstraction 本身结构一致），只是 $Y$ 位置的值替换成了 $(\\bar{\\sigma}Y)$，为了得到和 $P$ 一样的结构，最简单的方法是——把 $P$ 现有的组件作为 $[params]$ 传递到 $B$（，当然也传递到了 $A$），然后在 $B$ 中把这些组件重组成 $P$ 的结构：\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(uv) $$\n（$ T \\mapsto t, x \\mapsto u, y \\mapsto v$）\n由于 $[params]$ 的传递，现在 $P$ 的结构发生了改变，我们需要让 $B$ 与新的 $P$ 结构同步；另一方面，我们需要在 $B$ 的内部将传递进来的 $y$ （由 $v$ 绑定）变为 $\\bar{\\sigma}y$：\n$$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. \\dots$$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\n做一个检查：当 $XY \\neq _{\\beta, w} \\bar{0}$：\n$ \\quad PXY $ $ = _{\\beta,w} T(XY)TXY $ $ = _{\\beta,w} BTXY $ $ = _{\\beta,w} T(X(\\bar{\\sigma}Y))TX(\\bar{\\sigma}Y) $ $ = _{\\beta,w} PX(\\bar{\\sigma}Y) $ 符合我们的预期，至此，迭代分支的构造就完成了.\n迭代终止分支的构造 目标是：$XY = _{\\beta, w} \\bar{0} \\longrightarrow PXY = A \\xlongequal{\\text{expected}} Y $，在 $B$ 的构造过程中，我们已有的参数列表是 $ t \\mapsto T, u \\mapsto x, v \\mapsto y$，在 $A$ 中，我们只需要把 $y$ 提取出来即可，所以 $A = \\lambda tuv.v$ ，如果你希望和 Definition 4.8 的记法保持一致，那么 $A = \\Pi^3_3$.\n完整 $\\lambda$ $$ P \\equiv \\lambda xy. T(xy)Txy $$ $$ T \\equiv \\textbf{D}AB $$ $$ A \\equiv \\lambda tuv. v (= _{\\beta,w} \\Pi^3_3) $$ $$ B \\equiv \\lambda tuv. q(u(\\bar{\\sigma}v))qu(\\bar{\\sigma}v) $$\nLCaC Theorem 4.20 中的 $P$ 简述 LCaC Theorem 4.20 中给出的 $P$ 定义如下：\n$$ T \\equiv \\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v)) $$ $$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$\n以与前文一致的格式转写：\n$$ P \\equiv \\lambda xy.Tx(xy)(Tx)y $$ $$ T \\equiv \\lambda x.\\textbf{D}AB $$ $$ A \\equiv \\bar{0} $$ $$ B \\equiv \\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v) $$\n在一些时刻把 $(Tx)$ 作为一个整体，让表达式更简洁了一些，同时让 $x$ 和 $T$ 有绑定关系（$T \\equiv \\lambda x\u0026hellip;.$），在 $T$ 的内部依然可以单独地拿出 $x$ 使用；$P$ 中的 $(Tx)$ 闭包，使得传参的形态是 $B(Tx)y$ —— 而不是 $BTxy$ ——让 $A$ 的设计更简洁了，$A \\equiv \\bar{0}$.\n虽然在细节上略有差别，但是整体结构与本文给出的 $P$ 是一致的，我觉得可能是包含一些直觉 / 灵感 / 优化上的差异.\n其他 尝试着展开上面的 $P$:\n$$ \\lambda xy.\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x(xy)(\\lambda x.\\textbf{D}\\bar{0}(\\lambda uv.u(x(\\bar{\\sigma}v))u(\\bar{\\sigma}v))x)y$$\n如果你愿意把以下也全部展开： $ \\textbf{D} = _{\\beta, w} \\lambda xyz.z(\\textbf{K}y)x, \\quad \\textbf{K} = _{\\beta, w} \\lambda xy.x $ $ \\bar{0} = _{\\beta, w} \\lambda xy.y $ $ \\bar{\\sigma} = _{\\beta, w} \\lambda nfz. f (n f z)$ $$ \\lambda xy.\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x(xy)(\\lambda x.(\\lambda xyz.z((\\lambda xy.x)y)x)(\\lambda xy.y)(\\lambda uv.u(x(\\lambda nfz. f (n f z)))u(\\lambda nfz. f (n f z)))x)y$$\n可以说，我们用这一堆符号 + Pure Lambda Culculus 的演算规则完成了一个迭代程序的构造——Programming in Pure Lambda Calculus.\n","date":"2024-09-17T23:48:00+08:00","permalink":"http://fyshxfish.github.io/p/the-construction-of-the-iteration-combinator-lcac-4c-theorem-4.20/","title":"The Construction of the Iteration Combinator - LCaC § 4C, Theorem 4.20"},{"content":"From Types and Programming Languages § 1.2 What Type Systems Are Good For\nA safe language is one that protects its own abstractions. A safe language is completely defined by its programmer\u0026rsquo;s manual.\nComplete abstraction means that users can fully trust the language design, focusing only on the high-level language abstraction layer, without needing to concern themselves with the specific implementation at the hardware level.\nHigh-level languages provide abstractions over physical devices. For example, arrays are abstractions over memory. Programmers expect that arrays can only be modified through explicit update operations (e.g., arr[1] = 1024). \u0026ldquo;Modifying a variable, and some elements in an array are inexplicably changed\u0026rdquo; (e.g., buffer overflow attacks) is a manifestation of broken abstraction. This means that programmers must have a detailed understanding of the layout of variables (abstractions provided by high-level languages) in memory (real physical devices) to write programs that meet expectations.\nThis reminds me of a series of experiments in CSAPP. Since the goal of CSAPP is to examine computer systems from the programmer\u0026rsquo;s perspective, i.e., viewing hardware from a software perspective, if the programming language used is safe, then we can fully trust the abstractions it provides. Consequently, we cannot see the hardware through the software. If C were safe, then the experiments in CSAPP couldn\u0026rsquo;t be done 🧐.\n","date":"2024-09-10T14:10:00+08:00","permalink":"http://fyshxfish.github.io/p/safety-abstraction/","title":"Safety \u0026 Abstraction"},{"content":"Motivation: Abstraction Level Up! 对 2 应用 $3$ 次 square\n1 ]=\u0026gt; (square (square (square 2))) ;Value: 256 2 → x: 对某个数 x 应用 $3$ 次 square\n(define square3 (lambda (x) (square (square (square x))))) square → f: 对某个值 x 应用 $3$ 次某个函数 f\n(define three_times_f (lambda (f x) (f (f (f x))))) $3 → i$ : 对某个值 x 应用 $i$ 次某个函数 f $(i \\in \\mathbb{N})$\n$i=0$\n(define zero_time_f (lambda (f x) (x))) $i=1$\n(define one_time_f (lambda (f x) (f x))) $i=2$\n(define two_times_f (lambda (f x) (f (f x)))) 递归定义 $i$ 次应用\n递归基：\n(define zero_time_f (lambda (f x) (x))) 递归步：\n(define (succ z) (lambda (f x) (f (z f x)))) 递归求解 $i$ 对应的 $i$ 次应用：\n(define (church i) (if (= i 0) zero_time_f (succ (church (- i 1))) ) ) 这就是自然数 $i$ 对应的 Church Encoding.\n在 REPL 中简单做一个测试：对 3 应用 $2$ 次 cube $((3^3)^3=19683)$\n1 ]=\u0026gt; (church 2) ;Value: #[compound-procedure 15] 1 ]=\u0026gt; ( #[compound-procedure 15] cube 3) ;Value: 19683 理解 Church Encoding Church Encoding 不是：\n可以被存储在物理存储器中的，可以用 bit 表示的数字\n为了算数运算（类似 $3.14 × 2.17$ ）而设计\nChurch Encoding 是：\n对 \u0026quot; 计数 \u0026quot; 的抽象 Church Encoding 是对计数过程的一种抽象，在 Lambda Calculus 的语境里，归纳定义 $λ-term$ 的三条规则分别涉及了 $atom$, $abstraction$, $application$，Church Encoding 可以理解为：有一个起始的 $atom$ 和一个 $abstraction$ ，我们希望对这个 $atom$ 进行若干次 $abstraction$ 的应用（$apply$），我们使用更高一层的 $abstraction$ 来抽象对 \u0026quot; 若干次 \u0026quot; 进行计数的过程，这一层对于计数过程的抽象就是 Church Encoding.\nChurch Encoding in Scheme $zero：λf.λx.x$\n对某个 $term$ 进行 $0$ 次任意 $abstraction$ 的应用，返回值依然是原来的 $term$.\n(define zero (lambda (f x) x)) $one：λf.λx.(f x)$ $two：λf.λx.(f (f x))$ $three: λf.λx.(f (f (f x)))$\n(define one (lambda (f x) (f x))) (define two (lambda (f x) (f (f x)))) (define thr (lambda (f x) (f (f (f x))))) 写到 thr 的时候注意到这里的递归结构，递归基毫无疑问是 zero，递归步 succ 如下：\n(define (succ z) (lambda (f x) (f (z f x))) ) 应用举例 Church Encoding 是对计数的抽象，如果我们希望对 2 进行 3 次平方（square）操作： $((2^2)^2)^2=256$\n1 ]=\u0026gt; (thr square 2) ;Value: 256 验证 succ 的正确性：\n1 ]=\u0026gt; (succ (succ (succ zero))) ;Value: #[compound-procedure 17] 1 ]=\u0026gt; (#[compound-procedure 17] square 2) ;Value: 256 参考资料 Church Encoding wiki\nTypes and Programming Languages, Chapter 5 The Untyped Lambda-Calculus\n一则知乎回答\n","date":"2024-09-08T20:13:00+08:00","permalink":"http://fyshxfish.github.io/p/church-encoding-note/","title":"Church Encoding Note"},{"content":"本文概述 SICP § 2.4.3 中描述了以查表（ type × operation 二维表）为实现方式的泛型系统，具体函数被隐藏在泛型函数 + Selector 这样的抽象之下，那么如果将具体函数放在数据 + Selector 这样的抽象之下是什么样的呢，本文呈现了符合此抽象（SICP 中称为 Message Passing）的 Boolean. 接下来从 Message Passing，Haskell 中的 $ 和 Haskell 中的代数数据类型 三个角度聊聊数据与函数之间的关系. Message Passing - 让数据自己携带函数；Haskell $的应用 - 将数据变成某种函数；Haskell中的代数数据类型 - 使用函数构造数据.\n泛型函数：Intelligent Operations 在 2.4.3 这一节中，作者构建了一个泛型系统，泛型是什么呢，是一种抽象；对于若干个具备某种相同特性的类型，如果我们可以对于其中某个类型，依赖这个特性写一个函数，那么我们希望将这个函数推广到具备这个特性的其他类型，例如：对于两个 Int 类型的值，我可以对其最大值进行计算（max Int Int），因为 Int 是可以比较 (Orderable) 的，即，Int 类型提供了 \u0026gt; / \u0026lt; / \u0026hellip; 等比较函数的实现，那么，对于其他可比的（提供比较函数实现的）类型，我们希望可以将 max 推广到这些类型：\nmax :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a max x y = if x \u0026gt;= y then x else y 我们将可比这个特性抽象成 Ord 类型类（type class），max 函数可以作用于任意该类的成员类型.\n当我们在任意 Ord 类的类型上应用 max 函数时，编译器会帮我们找到对应类型的 \u0026gt;= 的具体实现.\n那么如何找到？一种答案是：查表. 当我需要对 Float (type) 执行 max (operation) ，那么我在 type × operation 的笛卡尔积中找到 (Float, max) 对应的函数 (也就是 Float 对应的 max 非泛型具体实现) 就可以了.\nSICP Page 252: 泛型就是把 type × operation 这张表分解成一行一行的，每个泛型函数代表一行. ✨\n数据与函数的边界 Intelligent Operation? WHAT IF Intelligent Data Objects? 在本文上一节中提到的泛型（泛型函数）中，数据作为被操作的客体存在，数据的工作就是被函数作用，我们的泛型针对的是函数（operation），在我们的预期中，我们希望函数是聪明的，比如 max :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; a 是聪明的，对于它所作用的具体类型，它可以\u0026quot;自动\u0026quot;转变成该类型对应的非泛型具体实现 max :: Int -\u0026gt; Int -\u0026gt; Int. 而数据只需要等待被作用就可以了.\n𝐖𝐡𝐚𝐭 𝐢𝐟: 让泛型函数找到数据对应的具体实现 → 让数据找到函数对应的具体实现？从分解 type × operation 表的角度说，将这张表分解成一列一列的，让某种数据（对应generic operation，暂且称之为 generic? data）代表一列，这样如何呢？\n在 SICP 2.1.3 中谈及组合数据的提取时对此就有所呈现，本站的上一篇博客也有提到. 在 SICP 2.1.3 中的侧重点在对组合数据本身的操作（提取字段）上：为了保证列表元素存取前后的一致性，我们将列表写成一个 procedure 向外提供，此 procedure 接收参数，并根据参数返回对应的列表元素.\n这里我们关心的是数据在程序中的行为，即 数据如何与函数、其他数据进行交互，我们希望数据自己携带与其他数据的交互方式，而不是让数据作为只能被其他函数作用的静态实体. 基于这样的想法，尝试着写一个这样符合这样的行为规范的 Boolean.\n携带函数的 Boolean 首先给出类似的 type × operation 二维表，只是简单建模，所以只考虑与（logic_and）或（logic_or）两种运算：\n类似于代表一行的泛型函数，写一个可以代表一列的\u0026quot;数据\u0026quot;，TRUE, FALSE列对应的标识符分别为 tru, fls，如何让数据携带函数，一种答案是 让数据本身就是一个可以接收参数的函数，由参数来提取数据携带的函数：\n(define tru ; (define tru (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) tru_logic_and) ((eq? op \u0026#39;or) tru_logic_or) ) ) ) (define fls ; (define fls (lambda ...)) (lambda (op) (cond ((eq? op \u0026#39;and) fls_logic_and) ((eq? op \u0026#39;or) fls_logic_or) ) ) ) lambda - cond 对应的函数（也就是柯里化的逻辑与或）实现如下：\n(define (tru_logic_and x) (if (eq? x tru) tru fls)) ; 1 AND x (define (tru_logic_or x) tru) ; 1 OR _ = 1 (define (fls_logic_and x) fls) ; 0 AND _ = 0 (define (fls_logic_or x) (if (eq? x tru) tru fls)) ; 0 OR x 在 REPL 中查看 tru fls：毫无疑问两者都是 compound procedure\n1 ]=\u0026gt; tru ;Value: #[compound-procedure 13 tru] 1 ]=\u0026gt; fls ;Value: #[compound-procedure 12 fls] 做一个简单的测试：\n1 ]=\u0026gt; ((tru \u0026#39;and) fls) ;Value: #[compound-procedure 12 fls] 这里我们做了什么事情呢？首先 tru 是接收符号参数的一个 lambda 表达式，(tru 'and) 得到的是 tru_logic_and —— 一个柯里化的逻辑与（也就是已经传入了一个 TRUE 的逻辑与），然后将 tru_logic_and 应用于 fls ，最后的返回值是 compound procedure fls.\n给出图示如下：\n如果表达式长一些：如果忽略一部分括号，看起来就是中缀的逻辑表达式\n1 ]=\u0026gt; ((((fls \u0026#39;or) tru) \u0026#39;and) fls) ; ((0 or 1) and 0) ;Value: #[compound-procedure 12 fls] 如果更偏好前缀调用，可以做一层小封装：\n(define (logic op x y) ((x op) y)) 对 logic 进行测试：\n1 ]=\u0026gt; (logic \u0026#39;and tru fls) ;Value: #[compound-procedure 12 fls] 1 ]=\u0026gt; (logic \u0026#39;or (logic \u0026#39;and fls fls) tru) ; (or (and 0 0) 1) ;Value: #[compound-procedure 13 tru] → Message Passing: 看待数据的另一种视角 上面这种构建 Boolean 的编程风格被称为 Message Passing：一个数据是一个接收操作名（message）的实体，例如：tru 可以接收 'and / 'or 这样的 Message 并返回对应的柯里化函数供我们后续使用. 在这样的视角下，数据本身和数据所携带的方法一样重要，也是\u0026quot;数据即程序\u0026quot;的一种体现. 不知道看到这里的你是否也在此处察觉到了一些面向对象的风味.\nHaskell 中的 $ $ 是一个中缀调用的函数，其类型签名和优先级如下，它的作用是改变表达式求值顺序，一个客观结果是 $ 的使用减少了代码中的括号量，\nghci\u0026gt; :i ($) ($) :: (a -\u0026gt; b) -\u0026gt; a -\u0026gt; b -- Defined in ‘GHC.Base’ infixr 0 $ 将 $ （柯里化）应用于一个值，返回值是一个函数：\nghci\u0026gt; x = 5 :: Int ghci\u0026gt; :t ($ x) ($ x) :: (Int -\u0026gt; b) -\u0026gt; b 一种理解是：($ x) 把 x 从静态数据，变成了一个等待被函数 Int -\u0026gt; b 作用的数据（从类型签名上看，这是一个函数）. 基于这种理解，可以写这样的代码：\nghci\u0026gt; map ($ 5) [(* 2), (+ 10), (^ 3)] [10,15,125] Haskell 中的代数数据类型 经典的代数数据类型对二叉树进行递归定义：\ndata Tree a = Empty | Node a (Tree a) (Tree a) Empty 和 Node 是 Tree a 的值构造子，值构造子就是返回某种类型的值的函数. Empty 是无参构造子，Node 接受 a，Tree a，Tree a三个值参数.\nTree a 是类型构造子，类型构造子是返回某种具体类型的函数，Tree a 接受 a 一个类型参数，返回相应的具体的 Tree 类型. 例如 Tree Int，Tree Char 分别是结点数据类型为 Int, Char 的 Tree.\n这里可以看出 Haskell 非常漂亮的语言设计上的一致性，没有特殊的泛型语法，只有函数贯穿始终.\n","date":"2024-09-07T23:18:00+08:00","permalink":"http://fyshxfish.github.io/p/boolean-from-a-message-passing-perspective-sicp-2.4.3-generics-boundaries-of-data-and-functions/","title":"Boolean from a Message Passing Perspective - SICP § 2.4.3 | Generics | Boundaries of Data and Functions"},{"content":"在看 SICP Section 2.3.4，对这节中 Huffman 树的实现中使用的组合 / 抽象有相当程度的参考.\n其实我应该把代码放在某个仓库里，比如把一些数据结构的 Haskell 实现整合在一个仓库里，但是我还没有这么多可供整合的材料，所以以后再说吧.\n代码链接：Huffman Tree in Haskell\nHuffman 树的 Haskell 实现 数据抽象 type Weight = Int data Symbol = A | B | C | D | E | F | G | H deriving Show data HuffmanTree a = Empty | Leaf a Weight | Node (HuffmanTree a) (HuffmanTree a) [a] Weight deriving Show Symbol + Weight → Leaf 设定对符号 (Symbol / 泛型 a) 根据使用频率/权重 (Weight) 进行 Huffman 编码，将这两个信息整合抽象成 Leaf，对应 SICP 中的 ((define (make-leaf symbol weight) (list 'leaf symbol weight))).\n泛型与类型约束：对符号没有类型约束，对权重的约束是 Weight 属于 Ord typeclass，因为需要权重是可以比较的，这里没有写泛型，直接用 Int 作为权重的类型 .\nHuffmanTree 的递归定义 含 Empty, Leaf, Node 三种构造子:\nEmpty: 空树\nLeaf: 包含符号 a 和权重 Weight 的叶子结点\nNode: 包含左右子树 (HuffmanTree a)、子树符号并集 [a] 和子树总权重 Weight 的分支结点.\nHuffman 树的构建 权重获取 通过模式匹配获取 Leaf，Node的权重.\n这里没有考虑空树 Empty 的情况，如果考虑应该写 getWeight :: HuffmanTree a -\u0026gt; Maybe Weight，匹配到 Empty 时返回 Nothing. 对一种类型做模式匹配时应该匹配到每一个构造子，这是标准的实践.\ngetWeight :: HuffmanTree a -\u0026gt; Weight getWeight (Leaf _ w) = w getWeight (Node _ _ _ w) = w 列表整理 Huffman 树建立的起点是一个有序的叶子列表，建立过程中也需要保持 [HuffmanTree a] 列表的有序. 这一部分的函数的目标是将一个无序的列表整理成一个有序的列表.\n» adjoinLeaf: 根据权重将 HuffmanTree a 插入到已有的有序 [HuffmanTree a] 中. （升序排列）\n» initLeafs: 将已有的无序叶子列表整理成有序的叶子列表.\n» moveFirstNode: Huffman Tree 建立过程中的 Merge 操作将把权重最小的两个 HuffmanTree (Leaf / Node) ——也就是列表前两个元素——组成一个新的 Node，所以 Merge 后需要将新生成的 Node 重新放置，利用此函数实现这个重置.\nadjoinTree :: HuffmanTree a -\u0026gt; [HuffmanTree a] -\u0026gt; [HuffmanTree a] adjoinTree t [] = [t] adjoinTree t (t\u0026#39;:ts) | w \u0026lt; w\u0026#39; = t: t\u0026#39;: ts | otherwise = t\u0026#39;: (adjoinTree t ts) where w = getWeight t w\u0026#39; = getWeight t\u0026#39; initLeafs :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] -- I know pl(leaf) = leaves, btw. ^^ initLeafs [] = [] initLeafs (p:ps) =adjoinLeaf p (initLeafs ps) moveFirstNode :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] moveFirstNode (t:ts) =adjoinLeaf t ts 树的建立 » makeNode: 将两个 HuffmanTree 组合成一个 Node.\n» constructHuffTree: 树的自底向上建立，尾递归建立 Huffman Tree.\n递归步：将当前列表中的前两个元素通过 makeNode 合并成一个父结点 Node，移动父结点得到新的有序列表，对新列表执行递归;\n递归基：列表中只有一个元素，即根结点.\n» initAndConstructHuffTree: 最后的封装，对叶子列表的初始化 initLeafs 和树的建立 constructHuffTree 进行 Point-less 的组合.\nmakeNode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; HuffmanTree a makeNode (Leaf s1 w1) (Leaf s2 w2) = Node (Leaf s1 w1) (Leaf s2 w2) [s1, s2] (w1 + w2) makeNode (Leaf s w) (Node l r ss w\u0026#39;) = Node (Leaf s w) (Node l r ss w\u0026#39;) (s:ss) (w + w\u0026#39;) makeNode (Node l r ss w\u0026#39;) (Leaf s w) = Node (Node l r ss w\u0026#39;) (Leaf s w) (ss ++ [s]) (w + w\u0026#39;) makeNode (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) = Node (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) (ss1 ++ ss2) (w1 + w2) constructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = Empty constructHuffTree [t] = t constructHuffTree (x:y:ts) = constructHuffTree $ moveFirstNode $ (makeNode x y): ts initAndConstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a initAndConstructHuffTree = constructHuffTree . initLeafs Huffman 树的编解码 获取符号编码 Huffman 树的建立过程就是编码过程，这里只是将编码用另一种形式呈现出来.\n此处的编码表示：\ndata Bit = L | R deriving Show type Bits = [Bit] L 对应二进制 0，R 对应二进制 1.\n编码的获取过程就是对 Huffman 树进行遍历与记录的过程：\ngetCode\u0026#39; :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [(a, Bits)] getCode\u0026#39; (Node (Leaf s1 _) (Leaf s2 _) _ _) rec = [(s1, rec ++ [L]), (s2, rec ++ [R])] getCode\u0026#39; (Node (Leaf s\u0026#39; _) node _ _) rec = [(s\u0026#39;, rec ++ [L])] ++ getCode\u0026#39; node (rec++[R]) getCode\u0026#39; (Node node (Leaf s\u0026#39; _) _ _) rec = getCode\u0026#39; node (rec++[L]) ++ [(s\u0026#39;, rec ++ [R])] getCode\u0026#39; (Node nodel noder _ _) rec = getCode\u0026#39; nodel (rec++[L]) ++ getCode\u0026#39; noder (rec++[R]) getCode :: HuffmanTree a -\u0026gt; [(a, Bits)] getCode t = getCode\u0026#39; t [] » getCode'：实现对 Huffman 树的递归遍历\n递归步：对于一个结点，对左右子树进行匹配，对非叶结点（node）继续递归遍历，在 rec 中记录途径的分叉方向.\n递归基：当对左/右子树匹配到 Leaf 时，表明已经抵达了一个 Symbol，此时的 rec ++ [L] / rec ++ [R] 就是 Symbol 对应的编码.\n模式匹配的解释：回顾 Huffman 树的构造过程，我们总是把两个结点合并成其父结点，所以不存在某个子树为 Empty 的情况，也即——每个分支结点的模式都是 Node lhs rhs _ _；同时，我们将 Leaf 作为递归基，不再对 Leaf 做递归，这就是为什么这里只对不同形态的 Node 构造子做模式匹配，并把含 Leaf 递归基的情形放在前面的原因.\n» getCode：对 getCode' 做一个封装，给 rec 一个起始值 []，即 在 Huffman 树的根节点，没有任何途径记录.\n解码 基本思路：根据 Bit 在树上移动，L - 向左子树移动，R - 向右子树移动，抵达子树为 Leaf 时，完成一个字符的解码，此时回到根节点继续对下一个字符解码，直到 Bit 列表为空.\n-- decode one symbol decodeOne :: HuffmanTree a -\u0026gt; Bits -\u0026gt; (a, Bits) decodeOne (Node (Leaf s _) _ _ _) (L:bs) = (s, bs) decodeOne (Node _ (Leaf s _) _ _) (R:bs) = (s, bs) decodeOne (Node node _ _ _) (L:bs) = decodeOne node bs decodeOne (Node _ node _ _) (R:bs) = decodeOne node bs -- decode from scratch decode :: HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode _ [] = [] decode t bs = let (s, remainBits) = decodeOne t bs in s: decode t remainBits » decodeOne:\n递归基：当前 Bit 对应的子树为 Leaf ，即完成了一个字符的解码，将该字符和剩余的 Bit 返回\n递归步：当前 Bit 对应的子树为 Node ，继续在该 Node 上递归解码，直到遇到递归基的情况\n» decode:\n递归基：Bit 列表为空，代表解码完毕.\n递归步：Bit 列表非空，将根结点和当前 Bit 列表交给 decodeOne 进行单字符的解码，单字符解码完毕后，继续对剩余的 Bit 在根节点上做单字符解码，直到 Bit 列表空.\n» 如何回到根节点：\n一开始写的函数类型签名是这样的 decode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a]，两个 HuffmanTree 分别是原始根节点和当前所在的根节点，实现大致如下：\ndecode\u0026#39; :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; Bits -\u0026gt; [a] decode\u0026#39; originT (Node (Leaf s _) _ _ _) (L:bs) = s: (decode\u0026#39; originT originT bs) --snip-- 看着不是很舒服，因为 originT 这个参数在递归过程中没有变过，所以稍稍改变了递归结构，写了上面的 decode 和 decodeOne. SICP 中使用闭包来记忆初始根节点.\n组合数据 (compound data) 的结构与解构 (construct / extract) SICP (Scheme): Blur the Barrier of Data and Procedure / abstraction barrier 一致性 我们希望将有结构的数据——而不是散落的变量——作为程序的组件，所以有了组合数据 (compound data)，比如 struct / class，于是出现的问题是，如何把用于构造 compound data 的字段重新提取出来，提取的行为需要保证的一件事情是：字段被提取前后行为是一致的，主要是编译器的工作，如果一定要在源代码的层面上去体现这一点，如何做到？在此处贴 SICP 2.1.3 (Page 124) 的示例代码：\n(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \u0026#34;Argument not 0 or 1: CONS\u0026#34; m)))) dispatch) (define (car z) (z 0)) (define (cdr z) (z 1)) Exercise 2.4 (Page 125) 中的通过 lambda 实现也很漂亮：\n(define (cons x y) (lambda (m) (m x y))) (define (car z) (z (lambda (p q) p))) （用 Pure Lambda Calculus 实现此例，参见本节的最后一小节.）\nSICP 这一章重点呈现的一个点是: 数据（data）与程序（procedure）的分界线并不是那么泾渭分明的. 以上的两个程序很准确地体现了这一点：列表的构造子返回的是一个 procedure，该 procedure 提供了访问组成列表的元素的接口，所以可以基于此定义 car/ cdr.\n数据的组合与提取 → 程序的构造：抽象层 组合这件事情在 LISP (LISt Programming) 中是简洁的，数据的组合方式就是构造列表，如 (list 1 2 3) / (list 3 4 (list 9 7) 5).\n而处于程序之中的数据不可能直接以这样的形式在函数之间流转，所以有了抽象层:\nconstructor (make-rat) 和 selector (denom, numer) 是从基本类型 (primitive data type) 到组合数据 (compound data) 的一次抽象，给了程序（在此抽象层之上的函数，add-rat / sub-rat）一个更高的视角去看待数据，数据不再只是零散的整型/浮点型，而是可以被构造 / 提取 / 分析的 rat；在 add-rat / sub-rat 之上的函数无需关心 rat 的实现细节，只需使用 add-rat 等运算来解决问题即可. 程序的构造过程是抽象层次提升的过程.\nHaskell: Pattern Match 写过 Lisp 会更懂 Haskell 的好，就像写过 C 可以更好地体会 Python 开发的便捷，这里只是考量语法的易用性，没有对于性能/应用场景等其他方面的比较.\n在 Scheme 中写 (define (make-leaf symbol weight))/ (define (leaf? object )) / (define (weight tree)) 这样的函数写得太多的时刻，会想 Haskell 中是如何应对数据的构造和提取这个问题的呢？\n构造：\n声明一种组合数据的语法如下：\ndata Point = Point Int Int 定义了 Point 类型，对应一个构造子 Point Int Int，即后续可以通过此构造子构造 Point 类型的组合数据，比如 p = Point 1 2.\n提取：\n模式匹配 Pattern Match\n一个简单的例子:\ngetX :: Point -\u0026gt; Int getX (Point x _) = x 值得注意的一点是：如何构造（Point Int Int）这个组合数据就如何去匹配它 （Point x _），形式是一样的.\n如何结构，就如何解构.\n很多语言都有 Pattern Match 的语法，但是 Haskell 设计得真的太丝滑，我写这篇博客的目的就在于呈现上面加黑的那句话.\n这个语法提供的一个优势是，可以对函数参数通过 Pattern Match 做解析，比如上面的例子：\nconstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = ... -- 空叶子列表 → 返回空树 constructHuffTree [t] = ... -- 只有一个叶子 → 返回只有根节点的树 constructHuffTree (x:y:ts) = ... -- 有两个及以上叶子 → 递归建立 Huffman 树 呈现出来的表现是：函数参数被解构的方式，决定了函数的行为.\n比如对于这样的问题：求解二叉树的节点的数量\ndata Tree a = Empty | Node a (Tree a) (Tree a) treeSize :: Tree a -\u0026gt; Int treeSize Empty = 0 treeSize (Node _ left right) = 1 + treeSize left + treeSize right 使用 Empty 构造子构造出的空树 → 直接返回 0 (递归基)\n使用 Node 构造子构造出的非空树 → 递归求解 (递归步)\n数据的构造方式决定了我们对数据的处理方式，而在 Haskell 中，构造数据的形式和对数据进行模式匹配的形式是一致的，所以可以在函数参数位做模式匹配，一种模式对应一种函数行为.\nLambda Calculus - pair abstraction Pure Lambda Calculus 中的 pair abstraction 上面一致性这一节提到的例子，可以使用纯 Lambda Calculus 来实现1：\npair = λm λn λb. b m n pair v w = λb. b v w 这样的 abstraction 提供的视角是：通过对 pair 的两次应用（application），对 m, n 进行实例化，即 确定 pair 中所含的元素，剩下的 b 为后续在 pair 元素上进行的操作留接口. 若想对 pair 中的元素进行按序提取，可定义 fst 和 snd：\nfst = λa λb. a snd = λa λb. b (pair v w) fst → v // 根据 left associativity convention，这里的括号是可以省略的 (pair v w) snd → w 如果你更希望以 fst (pair v w) 这样的编程风格呈现，当然也可以做到：\ntru = λt λf. t // α 等价于上一个代码段定义的 `fst`，我们可以对同一个抽象做不同的理解 fls = λt λf. f // ... `snd` ... fst = λp. p tru snd = λp. p fls fst (pair v w) → v snd (pair v w) → w 再次审视这个 abstraction：pair = λm λn λb. b m n. Lambda Calculus 中将我们惯常称之为函数的结构称为 abstraction（抽象），这里的 pair abstraction 就对 pair 的构造与操作进行了抽象，我们首先通过外层参 m, n 确定包含的元素，构建 pair，最后通过内层参 b 来执行对已有元素的操作；在这样的视角下，pair 天然具备与 Lambda Calculus 体系内其他函数（abstraction）交互的属性，因为在实例化 pair 元素之后，它向外界提供 b 这个交互接口，等待其他 abstraction 与 pair 已有的元素通过应用（application）交互.\nBöhm’s theorem 对于 (pair v w) fst 这样的结构，假定 a,b,c,d 是不同的四个符号，可以想见 (pair a b) fst 和 (pair c d) fst 的值必然是不同的，提高此观察的抽象程度，我们可以陈述：对于不同的抽象，应用相同的操作，得到的值不同. Lambda Calculus 和 Combinator Logic 里的 Böhm\u0026rsquo;s theorem 2 如下：\nIn λ and CL: let $M$ and $N$ be combinators, either in βη-normal form (in λ) or in strong normal form (in CL). If $M \\not\\equiv N$, then there exist $n ≥ 0$ and combinators $L_1$, \u0026hellip;, $L_n$ such that $$ ML_1 \u0026hellip;L_nxy \\quad \\rhd_{\\beta,w} \\quad x, $$ $$ NL_1 \u0026hellip;L_nxy \\quad \\rhd_{\\beta,w} \\quad y. $$ Roughly speaking, Böhm’s theorem says that $M$ and $N$ can be distinguished, not just by their structure, but by their behaviour.\nBöhm\u0026rsquo;s theorem 提供的视角是：在不等的两个组合子（即不含自由变量的 λ-term）上应用相同的操作，得到的值不同；即 我们可以通过组合子的行为来对不同组合子进行区分. 上文提到的 (pair v w) fst 就是一个简单的例子，(pair a b) 和 (pair c d)是不同的组合子，将此二者施以同样的操作 fst ，得到的值不同. 我们在 Scheme 中实现的 cons - dispatch 也可以用这个思路来理解.\nTypes and Programming Languages - Chapter 5 The Untyped Lambda-Calculus\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLambda-calculus and Combinators, an introduction - 3C Theorem 3.11\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-02T01:53:00+08:00","permalink":"http://fyshxfish.github.io/p/huffman-tree-implementation-in-haskell-sicp-2.3.4-structuring-and-destructuring-of-composed-data/","title":"Huffman Tree Implementation in Haskell - SICP § 2.3.4 | Structuring and Destructuring of Composed Data"},{"content":"Problem Description Problem: Given a positive integer $n$, find all ordered pairs of distinct positive integers $i$ and $j$, where $ 1 \\leq i \\leq j \\leq n $, such that $ i + j $ is prime.\nImplementation in Haskell isDivisible :: Int -\u0026gt; Int -\u0026gt; Bool isDivisible x y | mod x y == 0 = True | otherwise = False isPrime :: Int -\u0026gt; Bool isPrime x | x \u0026lt;= 2 = True | otherwise = not (foldr (||) False (map (isDivisible x) [2..((floor . sqrt . fromIntegral) x)])) genPairs :: Int -\u0026gt; [((Int, Int), Int)] genPairs n = do x \u0026lt;- [1..n] y \u0026lt;- [1..(x-1)] return ((y, x), (x + y)) sumPrimePairs :: Int -\u0026gt; [((Int, Int), Int)] sumPrimePairs = (filter (\\(_, s) -\u0026gt; (isPrime s))) . genPairs About List Monad: Context, Nested lambda and do-notation Context of List Monad : nondeterministic result.\nThe title of this section is Nested Mappings, represented in code with nested lambdas. In Haskell, do notation is syntactic sugar for nested lambdas.\nAnd flatMap defined in this chapter is actually Haskell \u0026gt;\u0026gt;= (bind) in Haskell.\nFor further details, consult Learn You a Haskell for Great Good: A Fistful of Monads - the List Monad\nAnother Example: The List Monad for Permutation An intuitive way to understand this is that nondeterministic results are well-suited for solving permutations.\npermutations :: Eq a =\u0026gt; [a] -\u0026gt; [[a]] permutations [] = [[]] permutations xs = do x \u0026lt;- xs perm \u0026lt;- permutations $ removeByElem x xs return (x: perm) removeByElem :: Eq a =\u0026gt; a -\u0026gt; [a] -\u0026gt; [a] removeByElem x = filter (/= x) ","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/nested-mapping-examples-implemented-in-haskell-sicp-2.2.3-list-monad/","title":"Nested Mapping Examples Implemented in Haskell - SICP § 2.2.3  | List Monad "},{"content":" let 的语义 结论: let scope 会立即求值 (包括绑定和绑定之后的表达式, 也就是 let 之外的一层括号所包裹的范围), 即使你把 let 嵌套在内层函数里而且这个函数还完全没有被调用.\n示例:\n(define (comp x) (if (\u0026gt; 3 x) (display \u0026#34;then-clause\u0026#34;) (display \u0026#34;else-clause\u0026#34;) ) #| (define foo1 (let ((bar1 (/ 2 0))) ; * evaluted immediately (display \u0026#34;should not be printed\u0026#34;) ) ) |# (define foo2 (let ((bar2 (/ 5 2))) ; * evaluted immediately (newline) (display \u0026#34;let in `foo2`, bar2: \u0026#34;) (display bar2) ) ) ) 运行示例:\nfoo1: 可以看到 let 绑定被求值了, 否则不会抛出除零异常.\nprompt\u0026gt; (comp 4) else-clause ;Division by zero signalled by /. ;To continue, call RESTART with an option number: ;snip foo2: 可以看到 let 绑定后的表达式被求值了, 否则不会有 display 的输出\nprompt\u0026gt; (comp 2) then-clause let in `foo2`, bar2: 5/2 ;Unspecified return value if 的语义 if的语义: 根据对条件式进行求值，根据求值结果决定继续对 then/else 分支进行求值.\n可以与此对照参考的材料是 SICP (2nd Edition) Exercise 1.6，此题中使用 abstraction ，通过 cond 定义了 new-if:\n(define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause) ) ) 函数应用的语义是（applicative mode evaluation）：先对参数（比如这里的then-clause 和 else-clause）进行求值，然后进行函数应用，这也是为什么不能在then-clause 或 else-clause里写递归表达式，因为它们会先被求值，而不是根据 predicate 的值决定是否求值，于是递归就无穷无尽了. if/cond/\u0026hellip; 是 special form, 相较于通过 define 定义的 abstraction, 语义是特殊的. 我喜欢 new-if 这个例子，它简洁而有力地体现了 lisp 元编程的特性，通过此例也可以更好地接纳 lisp 里大量的括号，根据 substitution model, 这里的 predicate, then-clause, else-clause 可以替换成你需要的表达式, 而表达式就是被括号包裹的, 即 括号是表达式的边界, 你可以把被括号包裹的表达式放在任意的参数位 (当然要符合 abstraction 隐式的对于参数的类型约束).\nlet 立即求值引发的错误实例 对于这样素数判断的一段代码：\n(define (prime? x) (if (or (= x 1) (= x 2)) #t test_prime ) (define (divisible? y) (= 0 (remainder x y)) ) (define (iter_biggest_divisor y) (cond ((= y 1) 1) ((divisible? y) y) (else (iter_biggest_divisor (- y 1))) ) ) (define test_prime (let ((biggest_divisor (iter_biggest_divisor (quotient x 2)) )) ; Notice (display biggest_divisor) (if (= biggest_divisor 1) #t #f ) ) ) ) 运行的结果是:\nprompt\u0026gt; (prime? 1) ;The object 0, passed as the second argument to integer-remainder, is not in the correct range. prompt\u0026gt; (prime? 2) 1 ;Value: #t 按照预期, (prime? 1) 和 (prime? 2) 都应该直接返回 #t, 而不是前者报错, 后者呈现出 (display biggest_divisor) 的行为. 根据前文的陈述, 原因是: 整个 let scope 都被求值了.\n","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/semantics-of-let-in-schemefeat.-semantics-of-if/","title":"Semantics of `let` in Scheme(feat. Semantics of `if`)"},{"content":"包含对于 VSCode 作为文本编辑器的配置，不包含对语言环境的配置.\nAbout: Command Palette \u0026amp; Ctrl + Shift + P 关于 Ctrl + Shift + P: 首先在这里贴蒋炎岩老师的一场与VSCode相关的讲座，Ctrl+Shift+P：如果需要做某些事情，可以先尝试用 Ctrl+Shift+P 打开命令面板搜索（比如也许你想重新加载 VSCode 窗口，就可以 Ctrl+Shift+P 打开命令面板，然后搜索 \u0026ldquo;reload window\u0026rdquo; ），如果发现自己需要经常做这个动作，那么就 Ctrl+K Ctrl+S 进入 Keyboard Shortcuts 为这个操作绑定快捷键吧，配置快捷键的哲学在于：发现自己经常重复做某件事情，有一个瞬间发现自己不想用鼠标再次重复这个过程，于是去检索记忆 / 配置这个热键。\nLayout 让 VSCode 的界面更简洁：隐藏 Activity Bar 和 Status Bar 其实并不是时时刻刻都需要看到 Activity Bar 和 Status Bar，如果你也觉得它们占用了宝贵的屏幕空间，那么可以绑定以下快捷键：\nView: Toggle Activity Bar Visibility - Ctrl+Shift+9\nView: Toggle Status Bar Visibility - Ctrl+Shift+8\n为什么是 Ctrl+Shift+8/9：因为 Shift+9 对应的字符是左括号，和 Activity Bar 在形态上略有相似，顺手把 Status Bar 对应的快捷键设置为 Ctrl+Shift+8，键位近比较顺手，因为我总是同时关闭此二者的可见性；想快捷键还是一个不那么容易的事情，一方面这里的快捷键语义含量没有那么高，另一方面容易和已有的键位绑定冲突，设置完了一段时间不用又会忘记，然后发现 Ctrl+Shift+P 检索才是永远的家.\nTerminal: Move Terminal to Editor Area 并置终端 tab 和代码 tab.\nCtrl+Shift+P → 在命令面板中检索 Terminal: Move Terminal to Editor Area ，即可将终端放置到 Editor Area，其他类似操作还有 Move Terminal to Panel, Create New Terminal in Editor Area\u0026hellip;当然，可以为你经常使用的操作绑定快捷键。\n一种适用的场景是：如果你在学习某种编程语言，而这种语言（比如 Haskell, Lisp, Python\u0026hellip;）刚好有REPL，你就可以在 Editor Area 切分，一半放代码，一半放 Terminal REPL，如果需要，可以编辑文件，然后在 REPL 中导入代码文件（像Haskell ghci中的:l foo.hs），这样就很方便，可以通过 Ctrl+1/Ctrl+2 在代码 tab 和终端 tab 之间做 Focus 的切换；视觉上我认为这样的体验也一些，比默认的上下分屏更好（毕竟更多情况下电脑的屏幕水平边比竖直边长，这也是为什么我喜欢竖直向的浏览器标签栏）.\n还有一种类似的实现：通过 Ctrl+Shift+B 打开 Secondary Side Bar，把终端拖到 Secondary Side Bar.\nEditor Area Rainbow Brackets 在Settings(GUI)中键入 @id:editor.bracketPairColorization.enabled @id:editor.guides.bracketPairs，选择你需要的选项，editor.bracketPairColorization.enabled 是默认启用的，editor.guides.bracketPairs是默认关闭(false)的，可以选择 true 或者 active 启用， true 的效果是所有括号都有引导线， active 的效果是只有最接近光标的外层括号有引导线，我觉得 active 就足够了，效果如下：\n顺便一个快捷键：Ctrl+Shift+\\，可以在当前文本对应的左右括号之间跳转，可以用来检查表达式嵌套的层级，对应 Vim Normal Mode 下的%.(P.S. 此快捷键在 Terminal 中使用，可以用来在不同的 Terminal tab 中跳转)\n起因是我最近在看 SICP ，这本书使用的语言是 lisp (scheme)，这门语言的括号实在是多(，真的有其他语言的语言设计中具备比lisp更多的括号吗？) 于是我在 Extensions 中搜索 Rainbow Brackets ，对应插件表示项目已放弃维护，因为此特性已由 VSCode 内置，并为我指路至 Settings(GUI) 的配置具体位置。\nHotKey Baseline\n将光标悬停在 GUI 的 button 上，如果该 button 有对应的快捷键，弹出的悬窗会呈现快捷键信息（很多程序都遵循这个设计哲学），所以如果发现自己经常点击某个键，不妨停下来看看它对应的热键是什么.\nCtrl-b：toggle side bar.\n这里对应的一个故事是，有人给 VSCode 提了一个issue，希望 VSCode 提供一个类似 toggleExplorerVisibility 配置项，然后一个用户回复 \u0026ldquo;Ctrl-B to toggle side bar\u0026rdquo; 并关闭了此issue. 为什么我会知道这件事情，因为我也以为我的需求是 toggleExplorerVisibility，结论是：明确每个组件的称呼很重要。(但是，一个热键对应 toggle，两个热键分别对应 show / hide，前者应该更合理一些.)\nAlt-left/right Arrow：回退到上一光标位置/前进到下一光标位置\n比较有用的一个情景是：和 F12 配合，在函数的调用链里导航.\nCtrl-[/]：对光标所在行左移/右移缩进。\n同 Vim Visual Mode 下的 \u0026gt;/\u0026lt;. Vim 的这个键位我用着一直不是很顺，因为选中之后只能进行一次操作，如果想再做一次缩进，那要再选一次，虽然是可以2 \u0026gt;这样向右缩进两个tab，但是对我来说还是没有那么顺，自从发现在编辑中使用 Ctrl/Shift/Alt 可以做一些跳转/选中等操作，我就很少离开Vim Insert Mode了，当然这些热键在语义化的方面是比不过 Vim 的键位.\nAlt-up/down Arrow：上移/下移光标所在行.\nShift-Alt-f: format 代码，前提是配置好了 formatter.\n于是我不再需要手动调空格/空行的数量，Ctrl + V 的时候也不必担心光标所在列，粘贴完一键 format 完事，很可惜像 Python 这样强制缩进的语言不太好 format.\nCtrl-(Shift-)Enter: 在当前光标所在行下(上)方新建一行，光标跳转到新行行首.\n同 Vim Normal Mode 下的 o(O).\nExtensions Bluloco Light Theme (Author: Umut Topuzoğlu)\n非常漂亮的主题，我的 Wezterm 使用的也是这个主题.\nRemove empty lines (Author: Alexander)\n删除选区内的所有空行. 可以通过 Ctrl + Shift + P 调用，也可以为其绑定快捷键.\nMisc 一些写在 User Settings (JSON) 里的小配置，包含:\n配置 VSCode-Vim 插件:\n与 VSCode 默认键位冲突处理\n使用系统剪切板\n智能相对行号（只在 Insert Mode 使用绝对行号）\n改变悬停窗口（如 Language Server 提供的函数描述）的背景色;\n默认缩放等级，因为我之前打开 VSCode 做的第一件事总是 ^+ 调大一次 Zoom Level;\n彩虹括号引导线设置.\n{ \u0026#34;vim.smartRelativeLine\u0026#34;: true, \u0026#34;vim.useSystemClipboard\u0026#34;: true, \u0026#34;vim.handleKeys\u0026#34;: { // 如你所见，我是一个非常不纯的 Vim 用户 \u0026#34;\u0026lt;C-c\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-x\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-a\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-s\u0026gt;\u0026#34;: false, // save \u0026#34;\u0026lt;C-z\u0026gt;\u0026#34;: false, // undo \u0026#34;\u0026lt;C-[\u0026gt;\u0026#34;: false, // outdent line \u0026#34;\u0026lt;C-]\u0026gt;\u0026#34;: false, // indent line \u0026#34;\u0026lt;C-b\u0026gt;\u0026#34;: false, // toggle side bar \u0026#34;\u0026lt;C-o\u0026gt;\u0026#34;: false, // open files \u0026#34;\u0026lt;C-k\u0026gt;\u0026#34;: false, // leading key for ... }, \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editorHoverWidget.background\u0026#34;: \u0026#34;#edeeee\u0026#34;, // 设置悬停提示的背景颜色 }, \u0026#34;window.zoomLevel\u0026#34;: 1, \u0026#34;editor.guides.bracketPairs\u0026#34;: \u0026#34;active\u0026#34; } ","date":"2024-08-26T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/my-vscode-configuration/","title":"My VSCode Configuration"},{"content":" Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. \u0026ndash; Antoine de Saint-Exupéry\n通过包管理器下载 mit-scheme MacOS:\nbrew install mit-scheme Ubuntu:\nsudo apt-get update sudo apt-get install mit-scheme REPL 基本使用 （REPL: Read-Evaluate-Print Loop）\n进入 REPL:\nmit-scheme 在 REPL 加载中加载 scheme 代码:\n1 ] =\u0026gt; (load \u0026#34;path/to/file.scm\u0026#34;) (后缀 .scm 可以省略.)\n查看手册:\nman mit-scheme 命令行查看 mit-scheme CLI 手册, 很简短, 可以通过命令行参数指定堆栈大小 / 加载文件 / 同时打开编辑器/ \u0026hellip;\n按下 Ctrl-C 后键入 H 查看中断手册:\nCtrl-C: 接收下一个键盘输入, 决定中断行为.\nCtrl-G: 回到 top-level\nCtrl-Z: 挂起当前 mit-scheme 进程\n按下 Ctrl-C 后键入 ? 查看手册: 下一键盘输入 (option) 与 REPL 行为 (清屏 / 挂起 / 退出 / 忽略中断 / \u0026hellip;) 的对应关系;\n如果 REPL 没有反应:\n检查括号是否逐对匹配;\nCtrl-C 中断后回到 REPL, 提示符 (1 ] =\u0026gt; / 2 error\u0026gt;) 不会重新显示.\n担心递归太深? 递归深度超限时, REPL 会提示 Recursion depth limit exceeded. Aborting! (3.1 中提到可以通过 CLI 参数指定堆栈大小, 即, mit-scheme使用的堆栈资源是有限的.)\nScHeMe Scheme 是大小写不敏感的语言.\n所以 (LoAd \u0026quot;path/to/file.scm\u0026quot;)/(DEFINE x 1)/(define x 1)/(defiNE x 1)/\u0026hellip; 都不会引发错误.\nHistory variable (procedure): 重用 REPL 求值后返回的 procedure:\n1 ]=\u0026gt; (average-dump square) ;Value: #[compound-procedure 12] ; 可以在后续表达式中重用, 就像 gdb 中的 history variable `$1` 1 ]=\u0026gt; (#[compound-procedure 12] 10) ; 虽然也不是很方便直接使用, 但是确实是能用 ;Value: 55 1 ]=\u0026gt; (define newfunc #[compound-procedure 12]) ; 可以绑定到一个标识符上, 再复用 ;Value: newfunc 1 ]=\u0026gt; (newfunc 10) ;Value: 55 后记 不知道是否有更好用的 Scheme REPL，这个 REPL 确实是比较原始，不支持历史表达式的回溯，不支持光标移动，但是一想到 lisp 历史这么悠久，语法本身十分简洁纯净，我就接受了一切。（不像写 Haskell 的时候 LSP 出了问题，我必通过重启 VSCode / 重启电脑 / 更改 LSP 版本先把 LSP 重新拉起来，而不是先把代码写了。）\n","date":"2024-08-24T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/mit-scheme-configuration-and-basic-usage/","title":"MIT-Scheme Configuration and Basic Usage"},{"content":" ghcup 修复 终端使用 ghcup 直接被杀进程，输出大致如：ghcup terminated by SIGKILL\n使用 ghcup 官网上的命令通过 curl 重新安装，会得到一句红色的报错信息\u0026quot;ghcup --metadata-fetching-mode=Strict upgrade\u0026quot; failed!\n不知道是不是因为太久没打开了，解决方式是清除缓存：rm -rf ~/.ghcup/cache\nghcup 配置环境 ghcup tui下载和设置 HLS 和 ghc（以及 stack, cabal）版本，\nghc 版本：注意 ghc 的备注信息中需要有 hls-powered，不知道为什么我的 mac 上的版本是 9.4.7，正好没有 hls 支持（9.8.4是有 hls 支持的），当时下载的时机这么刚好吗。\nHLS 版本：VSCode 的 Haskell 插件会要求 HLS 是最新的版本，所以就直接下最新的版本吧，VSCode 弹出提示\u0026quot; Haskell 插件需要 2.9.0.1 的 HLS，是否下载\u0026quot;，这里的下载比较慢，而且看不到进度，所以可以直接在终端的 ghcup 下载，然后回到VSC（重启？反正我重启了），插件就可以正常使用了。\nHLS 无法正常工作也可以尝试通过 ghcup tui 下载并切换 HLS 的版本。\n一个网络问题 在第一步中修复 ghcup 之后，使用 ghcup 会遇到这样的报错：\n根据提示执行：ghcup config set downloader Wget，再次使用 ghcup，得到差不多一样的报错：\n关于 yaml：尝试过最后一行的 removing \u0026hellip;yaml，结果为本机中确实不存在这个文件，所以不是这里的问题。\n解决方式：复制 clash 的终端代理命令，就不会报这个错了，同时下载速度得到了极大提升。\n","date":"2024-08-16T00:00:00Z","permalink":"http://fyshxfish.github.io/p/fix-haskell-development-environment-vscode--ghcup--hls/","title":"Fix Haskell Development Environment (VSCode + GHCup + HLS)"},{"content":" 如何调试一个rust程序？ $ gdb excutable 简单的示例：\n查看变量的地址：\n格式化p s的输出：\n$17 = alloc::string::String { vec: alloc::vec::Vec\u0026lt;u8, alloc::alloc::Global\u0026gt; { buf: alloc::raw_vec::RawVec\u0026lt;u8, alloc::alloc::Global\u0026gt; { ptr: core::ptr::unique::Unique\u0026lt;u8\u0026gt; { pointer: core::ptr::non_null::NonNull\u0026lt;u8\u0026gt; { pointer: 0x5555555abb80 }, _marker: core::marker::PhantomData\u0026lt;u8\u0026gt; }, cap: alloc::raw_vec::Cap (16), alloc: alloc::alloc::Global }, len: 16 } } 提要：p \u0026lt;variable\u0026gt; p \u0026amp;\u0026lt;variable\u0026gt; ptype \u0026lt;variable\u0026gt;\ndbg! 辅助输出调试信息中的所有权问题 错误的：\ndbg!(var); // move dbg!(var); // invalid reference dbg!将拿走var的所有权(Move)，var就不能再用了。\n正确的：\ndbg!(\u0026amp;var); // or let new_var = dbg!(var); dbg!(\u0026amp;new_var); // if u will 关于 gdb 对于想探究的东西，使用gdb去进行探索，例如：[enum的底层表示？] -\u0026gt; 写一个简单的例程，编译成可执行文件，然后进行gdb，使用print var print \u0026amp;var x/x \u0026lt;addr\u0026gt;进行探索。\n关于对 vector 的引用 一个摘录\nch08-01\n/* CANNOT COMPILE */ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n一个问题：如何让一个Vector看起来存储了多种类型的数据？ 答案：让Vector存储enum，enum含有多种类型的variant，在某种程度上可以说Vector存储了多种类型的数据。\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Text(String::from(\u0026#34;word\u0026#34;)), CellType::Float(3.14), ]; let v1 = \u0026amp;v[0]; } enum CellType { Int(i32), Float(f64), Text(String), } gdb 调试 enum 示例与 gdb（以及其他REPL）中的 history variable 源代码：\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Float(3.14), ]; let v1: \u0026amp;CellType = \u0026amp;v[0]; let v2: \u0026amp;CellType = \u0026amp;v[1]; println!(\u0026#34;END\u0026#34;); } enum CellType { Int(i32), Float(f64), } 调试实录：\np v1：打印v1: \u0026amp;CellType的值，也就是指针值，即附带数据存储在堆上的地址，注意到v1, v2对应的数据各占据了16个字节。 x/4x $1：检查v1指针指向的16字节 p *v1：解引用v1查看该内存处存储的实际值 enum在计算机中存储的实际数据分析\n第一个字节应该是variant标识符，对应关系：0-Int 1-Float Int：附带数据存储在第二个字节，0x0000000c即代码中的Int(12) Float：附带的数据存储在第三、四个字节0x40091eb8_51eb851f是3.14的IEEE 754 64bit表示 遗留的问题：为什么上述两变体存储附加数据的位置不同，Float中的0x00005555是什么？ gdb的使用拾遗 (history variable)：\np var 打印出来的 $x 是一种 history variable, 供用户后续复用的，类似的 REPL 行为还有bash 里 echo $(ls)，mit-scheme 也会为返回的 procedure 给出一个可引用的 history variable（不过这个 variable 很长，且包含了 #[] 等特殊字符，真正要复用还是要复制一遍标识符，绑定在某个标识符上再复用。）。\nRUST_BACKTRACE 与命令行拾遗 $ RUST_BACKTRACE=1 cargo run $ A=12 B=23 echo \u0026#34;$A $B\u0026#34; 在命令的最左可以写临时的环境变量。\n花里胡哨的技术：rust的println的色彩转义 println!(\u0026#34;\\x1b[34mMESSAGE\\x1b[0m\u0026#34;); 使用\\x1b[34m进行转义\n\\x1b是什么？\n\\x表十六进制，1b是ESC的ASCII十六进制码\nResult\u0026lt;T, E\u0026gt;的unwrap和expect 之间的区别： 适当地看一些库函数的实现，可以对封装好的函数有更具体的了解，例如Result\u0026lt;T, E\u0026gt;的unwrap和expect，看过源码就可以知道这两者的区别在于何处（只在于unwrap_failed的msg参数，至于unwrap_failed只是一个对panic!的封装）：\nimpl\u0026lt;T, E\u0026gt; Result\u0026lt;Result\u0026lt;T, E\u0026gt;, E\u0026gt; { ... pub fn expect(self, msg: \u0026amp;str) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(msg, \u0026amp;e), } } pub fn unwrap(self) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(\u0026#34;called `Result::unwrap()` on an `Err` value\u0026#34;, \u0026amp;e), } } ... } fn unwrap_failed(msg: \u0026amp;str, error: \u0026amp;dyn fmt::Debug) -\u0026gt; ! { panic!(\u0026#34;{msg}: {error:?}\u0026#34;) } ","date":"2024-08-05T00:00:00Z","permalink":"http://fyshxfish.github.io/p/explore-rust-basic/","title":"Explore Rust (Basic)"}]