[{"content":"在看 SICP Section 2.3.4，对这节的组合 / 抽象有相当程度的参考.\n其实我应该把代码放在某个仓库里，比如把一些数据结构的 Haskell 实现整合在一个仓库里，但是我还没有这么多可供整合的材料，所以以后再说吧.\nHuffman 树的 Haskell 实现 type Weight = Int data HuffmanTree a = Empty | Leaf a Weight | Node (HuffmanTree a) (HuffmanTree a) [a] Weight deriving (Show, Eq) data Symbol = A | B | C | D | E | F | G | H deriving (Show, Eq) getWeight :: HuffmanTree a -\u0026gt; Weight getWeight (Leaf _ w) = w getWeight (Node _ _ _ w) = w adjoinTree :: HuffmanTree a -\u0026gt; [HuffmanTree a] -\u0026gt; [HuffmanTree a] adjoinTree t [] = [t] adjoinTree t (t\u0026#39;:ts) | w \u0026lt; w\u0026#39; = t: t\u0026#39;: ts | otherwise = t\u0026#39;: (adjoinTree t ts) where w = getWeight t w\u0026#39; = getWeight t\u0026#39; moveFirstNode :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] moveFirstNode (t:ts) = adjoinTree t ts initLeafs :: [HuffmanTree a] -\u0026gt; [HuffmanTree a] -- I know pl(leaf) = leaves, btw. ^^ initLeafs [] = [] initLeafs (p:ps) = adjoinTree p (initLeafs ps) makeNode :: HuffmanTree a -\u0026gt; HuffmanTree a -\u0026gt; HuffmanTree a makeNode (Leaf s1 w1) (Leaf s2 w2) = Node (Leaf s1 w1) (Leaf s2 w2) [s1, s2] (w1 + w2) makeNode (Leaf s w) (Node l r ss w\u0026#39;) = Node (Leaf s w) (Node l r ss w\u0026#39;) (s:ss) (w + w\u0026#39;) makeNode (Node l r ss w\u0026#39;) (Leaf s w) = Node (Node l r ss w\u0026#39;) (Leaf s w) (ss ++ [s]) (w + w\u0026#39;) makeNode (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) = Node (Node l1 r1 ss1 w1) (Node l2 r2 ss2 w2) (ss1 ++ ss2) (w1 + w2) constructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = Empty constructHuffTree [t] = t -- singleton leaf constructHuffTree (x:y:ts) = constructHuffTree $ moveFirstNode $ (makeNode x y): ts initAndConstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a initAndConstructHuffTree = constructHuffTree . initLeafs 组合数据 (compound data) 的结构与解构 (construct / extract) SICP: Blur the Barrier of Data and Procedure 我们希望将有结构的数据——而不是散落的变量——作为程序的组件，所以有了组合数据 (compound data)，比如 struct / class，于是出现的问题是，如何把用于构造 compound data 的字段重新提取出来，提取的行为需要保证的一件事情是：字段被提取前后行为是一致的，主要是编译器的工作，如果一定要在源代码的层面上去体现这一点，如何做到？在此处贴 SICP 2.1.3 (Page 124) 的示例代码：\n(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \u0026#34;Argument not 0 or 1: CONS\u0026#34; m)))) dispatch) (define (car z) (z 0)) (define (cdr z) (z 1)) Exercise 2.4 (Page 125) 中的通过 lambda 实现也很漂亮：\n(define (cons x y) (lambda (m) (m x y))) (define (car z) (z (lambda (p q) p))) SICP 这一章重点呈现的一个点是: 数据（data）与程序（procedure）的分界线并不是那么泾渭分明的. 以上的两个程序很准确地体现了这一点：列表的构造子返回的是一个 procedure，该 procedure 提供了访问组成列表的元素的接口，所以可以基于此定义 car/ cdr.\nHaskell: Pattern Match 写过 Lisp 会更懂 Haskell 的好，就像写过 C 可以更好地体会 Python 开发的便捷，当然我只是考量语法的易用性，没有对于性能/应用场景等其他方面的比较.\n在 Scheme 中写 (define (make-leaf symbol weight))/ (define (leaf? object )) / (define (weight tree)) 这样的函数写得太多的时刻，会想 Haskell 中是如何应对数据的构造和提取这个问题的呢？\n构造：\n声明一种组合数据的语法如下：\ndata Point = Point Int Int 定义了 Point 类型，对应一个构造子 Point Int Int，即后续可以通过此构造子构造 Point 类型的组合数据，比如 p = Point 1 2.\n提取：\n模式匹配 Pattern Match.\n一个简单的例子:\ngetX :: Point -\u0026gt; Int getX (Point x _) = x 值得注意的一点是：如何构造（Point Int Int）这个组合数据就如何去匹配它 （Point x _），形式是一样的.\n如何结构，就如何解构.\n很多语言都有 Pattern Match 的语法，但是 Haskell 设计得真的太丝滑，我写这篇博客的目的就在于呈现上面加黑的那句话.\n这个语法提供的一个优势是，可以对函数参数通过 Pattern Match 做解析，比如上面的例子：\nconstructHuffTree :: [HuffmanTree a] -\u0026gt; HuffmanTree a constructHuffTree [] = ... -- 空叶子列表 -\u0026gt; 返回空树 constructHuffTree [t] = ... -- 只有一个叶子 -\u0026gt; 返回只有根节点的树 constructHuffTree (x:y:ts) = ... -- 有两个及以上叶子 -\u0026gt; 递归建立 Huffman 树 呈现出来的表现是：函数参数被解构的方式，决定了函数的行为.\n比如对于这样的问题：求解二叉树的节点的数量\ndata Tree a = Empty | Node a (Tree a) (Tree a) treeSize :: Tree a -\u0026gt; Int treeSize Empty = 0 treeSize (Node _ left right) = 1 + treeSize left + treeSize right 使用 Empty 构造子构造出的空树 → 直接返回 0 (递归基)\n使用 Node 构造子构造出的非空树 → 递归求解 (递归步)\n数据的构造方式决定了我们对数据的处理方式，而在 Haskell 中，构造数据的形式和对数据进行模式匹配的形式是一致的，所以可以在函数参数位做模式匹配，一种模式对应一种函数行为.\n","date":"2024-09-02T01:53:00+08:00","permalink":"http://fyshxfish.github.io/p/huffman-%E6%A0%91%E7%9A%84-haskell-%E5%AE%9E%E7%8E%B0-sicp-2.3.4-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E8%A7%A3%E6%9E%84/","title":"Huffman 树的 Haskell 实现 - SICP § 2.3.4  | 组合数据的结构与解构"},{"content":"问题 Problem: Given a positive integer $n$, find all ordered pairs of distinct positive integers $i$ and $j$, where $ 1 \\leq i \\leq j \\leq n $, such that $ i + j $ is prime.\nHaskell 实现 isDivisible :: Int -\u0026gt; Int -\u0026gt; Bool isDivisible x y | mod x y == 0 = True | otherwise = False isPrime :: Int -\u0026gt; Bool isPrime x | x \u0026lt;= 2 = True | otherwise = not (foldr (||) False (map (isDivisible x) [2..((floor . sqrt . fromIntegral) x)])) genPairs :: Int -\u0026gt; [((Int, Int), Int)] genPairs n = do x \u0026lt;- [1..n] y \u0026lt;- [1..(x-1)] return ((y, x), (x + y)) sumPrimePairs :: Int -\u0026gt; [((Int, Int), Int)] sumPrimePairs = (filter (\\(_, s) -\u0026gt; (isPrime s))) . genPairs 关于 List Monad: Context, 嵌套 lambda 与 do-notation Context of List Monad : 不确定的结果.\n此章的标题是 Nested Mappings, 在代码层面的表现是嵌套的 lambda, Haskell 中的 do-notation 展开形式就是嵌套的 lambda, 前者是后者的语法糖.\n此章中定义的 flatMap 就是 Haskell 中的 \u0026gt;\u0026gt;= (bind).\nList Monad 实现全排列 2024-08-30 补充： SICP page 168 集合全排列的 Haskell 实现\npermutations :: Eq a =\u0026gt; [a] -\u0026gt; [[a]] permutations [] = [[]] permutations xs = do x \u0026lt;- xs perm \u0026lt;- permutations $ removeByElem x xs return (x: perm) removeByElem :: Eq a =\u0026gt; a -\u0026gt; [a] -\u0026gt; [a] removeByElem x = filter (/= x) ","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/nested-mappings-%E6%A1%88%E4%BE%8B%E7%9A%84-haskell-%E5%AE%9E%E7%8E%B0-sicp-2.2.3-list-monad/","title":"Nested Mappings 案例的 Haskell 实现 - SICP § 2.2.3  | List Monad "},{"content":" let 的语义 结论: let scope 会立即求值 (包括绑定和绑定之后的表达式, 也就是 let 之外的一层括号所包裹的范围), 即使你把 let 嵌套在内层函数里而且这个函数还完全没有被调用.\n示例:\n(define (comp x) (if (\u0026gt; 3 x) (display \u0026#34;then-clause\u0026#34;) (display \u0026#34;else-clause\u0026#34;) ) #| (define foo1 (let ((bar1 (/ 2 0))) ; * evaluted immediately (display \u0026#34;should not be printed\u0026#34;) ) ) |# (define foo2 (let ((bar2 (/ 5 2))) ; * evaluted immediately (newline) (display \u0026#34;let in `foo2`, bar2: \u0026#34;) (display bar2) ) ) ) 运行示例:\nfoo1: 可以看到 let 绑定被求值了, 否则不会抛出除零异常.\nprompt\u0026gt; (comp 4) else-clause ;Division by zero signalled by /. ;To continue, call RESTART with an option number: ;snip foo2: 可以看到 let 绑定后的表达式被求值了, 否则不会有 display 的输出\nprompt\u0026gt; (comp 2) then-clause let in `foo2`, bar2: 5/2 ;Unspecified return value if 的语义 if的语义: 根据对条件式进行求值，根据求值结果决定继续对 then/else 分支进行求值.\n可以与此对照参考的材料是 SICP (2nd Edition) Exercise 1.6，此题中使用 abstraction ，通过 cond 定义了 new-if:\n(define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause) ) ) 函数应用的语义是（applicative mode evaluation）：先对参数（比如这里的then-clause 和 else-clause）进行求值，然后进行函数应用，这也是为什么不能在then-clause 或 else-clause里写递归表达式，因为它们会先被求值，而不是根据 predicate 的值决定是否求值，于是递归就无穷无尽了. if/cond/\u0026hellip; 是 special form, 相较于通过 define 定义的 abstraction, 语义是特殊的. 我喜欢 new-if 这个例子，它简洁而有力地体现了 lisp 元编程的特性，通过此例也可以更好地接纳 lisp 里大量的括号，根据 substitution model, 这里的 predicate, then-clause, else-clause 可以替换成你需要的表达式, 而表达式就是被括号包裹的, 即 括号是表达式的边界, 你可以把被括号包裹的表达式放在任意的参数位 (当然要符合 abstraction 隐式的对于参数的类型约束).\nlet 立即求值引发的错误实例 对于这样素数判断的一段代码：\n(define (prime? x) (if (or (= x 1) (= x 2)) #t test_prime ) (define (divisible? y) (= 0 (remainder x y)) ) (define (iter_biggest_divisor y) (cond ((= y 1) 1) ((divisible? y) y) (else (iter_biggest_divisor (- y 1))) ) ) (define test_prime (let ((biggest_divisor (iter_biggest_divisor (quotient x 2)) )) ; Notice (display biggest_divisor) (if (= biggest_divisor 1) #t #f ) ) ) ) 运行的结果是:\nprompt\u0026gt; (prime? 1) ;The object 0, passed as the second argument to integer-remainder, is not in the correct range. prompt\u0026gt; (prime? 2) 1 ;Value: #t 按照预期, (prime? 1) 和 (prime? 2) 都应该直接返回 #t, 而不是前者报错, 后者呈现出 (display biggest_divisor) 的行为. 根据前文的陈述, 原因是: 整个 let scope 都被求值了.\n","date":"2024-08-29T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/scheme-let-%E7%9A%84%E8%AF%AD%E4%B9%89-feat.-if-%E7%9A%84%E8%AF%AD%E4%B9%89/","title":"Scheme: `let` 的语义 (feat. `if` 的语义)"},{"content":"不严肃的随手记录，希望我能记得持续更新，因为我经常把一些记录扔在零零散散的位置，然后忘记这个记录的存在。\n首先在这里贴蒋炎岩老师的一场与VSCode相关的讲座，Ctrl+Shift+P：如果你需要做某些事情，可以先尝试用 Ctrl+Shift+P 打开命令面板搜索（比如也许你想重新加载VSCode窗口，你就可以 Ctrl+Shift+P 然后搜索\u0026quot;reload window\u0026quot;），如果你发现自己需要经常做这个动作，那么就 Ctrl+k Ctrl+s 进入 Keyboard Shortcuts 为这个操作绑定快捷键吧，配置快捷键的哲学就在于：发现自己经常重复做某件事情，有一个瞬间发现自己不想用鼠标再次重复这个过程，于是去检索记忆/配置这个热键。\n(如果后续VSCode Command Palette接入了语言模型，可以进行自然语言的模糊搜素，那应该会很不错。)\n\u0026raquo; 让VSCode的界面更简洁：隐藏Activity Bar和Status Bar 其实并不是时时刻刻都需要看到 Activity Bar 和 Status Bar，如果你也觉得它们占用了宝贵的屏幕空间，那么可以绑定以下快捷键：\nView: Toggle Activity Bar Visibility - Ctrl+Shift+9 View: Toggle Status Bar Visibility - Ctrl+Shift+8\n为什么是Ctrl+Shift+8/9：因为Shift+9对应的字符是左括号，和Activity Bar在形态上略有相似，顺手把Status Bar对应的快捷键设置为Ctrl+Shift+8，键位近比较顺手，因为我总是同时关闭此二者的可见性；想快捷键还是一个不那么容易的事情，容易和已有的键位绑定冲突，设置完了一段时间不用又会忘记，然后发现Ctrl+Shift+P检索才是永远的家。\n\u0026raquo; Terminal: Move Terminal to Editor Area 之前看蒋炎岩老师的课的时候发现他的终端tab和代码tab的形态是一致的，现在我也知道怎么做了，先Ctrl+Shift+P，在命令面板中检索Terminal: Move Terminal to Editor Area，即可将终端放置到Editor Area，其他类似操作还有Move Terminal to Panel, Create New Terminal in Editor Area\u0026hellip;当然，可以为你经常使用的操作绑定快捷键。\n一种适用的场景是：如果你在学习某种编程语言，而这种语言（比如Haskell, Lisp, Python\u0026hellip;）刚好有REPL，你就可以在Editor Area切分，一半放代码，一半放Terminal REPL，如果需要，可以编辑文件，然后在REPL中导入代码文件（像Haskell ghci中的:l foo.hs），这样就很方便，可以通过Ctrl+1/Ctrl+2在代码tab和终端tab之间做Focus的切换；视觉上我认为这样的体验也一些，比默认的上下分屏更好（毕竟更多情况下电脑的屏幕水平边比竖直边长，这也是为什么我喜欢竖直向的浏览器标签栏）。\n还有一种类似的实现：通过Ctrl+Shift+B打开Secondary Side Bar，把终端拖到Secondary Side Bar，不过在我的Windows的VScode上，我不能把终端拖到Secondary Side Bar展示，很奇怪，之前在Linux虚拟机上是可以的。\n\u0026raquo; Rainbow Brackets 在Settings(GUI)中键入@id:editor.bracketPairColorization.enabled @id:editor.guides.bracketPairs，选择你需要的选项，editor.bracketPairColorization.enabled是默认启用的，editor.guides.bracketPairs是默认关闭(false)的，可以选择true或者active启用，true的效果是所有括号都有引导线，active的效果是只有最接近光标的外层括号有引导线，我觉得active就很好了，true让编辑界面有点花里胡哨。效果如下：\n顺便一个快捷键：Ctrl+Shift+\\，可以在当前文本对应的左右括号之间跳转，给别人展示代码的时候也许有用，对应Vim Normal Mode下的%.(P.S. 此快捷键在Terminal中使用，可以用来在不同的Terminal tab中跳转)\n起因是我最近在看SICP，这本书使用的语言是lisp(scheme)，这门语言的括号实在是多(，真的有其他语言的语言设计中具备比lisp更多的括号吗？) 于是我在Extensions中搜索Rainbow Brackets，对应插件表示项目已放弃维护，因为此特性已由VSCode内置，并为我指路至Settings(GUI)的配置具体位置。\n\u0026raquo; 一些常用的快捷键 Baseline\n将光标悬停在GUI的button上，如果该button有对应的快捷键，弹出的悬窗会呈现快捷键信息（很多程序都遵循这个设计哲学），所以如果发现自己经常点击某个键，不妨停下来看看它对应的热键是什么。\nCtrl-b：toggle side bar.\n这里对应的一个故事是，有人给VSCode提了一个issue，希望VSCode提供一个类似toggleExplorerVisibility配置项，然后获得一个用户回复\u0026quot;Ctrl-B to toggle side bar\u0026quot;并关闭了此issue. 为什么我会知道这件事情，因为我也以为我的需求是toggleExplorerVisibility，结论是：明确每个组件的称呼很重要。(但是，一个热键对应toggle，两个热键分别对应show/hide，前者应该更合理一些。)\nAlt-left/right Arrow：回退到上一光标位置/前进到下一光标位置\n比较有用的一个情景是：和F12配合，在函数的调用链里导航。\nCtrl-[/]：对光标所在行左移/右移缩进。\n同 Vim Visual Mode 下的 \u0026gt;/\u0026lt;. Vim的这个键位我用着一直不是很顺，因为选中之后只能进行一次操作，如果想再做一次缩进，那要再选一次，虽然是可以2 \u0026gt;这样向右缩进两个tab，但是对我来说还是没有那么顺，自从发现在编辑中使用 Ctrl/Shift/Alt 可以做一些跳转/选中等操作，我就很少离开Vim Insert Mode了，当然这些热键在语义化的方面是比不过Vim的键位。\nAlt-up/down Arrow：上移/下移光标所在行。\nShift-Alt-f: format 代码，前提是配置好了formatter.\n于是我不再需要手动调空格/空行的数量，Ctrl-v的时候也不必担心光标所在列，粘贴完一键format完事，很可惜像Python这样强制缩进的语言不太好format.\nCtrl-(Shift-)Enter: 在当前光标所在行下(上)方新建一行，光标跳转到新行行首。\n同 Vim Normal Mode 下的 o(O).\n","date":"2024-08-26T00:00:00+08:00","image":"http://fyshxfish.github.io/p/vscode-%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/cover_hu6990843420303988956.png","permalink":"http://fyshxfish.github.io/p/vscode-%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"VSCode 配置与使用记录"},{"content":" Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away. \u0026ndash; Antoine de Saint-Exupéry\n通过包管理器下载 mit-scheme MacOS:\nbrew install mit-scheme Ubuntu:\nsudo apt-get update sudo apt-get install mit-scheme REPL 基本使用 （REPL: Read-Evaluate-Print Loop）\n进入 REPL:\nmit-scheme 在 REPL 加载中加载 scheme 代码:\n1 ] =\u0026gt; (load \u0026#34;path/to/file.scm\u0026#34;) (后缀 .scm 可以省略.)\n查看手册:\nman mit-scheme 命令行查看 mit-scheme CLI 手册, 很简短, 可以通过命令行参数指定堆栈大小 / 加载文件 / 同时打开编辑器/ \u0026hellip;\n按下 Ctrl-C 后键入 H 查看中断手册:\nCtrl-C: 接收下一个键盘输入, 决定中断行为.\nCtrl-G: 回到 top-level\nCtrl-Z: 挂起当前 mit-scheme 进程\n按下 Ctrl-C 后键入 ? 查看手册: 下一键盘输入 (option) 与 REPL 行为 (清屏 / 挂起 / 退出 / 忽略中断 / \u0026hellip;) 的对应关系;\n如果 REPL 没有反应:\n检查括号是否逐对匹配;\nCtrl-C 中断后回到 REPL, 提示符 (1 ] =\u0026gt; / 2 error\u0026gt;) 不会重新显示.\n担心递归太深? 递归深度超限时, REPL 会提示 Recursion depth limit exceeded. Aborting! (3.1 中提到可以通过 CLI 参数指定堆栈大小, 即, mit-scheme使用的堆栈资源是有限的.)\nScHeMe Scheme 是大小写不敏感的语言.\n所以 (LoAd \u0026quot;path/to/file.scm\u0026quot;)/(DEFINE x 1)/(define x 1)/(defiNE x 1)/\u0026hellip; 都不会引发错误.\nHistory variable (procedure): 重用 REPL 求值后返回的 procedure:\n1 ]=\u0026gt; (average-dump square) ;Value: #[compound-procedure 12] ; 可以在后续表达式中重用, 就像 gdb 中的 history variable `$1` 1 ]=\u0026gt; (#[compound-procedure 12] 10) ; 虽然也不是很方便直接使用, 但是确实是能用 ;Value: 55 1 ]=\u0026gt; (define newfunc #[compound-procedure 12]) ; 可以绑定到一个标识符上, 再复用 ;Value: newfunc 1 ]=\u0026gt; (newfunc 10) ;Value: 55 后记 不知道是否有更好用的 Scheme REPL，这个 REPL 确实是比较原始，不支持历史表达式的回溯，不支持光标移动，但是一想到 lisp 历史这么悠久，语法本身十分简洁纯净，我就接受了一切。（不像写 Haskell 的时候 LSP 出了问题，我必通过重启 VSCode / 重启电脑 / 更改 LSP 版本先把 LSP 重新拉起来，而不是先把代码写了。）\n","date":"2024-08-24T00:00:00+08:00","permalink":"http://fyshxfish.github.io/p/mit-scheme-%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"mit-scheme 配置与基本使用"},{"content":" ghcup 修复 终端使用ghcup直接被杀进程，输出大致如：ghcup terminated by SIGKILL\n使用ghcup官网上的命令通过curl重新安装，会得到一句红色的报错信息\u0026quot;ghcup --metadata-fetching-mode=Strict upgrade\u0026quot; failed!\n不知道是不是因为太久没打开了，解决方式是清除缓存：rm -rf ~/.ghcup/cache\nghcup 配置环境 ghcup tui下载和设置HLS和ghc（以及stack, cabal）版本，\nghc版本：注意ghc的备注信息中需要有hls-powered，不知道为什么我的mac上的版本是9.4.7，正好没有hls支持（9.8.4是有hls支持的），当时下载的时机这么刚好吗。\nHLS版本：VSCode的Haskell插件会要求HLS是最新的版本，所以就直接下最新的版本吧，VSCode弹出提示\u0026quot;Haskell插件需要2.9.0.1的HLS，是否下载\u0026quot;，这里的下载比较慢，而且看不到进度，所以可以直接在终端的ghcup下载，然后回到VSC（重启？反正我重启了），插件就可以正常使用了。\nHLS 无法正常工作也可以尝试通过 ghcup tui 下载并切换 HLS 的版本。\n一个网络问题 在第一步中修复ghcup之后，使用ghcup会遇到这样的报错：\n根据提示执行：ghcup config set downloader Wget，再次使用ghcup，得到差不多一样的报错：\n关于yaml：尝试过最后一行的removing \u0026hellip;yaml，结果为本机中确实不存在这个文件，所以不是这里的问题。\n解决方式：复制clash的终端代理命令，就不会报这个错了，同时下载速度得到了极大提升。\n","date":"2024-08-16T00:00:00Z","permalink":"http://fyshxfish.github.io/p/haskell%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-ghcup--hls-%E4%BF%AE%E5%A4%8D%E8%AE%B0%E5%BD%95/","title":"Haskell开发环境 (GHCup + HLS) 修复记录"},{"content":" 如何调试一个rust程序？ $ gdb excutable 简单的示例：\n查看变量的地址：\n格式化p s的输出：\n$17 = alloc::string::String { vec: alloc::vec::Vec\u0026lt;u8, alloc::alloc::Global\u0026gt; { buf: alloc::raw_vec::RawVec\u0026lt;u8, alloc::alloc::Global\u0026gt; { ptr: core::ptr::unique::Unique\u0026lt;u8\u0026gt; { pointer: core::ptr::non_null::NonNull\u0026lt;u8\u0026gt; { pointer: 0x5555555abb80 }, _marker: core::marker::PhantomData\u0026lt;u8\u0026gt; }, cap: alloc::raw_vec::Cap (16), alloc: alloc::alloc::Global }, len: 16 } } 提要：p \u0026lt;variable\u0026gt; p \u0026amp;\u0026lt;variable\u0026gt; ptype \u0026lt;variable\u0026gt;\ndbg! 辅助输出调试信息中的所有权问题 错误的：\ndbg!(var); // move dbg!(var); // invalid reference dbg!将拿走var的所有权(Move)，var就不能再用了。\n正确的：\ndbg!(\u0026amp;var); // or let new_var = dbg!(var); dbg!(\u0026amp;new_var); // if u will 关于 gdb 对于想探究的东西，使用gdb去进行探索，例如：[enum的底层表示？] -\u0026gt; 写一个简单的例程，编译成可执行文件，然后进行gdb，使用print var print \u0026amp;var x/x \u0026lt;addr\u0026gt;进行探索。\n关于对 vector 的引用 一个摘录\nch08-01\n/* CANNOT COMPILE */ let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n一个问题：如何让一个Vector看起来存储了多种类型的数据？ 答案：让Vector存储enum，enum含有多种类型的variant，在某种程度上可以说Vector存储了多种类型的数据。\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Text(String::from(\u0026#34;word\u0026#34;)), CellType::Float(3.14), ]; let v1 = \u0026amp;v[0]; } enum CellType { Int(i32), Float(f64), Text(String), } gdb 调试 enum 示例与 gdb（以及其他REPL）中的 history variable 源代码：\nfn main(){ let v: Vec\u0026lt;CellType\u0026gt; = vec![ CellType::Int(12), CellType::Float(3.14), ]; let v1: \u0026amp;CellType = \u0026amp;v[0]; let v2: \u0026amp;CellType = \u0026amp;v[1]; println!(\u0026#34;END\u0026#34;); } enum CellType { Int(i32), Float(f64), } 调试实录：\np v1：打印v1: \u0026amp;CellType的值，也就是指针值，即附带数据存储在堆上的地址，注意到v1, v2对应的数据各占据了16个字节。 x/4x $1：检查v1指针指向的16字节 p *v1：解引用v1查看该内存处存储的实际值 enum在计算机中存储的实际数据分析\n第一个字节应该是variant标识符，对应关系：0-Int 1-Float Int：附带数据存储在第二个字节，0x0000000c即代码中的Int(12) Float：附带的数据存储在第三、四个字节0x40091eb8_51eb851f是3.14的IEEE 754 64bit表示 遗留的问题：为什么上述两变体存储附加数据的位置不同，Float中的0x00005555是什么？ gdb的使用拾遗 (history variable)：\np var 打印出来的 $x 是一种 history variable, 供用户后续复用的，类似的 REPL 行为还有bash 里 echo $(ls)，mit-scheme 也会为返回的 procedure 给出一个可引用的 history variable（不过这个 variable 很长，且包含了 #[] 等特殊字符，真正要复用还是要复制一遍标识符，绑定在某个标识符上再复用。）。\nRUST_BACKTRACE 与命令行拾遗 $ RUST_BACKTRACE=1 cargo run $ A=12 B=23 echo \u0026#34;$A $B\u0026#34; 在命令的最左可以写临时的环境变量。\n花里胡哨的技术：rust的println的色彩转义 println!(\u0026#34;\\x1b[34mMESSAGE\\x1b[0m\u0026#34;); 使用\\x1b[34m进行转义\n\\x1b是什么？\n\\x表十六进制，1b是ESC的ASCII十六进制码\nResult\u0026lt;T, E\u0026gt;的unwrap和expect 之间的区别： 适当地看一些库函数的实现，可以对封装好的函数有更具体的了解，例如Result\u0026lt;T, E\u0026gt;的unwrap和expect，看过源码就可以知道这两者的区别在于何处（只在于unwrap_failed的msg参数，至于unwrap_failed只是一个对panic!的封装）：\nimpl\u0026lt;T, E\u0026gt; Result\u0026lt;Result\u0026lt;T, E\u0026gt;, E\u0026gt; { ... pub fn expect(self, msg: \u0026amp;str) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(msg, \u0026amp;e), } } pub fn unwrap(self) -\u0026gt; T where E: fmt::Debug, { match self { Ok(t) =\u0026gt; t, Err(e) =\u0026gt; unwrap_failed(\u0026#34;called `Result::unwrap()` on an `Err` value\u0026#34;, \u0026amp;e), } } ... } fn unwrap_failed(msg: \u0026amp;str, error: \u0026amp;dyn fmt::Debug) -\u0026gt; ! { panic!(\u0026#34;{msg}: {error:?}\u0026#34;) } ","date":"2024-08-05T00:00:00Z","permalink":"http://fyshxfish.github.io/p/rust-%E5%9F%BA%E7%A1%80%E4%B8%8E-gdb-%E4%BD%BF%E7%94%A8%E6%8B%BE%E9%81%97/","title":"Rust 基础与 gdb 使用拾遗"}]